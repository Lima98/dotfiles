{
  "version": 3,
  "sources": ["../node_modules/is-plain-obj/index.js", "../node_modules/execa/lib/arguments/file-url.js", "../node_modules/execa/lib/methods/parameters.js", "../node_modules/execa/lib/utils/uint-array.js", "../node_modules/execa/lib/methods/template.js", "../node_modules/execa/lib/utils/standard-stream.js", "../node_modules/execa/lib/arguments/specific.js", "../node_modules/execa/lib/verbose/values.js", "../node_modules/execa/lib/arguments/escape.js", "../node_modules/is-unicode-supported/index.js", "../node_modules/figures/index.js", "../node_modules/yoctocolors/base.js", "../node_modules/yoctocolors/index.js", "../node_modules/execa/lib/verbose/default.js", "../node_modules/execa/lib/verbose/custom.js", "../node_modules/execa/lib/verbose/log.js", "../node_modules/execa/lib/verbose/start.js", "../node_modules/execa/lib/verbose/info.js", "../node_modules/execa/lib/return/duration.js", "../node_modules/execa/lib/arguments/command.js", "../node_modules/isexe/windows.js", "../node_modules/isexe/mode.js", "../node_modules/isexe/index.js", "../node_modules/which/which.js", "../node_modules/path-key/index.js", "../node_modules/cross-spawn/lib/util/resolveCommand.js", "../node_modules/cross-spawn/lib/util/escape.js", "../node_modules/shebang-regex/index.js", "../node_modules/shebang-command/index.js", "../node_modules/cross-spawn/lib/util/readShebang.js", "../node_modules/cross-spawn/lib/parse.js", "../node_modules/cross-spawn/lib/enoent.js", "../node_modules/cross-spawn/index.js", "../node_modules/npm-run-path/node_modules/path-key/index.js", "../node_modules/unicorn-magic/default.js", "../node_modules/unicorn-magic/node.js", "../node_modules/npm-run-path/index.js", "../node_modules/execa/lib/return/final-error.js", "../node_modules/human-signals/build/src/realtime.js", "../node_modules/human-signals/build/src/core.js", "../node_modules/human-signals/build/src/signals.js", "../node_modules/human-signals/build/src/main.js", "../node_modules/execa/lib/terminate/signal.js", "../node_modules/execa/lib/terminate/kill.js", "../node_modules/execa/lib/utils/abort-signal.js", "../node_modules/execa/lib/terminate/cancel.js", "../node_modules/execa/lib/ipc/validation.js", "../node_modules/execa/lib/utils/deferred.js", "../node_modules/execa/lib/arguments/fd-options.js", "../node_modules/execa/lib/utils/max-listeners.js", "../node_modules/execa/lib/ipc/reference.js", "../node_modules/execa/lib/ipc/incoming.js", "../node_modules/execa/lib/ipc/forward.js", "../node_modules/execa/lib/ipc/strict.js", "../node_modules/execa/lib/ipc/outgoing.js", "../node_modules/execa/lib/ipc/send.js", "../node_modules/execa/lib/ipc/graceful.js", "../node_modules/execa/lib/terminate/graceful.js", "../node_modules/execa/lib/terminate/timeout.js", "../node_modules/execa/lib/methods/node.js", "../node_modules/execa/lib/ipc/ipc-input.js", "../node_modules/execa/lib/arguments/encoding-option.js", "../node_modules/execa/lib/arguments/cwd.js", "../node_modules/execa/lib/arguments/options.js", "../node_modules/execa/lib/arguments/shell.js", "../node_modules/strip-final-newline/index.js", "../node_modules/is-stream/index.js", "../node_modules/@sec-ant/readable-stream/dist/ponyfill/asyncIterator.js", "../node_modules/@sec-ant/readable-stream/dist/ponyfill/fromAnyIterable.js", "../node_modules/@sec-ant/readable-stream/dist/ponyfill/index.js", "../node_modules/get-stream/source/stream.js", "../node_modules/get-stream/source/contents.js", "../node_modules/get-stream/source/utils.js", "../node_modules/get-stream/source/array.js", "../node_modules/get-stream/source/array-buffer.js", "../node_modules/get-stream/source/string.js", "../node_modules/get-stream/source/exports.js", "../node_modules/get-stream/source/index.js", "../node_modules/execa/lib/io/max-buffer.js", "../node_modules/execa/lib/return/message.js", "../node_modules/execa/lib/return/result.js", "../node_modules/parse-ms/index.js", "../node_modules/pretty-ms/index.js", "../node_modules/execa/lib/verbose/error.js", "../node_modules/execa/lib/verbose/complete.js", "../node_modules/execa/lib/return/reject.js", "../node_modules/execa/lib/stdio/type.js", "../node_modules/execa/lib/transform/object-mode.js", "../node_modules/execa/lib/transform/normalize.js", "../node_modules/execa/lib/stdio/direction.js", "../node_modules/execa/lib/ipc/array.js", "../node_modules/execa/lib/stdio/stdio-option.js", "../node_modules/execa/lib/stdio/native.js", "../node_modules/execa/lib/stdio/input-option.js", "../node_modules/execa/lib/stdio/duplicate.js", "../node_modules/execa/lib/stdio/handle.js", "../node_modules/execa/lib/stdio/handle-sync.js", "../node_modules/execa/lib/io/strip-newline.js", "../node_modules/execa/lib/transform/split.js", "../node_modules/execa/lib/transform/validate.js", "../node_modules/execa/lib/transform/encoding-transform.js", "../node_modules/execa/lib/transform/run-async.js", "../node_modules/execa/lib/transform/run-sync.js", "../node_modules/execa/lib/transform/generator.js", "../node_modules/execa/lib/io/input-sync.js", "../node_modules/execa/lib/verbose/output.js", "../node_modules/execa/lib/io/output-sync.js", "../node_modules/execa/lib/resolve/all-sync.js", "../node_modules/execa/lib/resolve/exit-async.js", "../node_modules/execa/lib/resolve/exit-sync.js", "../node_modules/execa/lib/methods/main-sync.js", "../node_modules/execa/lib/ipc/get-one.js", "../node_modules/execa/lib/ipc/get-each.js", "../node_modules/execa/lib/ipc/methods.js", "../node_modules/execa/lib/return/early-error.js", "../node_modules/execa/lib/stdio/handle-async.js", "../node_modules/@sindresorhus/merge-streams/index.js", "../node_modules/execa/lib/io/pipeline.js", "../node_modules/execa/lib/io/output-async.js", "../node_modules/signal-exit/src/signals.ts", "../node_modules/signal-exit/src/index.ts", "../node_modules/execa/lib/terminate/cleanup.js", "../node_modules/execa/lib/pipe/pipe-arguments.js", "../node_modules/execa/lib/pipe/throw.js", "../node_modules/execa/lib/pipe/sequence.js", "../node_modules/execa/lib/pipe/streaming.js", "../node_modules/execa/lib/pipe/abort.js", "../node_modules/execa/lib/pipe/setup.js", "../node_modules/execa/lib/io/iterate.js", "../node_modules/execa/lib/io/contents.js", "../node_modules/execa/lib/resolve/wait-stream.js", "../node_modules/execa/lib/resolve/stdio.js", "../node_modules/execa/lib/resolve/all-async.js", "../node_modules/execa/lib/verbose/ipc.js", "../node_modules/execa/lib/ipc/buffer-messages.js", "../node_modules/execa/lib/resolve/wait-subprocess.js", "../node_modules/execa/lib/convert/concurrent.js", "../node_modules/execa/lib/convert/shared.js", "../node_modules/execa/lib/convert/readable.js", "../node_modules/execa/lib/convert/writable.js", "../node_modules/execa/lib/convert/duplex.js", "../node_modules/execa/lib/convert/iterable.js", "../node_modules/execa/lib/convert/add.js", "../node_modules/execa/lib/methods/promise.js", "../node_modules/execa/lib/methods/main-async.js", "../node_modules/execa/lib/methods/bind.js", "../node_modules/execa/lib/methods/create.js", "../node_modules/execa/lib/methods/command.js", "../node_modules/execa/lib/methods/script.js", "../node_modules/execa/index.js", "../src/platform/macos.ts", "../src/platform/windows.ts", "../src/auto-switch-input.ts", "../src/auto-switcher.ts", "../src/platform/index.ts", "../src/audio-device.ts", "../src/device-actions.ts", "../src/auto-switch-keys.ts", "../src/device-preferences.ts"],
  "sourcesContent": ["export default function isPlainObject(value) {\n\tif (typeof value !== 'object' || value === null) {\n\t\treturn false;\n\t}\n\n\tconst prototype = Object.getPrototypeOf(value);\n\treturn (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);\n}\n", "import {fileURLToPath} from 'node:url';\n\n// Allow some arguments/options to be either a file path string or a file URL\nexport const safeNormalizeFileUrl = (file, name) => {\n\tconst fileString = normalizeFileUrl(normalizeDenoExecPath(file));\n\n\tif (typeof fileString !== 'string') {\n\t\tthrow new TypeError(`${name} must be a string or a file URL: ${fileString}.`);\n\t}\n\n\treturn fileString;\n};\n\n// In Deno node:process execPath is a special object, not just a string:\n// https://github.com/denoland/deno/blob/f460188e583f00144000aa0d8ade08218d47c3c1/ext/node/polyfills/process.ts#L344\nconst normalizeDenoExecPath = file => isDenoExecPath(file)\n\t? file.toString()\n\t: file;\n\nexport const isDenoExecPath = file => typeof file !== 'string'\n\t&& file\n\t&& Object.getPrototypeOf(file) === String.prototype;\n\n// Same but also allows other values, e.g. `boolean` for the `shell` option\nexport const normalizeFileUrl = file => file instanceof URL ? fileURLToPath(file) : file;\n", "import isPlainObject from 'is-plain-obj';\nimport {safeNormalizeFileUrl} from '../arguments/file-url.js';\n\n// The command `arguments` and `options` are both optional.\n// This also does basic validation on them and on the command file.\nexport const normalizeParameters = (rawFile, rawArguments = [], rawOptions = {}) => {\n\tconst filePath = safeNormalizeFileUrl(rawFile, 'First argument');\n\tconst [commandArguments, options] = isPlainObject(rawArguments)\n\t\t? [[], rawArguments]\n\t\t: [rawArguments, rawOptions];\n\n\tif (!Array.isArray(commandArguments)) {\n\t\tthrow new TypeError(`Second argument must be either an array of arguments or an options object: ${commandArguments}`);\n\t}\n\n\tif (commandArguments.some(commandArgument => typeof commandArgument === 'object' && commandArgument !== null)) {\n\t\tthrow new TypeError(`Second argument must be an array of strings: ${commandArguments}`);\n\t}\n\n\tconst normalizedArguments = commandArguments.map(String);\n\tconst nullByteArgument = normalizedArguments.find(normalizedArgument => normalizedArgument.includes('\\0'));\n\tif (nullByteArgument !== undefined) {\n\t\tthrow new TypeError(`Arguments cannot contain null bytes (\"\\\\0\"): ${nullByteArgument}`);\n\t}\n\n\tif (!isPlainObject(options)) {\n\t\tthrow new TypeError(`Last argument must be an options object: ${options}`);\n\t}\n\n\treturn [filePath, normalizedArguments, options];\n};\n", "import {StringDecoder} from 'node:string_decoder';\n\nconst {toString: objectToString} = Object.prototype;\n\nexport const isArrayBuffer = value => objectToString.call(value) === '[object ArrayBuffer]';\n\n// Is either Uint8Array or Buffer\nexport const isUint8Array = value => objectToString.call(value) === '[object Uint8Array]';\n\nexport const bufferToUint8Array = buffer => new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n\nconst textEncoder = new TextEncoder();\nconst stringToUint8Array = string => textEncoder.encode(string);\n\nconst textDecoder = new TextDecoder();\nexport const uint8ArrayToString = uint8Array => textDecoder.decode(uint8Array);\n\nexport const joinToString = (uint8ArraysOrStrings, encoding) => {\n\tconst strings = uint8ArraysToStrings(uint8ArraysOrStrings, encoding);\n\treturn strings.join('');\n};\n\nconst uint8ArraysToStrings = (uint8ArraysOrStrings, encoding) => {\n\tif (encoding === 'utf8' && uint8ArraysOrStrings.every(uint8ArrayOrString => typeof uint8ArrayOrString === 'string')) {\n\t\treturn uint8ArraysOrStrings;\n\t}\n\n\tconst decoder = new StringDecoder(encoding);\n\tconst strings = uint8ArraysOrStrings\n\t\t.map(uint8ArrayOrString => typeof uint8ArrayOrString === 'string'\n\t\t\t? stringToUint8Array(uint8ArrayOrString)\n\t\t\t: uint8ArrayOrString)\n\t\t.map(uint8Array => decoder.write(uint8Array));\n\tconst finalString = decoder.end();\n\treturn finalString === '' ? strings : [...strings, finalString];\n};\n\nexport const joinToUint8Array = uint8ArraysOrStrings => {\n\tif (uint8ArraysOrStrings.length === 1 && isUint8Array(uint8ArraysOrStrings[0])) {\n\t\treturn uint8ArraysOrStrings[0];\n\t}\n\n\treturn concatUint8Arrays(stringsToUint8Arrays(uint8ArraysOrStrings));\n};\n\nconst stringsToUint8Arrays = uint8ArraysOrStrings => uint8ArraysOrStrings.map(uint8ArrayOrString => typeof uint8ArrayOrString === 'string'\n\t? stringToUint8Array(uint8ArrayOrString)\n\t: uint8ArrayOrString);\n\nexport const concatUint8Arrays = uint8Arrays => {\n\tconst result = new Uint8Array(getJoinLength(uint8Arrays));\n\n\tlet index = 0;\n\tfor (const uint8Array of uint8Arrays) {\n\t\tresult.set(uint8Array, index);\n\t\tindex += uint8Array.length;\n\t}\n\n\treturn result;\n};\n\nconst getJoinLength = uint8Arrays => {\n\tlet joinLength = 0;\n\tfor (const uint8Array of uint8Arrays) {\n\t\tjoinLength += uint8Array.length;\n\t}\n\n\treturn joinLength;\n};\n", "import {ChildProcess} from 'node:child_process';\nimport isPlainObject from 'is-plain-obj';\nimport {isUint8Array, uint8ArrayToString} from '../utils/uint-array.js';\n\n// Check whether the template string syntax is being used\nexport const isTemplateString = templates => Array.isArray(templates) && Array.isArray(templates.raw);\n\n// Convert execa`file ...commandArguments` to execa(file, commandArguments)\nexport const parseTemplates = (templates, expressions) => {\n\tlet tokens = [];\n\n\tfor (const [index, template] of templates.entries()) {\n\t\ttokens = parseTemplate({\n\t\t\ttemplates,\n\t\t\texpressions,\n\t\t\ttokens,\n\t\t\tindex,\n\t\t\ttemplate,\n\t\t});\n\t}\n\n\tif (tokens.length === 0) {\n\t\tthrow new TypeError('Template script must not be empty');\n\t}\n\n\tconst [file, ...commandArguments] = tokens;\n\treturn [file, commandArguments, {}];\n};\n\nconst parseTemplate = ({templates, expressions, tokens, index, template}) => {\n\tif (template === undefined) {\n\t\tthrow new TypeError(`Invalid backslash sequence: ${templates.raw[index]}`);\n\t}\n\n\tconst {nextTokens, leadingWhitespaces, trailingWhitespaces} = splitByWhitespaces(template, templates.raw[index]);\n\tconst newTokens = concatTokens(tokens, nextTokens, leadingWhitespaces);\n\n\tif (index === expressions.length) {\n\t\treturn newTokens;\n\t}\n\n\tconst expression = expressions[index];\n\tconst expressionTokens = Array.isArray(expression)\n\t\t? expression.map(expression => parseExpression(expression))\n\t\t: [parseExpression(expression)];\n\treturn concatTokens(newTokens, expressionTokens, trailingWhitespaces);\n};\n\n// Like `string.split(/[ \\t\\r\\n]+/)` except newlines and tabs are:\n//  - ignored when input as a backslash sequence like: `echo foo\\n bar`\n//  - not ignored when input directly\n// The only way to distinguish those in JavaScript is to use a tagged template and compare:\n//  - the first array argument, which does not escape backslash sequences\n//  - its `raw` property, which escapes them\nconst splitByWhitespaces = (template, rawTemplate) => {\n\tif (rawTemplate.length === 0) {\n\t\treturn {nextTokens: [], leadingWhitespaces: false, trailingWhitespaces: false};\n\t}\n\n\tconst nextTokens = [];\n\tlet templateStart = 0;\n\tconst leadingWhitespaces = DELIMITERS.has(rawTemplate[0]);\n\n\tfor (\n\t\tlet templateIndex = 0, rawIndex = 0;\n\t\ttemplateIndex < template.length;\n\t\ttemplateIndex += 1, rawIndex += 1\n\t) {\n\t\tconst rawCharacter = rawTemplate[rawIndex];\n\t\tif (DELIMITERS.has(rawCharacter)) {\n\t\t\tif (templateStart !== templateIndex) {\n\t\t\t\tnextTokens.push(template.slice(templateStart, templateIndex));\n\t\t\t}\n\n\t\t\ttemplateStart = templateIndex + 1;\n\t\t} else if (rawCharacter === '\\\\') {\n\t\t\tconst nextRawCharacter = rawTemplate[rawIndex + 1];\n\t\t\tif (nextRawCharacter === '\\n') {\n\t\t\t\t// Handles escaped newlines in templates\n\t\t\t\ttemplateIndex -= 1;\n\t\t\t\trawIndex += 1;\n\t\t\t} else if (nextRawCharacter === 'u' && rawTemplate[rawIndex + 2] === '{') {\n\t\t\t\trawIndex = rawTemplate.indexOf('}', rawIndex + 3);\n\t\t\t} else {\n\t\t\t\trawIndex += ESCAPE_LENGTH[nextRawCharacter] ?? 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tconst trailingWhitespaces = templateStart === template.length;\n\tif (!trailingWhitespaces) {\n\t\tnextTokens.push(template.slice(templateStart));\n\t}\n\n\treturn {nextTokens, leadingWhitespaces, trailingWhitespaces};\n};\n\nconst DELIMITERS = new Set([' ', '\\t', '\\r', '\\n']);\n\n// Number of characters in backslash escape sequences: \\0 \\xXX or \\uXXXX\n// \\cX is allowed in RegExps but not in strings\n// Octal sequences are not allowed in strict mode\nconst ESCAPE_LENGTH = {x: 3, u: 5};\n\nconst concatTokens = (tokens, nextTokens, isSeparated) => isSeparated\n\t|| tokens.length === 0\n\t|| nextTokens.length === 0\n\t? [...tokens, ...nextTokens]\n\t: [\n\t\t...tokens.slice(0, -1),\n\t\t`${tokens.at(-1)}${nextTokens[0]}`,\n\t\t...nextTokens.slice(1),\n\t];\n\n// Handle `${expression}` inside the template string syntax\nconst parseExpression = expression => {\n\tconst typeOfExpression = typeof expression;\n\n\tif (typeOfExpression === 'string') {\n\t\treturn expression;\n\t}\n\n\tif (typeOfExpression === 'number') {\n\t\treturn String(expression);\n\t}\n\n\tif (isPlainObject(expression) && ('stdout' in expression || 'isMaxBuffer' in expression)) {\n\t\treturn getSubprocessResult(expression);\n\t}\n\n\tif (expression instanceof ChildProcess || Object.prototype.toString.call(expression) === '[object Promise]') {\n\t\t// eslint-disable-next-line no-template-curly-in-string\n\t\tthrow new TypeError('Unexpected subprocess in template expression. Please use ${await subprocess} instead of ${subprocess}.');\n\t}\n\n\tthrow new TypeError(`Unexpected \"${typeOfExpression}\" in template expression`);\n};\n\nconst getSubprocessResult = ({stdout}) => {\n\tif (typeof stdout === 'string') {\n\t\treturn stdout;\n\t}\n\n\tif (isUint8Array(stdout)) {\n\t\treturn uint8ArrayToString(stdout);\n\t}\n\n\tif (stdout === undefined) {\n\t\tthrow new TypeError('Missing result.stdout in template expression. This is probably due to the previous subprocess\\' \"stdout\" option.');\n\t}\n\n\tthrow new TypeError(`Unexpected \"${typeof stdout}\" stdout in template expression`);\n};\n", "import process from 'node:process';\n\nexport const isStandardStream = stream => STANDARD_STREAMS.includes(stream);\nexport const STANDARD_STREAMS = [process.stdin, process.stdout, process.stderr];\nexport const STANDARD_STREAMS_ALIASES = ['stdin', 'stdout', 'stderr'];\nexport const getStreamName = fdNumber => STANDARD_STREAMS_ALIASES[fdNumber] ?? `stdio[${fdNumber}]`;\n", "import {debuglog} from 'node:util';\nimport isPlainObject from 'is-plain-obj';\nimport {STANDARD_STREAMS_ALIASES} from '../utils/standard-stream.js';\n\n// Some options can have different values for `stdout`/`stderr`/`fd3`.\n// This normalizes those to array of values.\n// For example, `{verbose: {stdout: 'none', stderr: 'full'}}` becomes `{verbose: ['none', 'none', 'full']}`\nexport const normalizeFdSpecificOptions = options => {\n\tconst optionsCopy = {...options};\n\n\tfor (const optionName of FD_SPECIFIC_OPTIONS) {\n\t\toptionsCopy[optionName] = normalizeFdSpecificOption(options, optionName);\n\t}\n\n\treturn optionsCopy;\n};\n\nexport const normalizeFdSpecificOption = (options, optionName) => {\n\tconst optionBaseArray = Array.from({length: getStdioLength(options) + 1});\n\tconst optionArray = normalizeFdSpecificValue(options[optionName], optionBaseArray, optionName);\n\treturn addDefaultValue(optionArray, optionName);\n};\n\nconst getStdioLength = ({stdio}) => Array.isArray(stdio)\n\t? Math.max(stdio.length, STANDARD_STREAMS_ALIASES.length)\n\t: STANDARD_STREAMS_ALIASES.length;\n\nconst normalizeFdSpecificValue = (optionValue, optionArray, optionName) => isPlainObject(optionValue)\n\t? normalizeOptionObject(optionValue, optionArray, optionName)\n\t: optionArray.fill(optionValue);\n\nconst normalizeOptionObject = (optionValue, optionArray, optionName) => {\n\tfor (const fdName of Object.keys(optionValue).sort(compareFdName)) {\n\t\tfor (const fdNumber of parseFdName(fdName, optionName, optionArray)) {\n\t\t\toptionArray[fdNumber] = optionValue[fdName];\n\t\t}\n\t}\n\n\treturn optionArray;\n};\n\n// Ensure priority order when setting both `stdout`/`stderr`, `fd1`/`fd2`, and `all`\nconst compareFdName = (fdNameA, fdNameB) => getFdNameOrder(fdNameA) < getFdNameOrder(fdNameB) ? 1 : -1;\n\nconst getFdNameOrder = fdName => {\n\tif (fdName === 'stdout' || fdName === 'stderr') {\n\t\treturn 0;\n\t}\n\n\treturn fdName === 'all' ? 2 : 1;\n};\n\nconst parseFdName = (fdName, optionName, optionArray) => {\n\tif (fdName === 'ipc') {\n\t\treturn [optionArray.length - 1];\n\t}\n\n\tconst fdNumber = parseFd(fdName);\n\tif (fdNumber === undefined || fdNumber === 0) {\n\t\tthrow new TypeError(`\"${optionName}.${fdName}\" is invalid.\nIt must be \"${optionName}.stdout\", \"${optionName}.stderr\", \"${optionName}.all\", \"${optionName}.ipc\", or \"${optionName}.fd3\", \"${optionName}.fd4\" (and so on).`);\n\t}\n\n\tif (fdNumber >= optionArray.length) {\n\t\tthrow new TypeError(`\"${optionName}.${fdName}\" is invalid: that file descriptor does not exist.\nPlease set the \"stdio\" option to ensure that file descriptor exists.`);\n\t}\n\n\treturn fdNumber === 'all' ? [1, 2] : [fdNumber];\n};\n\n// Use the same syntax for fd-specific options and the `from`/`to` options\nexport const parseFd = fdName => {\n\tif (fdName === 'all') {\n\t\treturn fdName;\n\t}\n\n\tif (STANDARD_STREAMS_ALIASES.includes(fdName)) {\n\t\treturn STANDARD_STREAMS_ALIASES.indexOf(fdName);\n\t}\n\n\tconst regexpResult = FD_REGEXP.exec(fdName);\n\tif (regexpResult !== null) {\n\t\treturn Number(regexpResult[1]);\n\t}\n};\n\nconst FD_REGEXP = /^fd(\\d+)$/;\n\nconst addDefaultValue = (optionArray, optionName) => optionArray.map(optionValue => optionValue === undefined\n\t? DEFAULT_OPTIONS[optionName]\n\t: optionValue);\n\n// Default value for the `verbose` option\nconst verboseDefault = debuglog('execa').enabled ? 'full' : 'none';\n\nconst DEFAULT_OPTIONS = {\n\tlines: false,\n\tbuffer: true,\n\tmaxBuffer: 1000 * 1000 * 100,\n\tverbose: verboseDefault,\n\tstripFinalNewline: true,\n};\n\n// List of options which can have different values for `stdout`/`stderr`\nexport const FD_SPECIFIC_OPTIONS = ['lines', 'buffer', 'maxBuffer', 'verbose', 'stripFinalNewline'];\n\n// Retrieve fd-specific option\nexport const getFdSpecificValue = (optionArray, fdNumber) => fdNumber === 'ipc'\n\t? optionArray.at(-1)\n\t: optionArray[fdNumber];\n", "import {getFdSpecificValue} from '../arguments/specific.js';\n\n// The `verbose` option can have different values for `stdout`/`stderr`\nexport const isVerbose = ({verbose}, fdNumber) => getFdVerbose(verbose, fdNumber) !== 'none';\n\n// Whether IPC and output and logged\nexport const isFullVerbose = ({verbose}, fdNumber) => !['none', 'short'].includes(getFdVerbose(verbose, fdNumber));\n\n// The `verbose` option can be a function to customize logging\nexport const getVerboseFunction = ({verbose}, fdNumber) => {\n\tconst fdVerbose = getFdVerbose(verbose, fdNumber);\n\treturn isVerboseFunction(fdVerbose) ? fdVerbose : undefined;\n};\n\n// When using `verbose: {stdout, stderr, fd3, ipc}`:\n//  - `verbose.stdout|stderr|fd3` is used for 'output'\n//  - `verbose.ipc` is only used for 'ipc'\n//  - highest `verbose.*` value is used for 'command', 'error' and 'duration'\nconst getFdVerbose = (verbose, fdNumber) => fdNumber === undefined\n\t? getFdGenericVerbose(verbose)\n\t: getFdSpecificValue(verbose, fdNumber);\n\n// When using `verbose: {stdout, stderr, fd3, ipc}` and logging is not specific to a file descriptor.\n// We then use the highest `verbose.*` value, using the following order:\n//  - function > 'full' > 'short' > 'none'\n//  - if several functions are defined: stdout > stderr > fd3 > ipc\nconst getFdGenericVerbose = verbose => verbose.find(fdVerbose => isVerboseFunction(fdVerbose))\n\t?? VERBOSE_VALUES.findLast(fdVerbose => verbose.includes(fdVerbose));\n\n// Whether the `verbose` option is customized using a function\nexport const isVerboseFunction = fdVerbose => typeof fdVerbose === 'function';\n\nexport const VERBOSE_VALUES = ['none', 'short', 'full'];\n", "import {platform} from 'node:process';\nimport {stripVTControlCharacters} from 'node:util';\n\n// Compute `result.command` and `result.escapedCommand`\nexport const joinCommand = (filePath, rawArguments) => {\n\tconst fileAndArguments = [filePath, ...rawArguments];\n\tconst command = fileAndArguments.join(' ');\n\tconst escapedCommand = fileAndArguments\n\t\t.map(fileAndArgument => quoteString(escapeControlCharacters(fileAndArgument)))\n\t\t.join(' ');\n\treturn {command, escapedCommand};\n};\n\n// Remove ANSI sequences and escape control characters and newlines\nexport const escapeLines = lines => stripVTControlCharacters(lines)\n\t.split('\\n')\n\t.map(line => escapeControlCharacters(line))\n\t.join('\\n');\n\nconst escapeControlCharacters = line => line.replaceAll(SPECIAL_CHAR_REGEXP, character => escapeControlCharacter(character));\n\nconst escapeControlCharacter = character => {\n\tconst commonEscape = COMMON_ESCAPES[character];\n\tif (commonEscape !== undefined) {\n\t\treturn commonEscape;\n\t}\n\n\tconst codepoint = character.codePointAt(0);\n\tconst codepointHex = codepoint.toString(16);\n\treturn codepoint <= ASTRAL_START\n\t\t? `\\\\u${codepointHex.padStart(4, '0')}`\n\t\t: `\\\\U${codepointHex}`;\n};\n\n// Characters that would create issues when printed are escaped using the \\u or \\U notation.\n// Those include control characters and newlines.\n// The \\u and \\U notation is Bash specific, but there is no way to do this in a shell-agnostic way.\n// Some shells do not even have a way to print those characters in an escaped fashion.\n// Therefore, we prioritize printing those safely, instead of allowing those to be copy-pasted.\n// List of Unicode character categories: https://www.fileformat.info/info/unicode/category/index.htm\nconst getSpecialCharRegExp = () => {\n\ttry {\n\t\t// This throws when using Node.js without ICU support.\n\t\t// When using a RegExp literal, this would throw at parsing-time, instead of runtime.\n\t\t// eslint-disable-next-line prefer-regex-literals\n\t\treturn new RegExp('\\\\p{Separator}|\\\\p{Other}', 'gu');\n\t} catch {\n\t\t// Similar to the above RegExp, but works even when Node.js has been built without ICU support.\n\t\t// Unlike the above RegExp, it only covers whitespaces and C0/C1 control characters.\n\t\t// It does not cover some edge cases, such as Unicode reserved characters.\n\t\t// See https://github.com/sindresorhus/execa/issues/1143\n\t\t// eslint-disable-next-line no-control-regex\n\t\treturn /[\\s\\u0000-\\u001F\\u007F-\\u009F\\u00AD]/g;\n\t}\n};\n\nconst SPECIAL_CHAR_REGEXP = getSpecialCharRegExp();\n\n// Accepted by $'...' in Bash.\n// Exclude \\a \\e \\v which are accepted in Bash but not in JavaScript (except \\v) and JSON.\nconst COMMON_ESCAPES = {\n\t' ': ' ',\n\t'\\b': '\\\\b',\n\t'\\f': '\\\\f',\n\t'\\n': '\\\\n',\n\t'\\r': '\\\\r',\n\t'\\t': '\\\\t',\n};\n\n// Up until that codepoint, \\u notation can be used instead of \\U\nconst ASTRAL_START = 65_535;\n\n// Some characters are shell-specific, i.e. need to be escaped when the command is copy-pasted then run.\n// Escaping is shell-specific. We cannot know which shell is used: `process.platform` detection is not enough.\n// For example, Windows users could be using `cmd.exe`, Powershell or Bash for Windows which all use different escaping.\n// We use '...' on Unix, which is POSIX shell compliant and escape all characters but ' so this is fairly safe.\n// On Windows, we assume cmd.exe is used and escape with \"...\", which also works with Powershell.\nconst quoteString = escapedArgument => {\n\tif (NO_ESCAPE_REGEXP.test(escapedArgument)) {\n\t\treturn escapedArgument;\n\t}\n\n\treturn platform === 'win32'\n\t\t? `\"${escapedArgument.replaceAll('\"', '\"\"')}\"`\n\t\t: `'${escapedArgument.replaceAll('\\'', '\\'\\\\\\'\\'')}'`;\n};\n\nconst NO_ESCAPE_REGEXP = /^[\\w./-]+$/;\n", "import process from 'node:process';\n\nexport default function isUnicodeSupported() {\n\tconst {env} = process;\n\tconst {TERM, TERM_PROGRAM} = env;\n\n\tif (process.platform !== 'win32') {\n\t\treturn TERM !== 'linux'; // Linux console (kernel)\n\t}\n\n\treturn Boolean(env.WT_SESSION) // Windows Terminal\n\t\t|| Boolean(env.TERMINUS_SUBLIME) // Terminus (<0.2.27)\n\t\t|| env.ConEmuTask === '{cmd::Cmder}' // ConEmu and cmder\n\t\t|| TERM_PROGRAM === 'Terminus-Sublime'\n\t\t|| TERM_PROGRAM === 'vscode'\n\t\t|| TERM === 'xterm-256color'\n\t\t|| TERM === 'alacritty'\n\t\t|| TERM === 'rxvt-unicode'\n\t\t|| TERM === 'rxvt-unicode-256color'\n\t\t|| env.TERMINAL_EMULATOR === 'JetBrains-JediTerm';\n}\n", "import isUnicodeSupported from 'is-unicode-supported';\n\nconst common = {\n\tcircleQuestionMark: '(?)',\n\tquestionMarkPrefix: '(?)',\n\tsquare: '\u2588',\n\tsquareDarkShade: '\u2593',\n\tsquareMediumShade: '\u2592',\n\tsquareLightShade: '\u2591',\n\tsquareTop: '\u2580',\n\tsquareBottom: '\u2584',\n\tsquareLeft: '\u258C',\n\tsquareRight: '\u2590',\n\tsquareCenter: '\u25A0',\n\tbullet: '\u25CF',\n\tdot: '\u2024',\n\tellipsis: '\u2026',\n\tpointerSmall: '\u203A',\n\ttriangleUp: '\u25B2',\n\ttriangleUpSmall: '\u25B4',\n\ttriangleDown: '\u25BC',\n\ttriangleDownSmall: '\u25BE',\n\ttriangleLeftSmall: '\u25C2',\n\ttriangleRightSmall: '\u25B8',\n\thome: '\u2302',\n\theart: '\u2665',\n\tmusicNote: '\u266A',\n\tmusicNoteBeamed: '\u266B',\n\tarrowUp: '\u2191',\n\tarrowDown: '\u2193',\n\tarrowLeft: '\u2190',\n\tarrowRight: '\u2192',\n\tarrowLeftRight: '\u2194',\n\tarrowUpDown: '\u2195',\n\talmostEqual: '\u2248',\n\tnotEqual: '\u2260',\n\tlessOrEqual: '\u2264',\n\tgreaterOrEqual: '\u2265',\n\tidentical: '\u2261',\n\tinfinity: '\u221E',\n\tsubscriptZero: '\u2080',\n\tsubscriptOne: '\u2081',\n\tsubscriptTwo: '\u2082',\n\tsubscriptThree: '\u2083',\n\tsubscriptFour: '\u2084',\n\tsubscriptFive: '\u2085',\n\tsubscriptSix: '\u2086',\n\tsubscriptSeven: '\u2087',\n\tsubscriptEight: '\u2088',\n\tsubscriptNine: '\u2089',\n\toneHalf: '\u00BD',\n\toneThird: '\u2153',\n\toneQuarter: '\u00BC',\n\toneFifth: '\u2155',\n\toneSixth: '\u2159',\n\toneEighth: '\u215B',\n\ttwoThirds: '\u2154',\n\ttwoFifths: '\u2156',\n\tthreeQuarters: '\u00BE',\n\tthreeFifths: '\u2157',\n\tthreeEighths: '\u215C',\n\tfourFifths: '\u2158',\n\tfiveSixths: '\u215A',\n\tfiveEighths: '\u215D',\n\tsevenEighths: '\u215E',\n\tline: '\u2500',\n\tlineBold: '\u2501',\n\tlineDouble: '\u2550',\n\tlineDashed0: '\u2504',\n\tlineDashed1: '\u2505',\n\tlineDashed2: '\u2508',\n\tlineDashed3: '\u2509',\n\tlineDashed4: '\u254C',\n\tlineDashed5: '\u254D',\n\tlineDashed6: '\u2574',\n\tlineDashed7: '\u2576',\n\tlineDashed8: '\u2578',\n\tlineDashed9: '\u257A',\n\tlineDashed10: '\u257C',\n\tlineDashed11: '\u257E',\n\tlineDashed12: '\u2212',\n\tlineDashed13: '\u2013',\n\tlineDashed14: '\u2010',\n\tlineDashed15: '\u2043',\n\tlineVertical: '\u2502',\n\tlineVerticalBold: '\u2503',\n\tlineVerticalDouble: '\u2551',\n\tlineVerticalDashed0: '\u2506',\n\tlineVerticalDashed1: '\u2507',\n\tlineVerticalDashed2: '\u250A',\n\tlineVerticalDashed3: '\u250B',\n\tlineVerticalDashed4: '\u254E',\n\tlineVerticalDashed5: '\u254F',\n\tlineVerticalDashed6: '\u2575',\n\tlineVerticalDashed7: '\u2577',\n\tlineVerticalDashed8: '\u2579',\n\tlineVerticalDashed9: '\u257B',\n\tlineVerticalDashed10: '\u257D',\n\tlineVerticalDashed11: '\u257F',\n\tlineDownLeft: '\u2510',\n\tlineDownLeftArc: '\u256E',\n\tlineDownBoldLeftBold: '\u2513',\n\tlineDownBoldLeft: '\u2512',\n\tlineDownLeftBold: '\u2511',\n\tlineDownDoubleLeftDouble: '\u2557',\n\tlineDownDoubleLeft: '\u2556',\n\tlineDownLeftDouble: '\u2555',\n\tlineDownRight: '\u250C',\n\tlineDownRightArc: '\u256D',\n\tlineDownBoldRightBold: '\u250F',\n\tlineDownBoldRight: '\u250E',\n\tlineDownRightBold: '\u250D',\n\tlineDownDoubleRightDouble: '\u2554',\n\tlineDownDoubleRight: '\u2553',\n\tlineDownRightDouble: '\u2552',\n\tlineUpLeft: '\u2518',\n\tlineUpLeftArc: '\u256F',\n\tlineUpBoldLeftBold: '\u251B',\n\tlineUpBoldLeft: '\u251A',\n\tlineUpLeftBold: '\u2519',\n\tlineUpDoubleLeftDouble: '\u255D',\n\tlineUpDoubleLeft: '\u255C',\n\tlineUpLeftDouble: '\u255B',\n\tlineUpRight: '\u2514',\n\tlineUpRightArc: '\u2570',\n\tlineUpBoldRightBold: '\u2517',\n\tlineUpBoldRight: '\u2516',\n\tlineUpRightBold: '\u2515',\n\tlineUpDoubleRightDouble: '\u255A',\n\tlineUpDoubleRight: '\u2559',\n\tlineUpRightDouble: '\u2558',\n\tlineUpDownLeft: '\u2524',\n\tlineUpBoldDownBoldLeftBold: '\u252B',\n\tlineUpBoldDownBoldLeft: '\u2528',\n\tlineUpDownLeftBold: '\u2525',\n\tlineUpBoldDownLeftBold: '\u2529',\n\tlineUpDownBoldLeftBold: '\u252A',\n\tlineUpDownBoldLeft: '\u2527',\n\tlineUpBoldDownLeft: '\u2526',\n\tlineUpDoubleDownDoubleLeftDouble: '\u2563',\n\tlineUpDoubleDownDoubleLeft: '\u2562',\n\tlineUpDownLeftDouble: '\u2561',\n\tlineUpDownRight: '\u251C',\n\tlineUpBoldDownBoldRightBold: '\u2523',\n\tlineUpBoldDownBoldRight: '\u2520',\n\tlineUpDownRightBold: '\u251D',\n\tlineUpBoldDownRightBold: '\u2521',\n\tlineUpDownBoldRightBold: '\u2522',\n\tlineUpDownBoldRight: '\u251F',\n\tlineUpBoldDownRight: '\u251E',\n\tlineUpDoubleDownDoubleRightDouble: '\u2560',\n\tlineUpDoubleDownDoubleRight: '\u255F',\n\tlineUpDownRightDouble: '\u255E',\n\tlineDownLeftRight: '\u252C',\n\tlineDownBoldLeftBoldRightBold: '\u2533',\n\tlineDownLeftBoldRightBold: '\u252F',\n\tlineDownBoldLeftRight: '\u2530',\n\tlineDownBoldLeftBoldRight: '\u2531',\n\tlineDownBoldLeftRightBold: '\u2532',\n\tlineDownLeftRightBold: '\u252E',\n\tlineDownLeftBoldRight: '\u252D',\n\tlineDownDoubleLeftDoubleRightDouble: '\u2566',\n\tlineDownDoubleLeftRight: '\u2565',\n\tlineDownLeftDoubleRightDouble: '\u2564',\n\tlineUpLeftRight: '\u2534',\n\tlineUpBoldLeftBoldRightBold: '\u253B',\n\tlineUpLeftBoldRightBold: '\u2537',\n\tlineUpBoldLeftRight: '\u2538',\n\tlineUpBoldLeftBoldRight: '\u2539',\n\tlineUpBoldLeftRightBold: '\u253A',\n\tlineUpLeftRightBold: '\u2536',\n\tlineUpLeftBoldRight: '\u2535',\n\tlineUpDoubleLeftDoubleRightDouble: '\u2569',\n\tlineUpDoubleLeftRight: '\u2568',\n\tlineUpLeftDoubleRightDouble: '\u2567',\n\tlineUpDownLeftRight: '\u253C',\n\tlineUpBoldDownBoldLeftBoldRightBold: '\u254B',\n\tlineUpDownBoldLeftBoldRightBold: '\u2548',\n\tlineUpBoldDownLeftBoldRightBold: '\u2547',\n\tlineUpBoldDownBoldLeftRightBold: '\u254A',\n\tlineUpBoldDownBoldLeftBoldRight: '\u2549',\n\tlineUpBoldDownLeftRight: '\u2540',\n\tlineUpDownBoldLeftRight: '\u2541',\n\tlineUpDownLeftBoldRight: '\u253D',\n\tlineUpDownLeftRightBold: '\u253E',\n\tlineUpBoldDownBoldLeftRight: '\u2542',\n\tlineUpDownLeftBoldRightBold: '\u253F',\n\tlineUpBoldDownLeftBoldRight: '\u2543',\n\tlineUpBoldDownLeftRightBold: '\u2544',\n\tlineUpDownBoldLeftBoldRight: '\u2545',\n\tlineUpDownBoldLeftRightBold: '\u2546',\n\tlineUpDoubleDownDoubleLeftDoubleRightDouble: '\u256C',\n\tlineUpDoubleDownDoubleLeftRight: '\u256B',\n\tlineUpDownLeftDoubleRightDouble: '\u256A',\n\tlineCross: '\u2573',\n\tlineBackslash: '\u2572',\n\tlineSlash: '\u2571',\n};\n\nconst specialMainSymbols = {\n\ttick: '\u2714',\n\tinfo: '\u2139',\n\twarning: '\u26A0',\n\tcross: '\u2718',\n\tsquareSmall: '\u25FB',\n\tsquareSmallFilled: '\u25FC',\n\tcircle: '\u25EF',\n\tcircleFilled: '\u25C9',\n\tcircleDotted: '\u25CC',\n\tcircleDouble: '\u25CE',\n\tcircleCircle: '\u24DE',\n\tcircleCross: '\u24E7',\n\tcirclePipe: '\u24BE',\n\tradioOn: '\u25C9',\n\tradioOff: '\u25EF',\n\tcheckboxOn: '\u2612',\n\tcheckboxOff: '\u2610',\n\tcheckboxCircleOn: '\u24E7',\n\tcheckboxCircleOff: '\u24BE',\n\tpointer: '\u276F',\n\ttriangleUpOutline: '\u25B3',\n\ttriangleLeft: '\u25C0',\n\ttriangleRight: '\u25B6',\n\tlozenge: '\u25C6',\n\tlozengeOutline: '\u25C7',\n\thamburger: '\u2630',\n\tsmiley: '\u32E1',\n\tmustache: '\u0DF4',\n\tstar: '\u2605',\n\tplay: '\u25B6',\n\tnodejs: '\u2B22',\n\toneSeventh: '\u2150',\n\toneNinth: '\u2151',\n\toneTenth: '\u2152',\n};\n\nconst specialFallbackSymbols = {\n\ttick: '\u221A',\n\tinfo: 'i',\n\twarning: '\u203C',\n\tcross: '\u00D7',\n\tsquareSmall: '\u25A1',\n\tsquareSmallFilled: '\u25A0',\n\tcircle: '( )',\n\tcircleFilled: '(*)',\n\tcircleDotted: '( )',\n\tcircleDouble: '( )',\n\tcircleCircle: '(\u25CB)',\n\tcircleCross: '(\u00D7)',\n\tcirclePipe: '(\u2502)',\n\tradioOn: '(*)',\n\tradioOff: '( )',\n\tcheckboxOn: '[\u00D7]',\n\tcheckboxOff: '[ ]',\n\tcheckboxCircleOn: '(\u00D7)',\n\tcheckboxCircleOff: '( )',\n\tpointer: '>',\n\ttriangleUpOutline: '\u2206',\n\ttriangleLeft: '\u25C4',\n\ttriangleRight: '\u25BA',\n\tlozenge: '\u2666',\n\tlozengeOutline: '\u25CA',\n\thamburger: '\u2261',\n\tsmiley: '\u263A',\n\tmustache: '\u250C\u2500\u2510',\n\tstar: '\u2736',\n\tplay: '\u25BA',\n\tnodejs: '\u2666',\n\toneSeventh: '1/7',\n\toneNinth: '1/9',\n\toneTenth: '1/10',\n};\n\nexport const mainSymbols = {...common, ...specialMainSymbols};\nexport const fallbackSymbols = {...common, ...specialFallbackSymbols};\n\nconst shouldUseMain = isUnicodeSupported();\nconst figures = shouldUseMain ? mainSymbols : fallbackSymbols;\nexport default figures;\n\nconst replacements = Object.entries(specialMainSymbols);\n\n// On terminals which do not support Unicode symbols, substitute them to other symbols\nexport const replaceSymbols = (string, {useFallback = !shouldUseMain} = {}) => {\n\tif (useFallback) {\n\t\tfor (const [key, mainSymbol] of replacements) {\n\t\t\tstring = string.replaceAll(mainSymbol, fallbackSymbols[key]);\n\t\t}\n\t}\n\n\treturn string;\n};\n", "import tty from 'node:tty';\n\n// eslint-disable-next-line no-warning-comments\n// TODO: Use a better method when it's added to Node.js (https://github.com/nodejs/node/pull/40240)\n// Lots of optionals here to support Deno.\nconst hasColors = tty?.WriteStream?.prototype?.hasColors?.() ?? false;\n\nconst format = (open, close) => {\n\tif (!hasColors) {\n\t\treturn input => input;\n\t}\n\n\tconst openCode = `\\u001B[${open}m`;\n\tconst closeCode = `\\u001B[${close}m`;\n\n\treturn input => {\n\t\tconst string = input + ''; // eslint-disable-line no-implicit-coercion -- This is faster.\n\t\tlet index = string.indexOf(closeCode);\n\n\t\tif (index === -1) {\n\t\t\t// Note: Intentionally not using string interpolation for performance reasons.\n\t\t\treturn openCode + string + closeCode;\n\t\t}\n\n\t\t// Handle nested colors.\n\n\t\t// We could have done this, but it's too slow (as of Node.js 22).\n\t\t// return openCode + string.replaceAll(closeCode, (close === 22 ? closeCode : '') + openCode) + closeCode;\n\n\t\tlet result = openCode;\n\t\tlet lastIndex = 0;\n\n\t\t// SGR 22 resets both bold (1) and dim (2). When we encounter a nested\n\t\t// close for styles that use 22, we need to re-open the outer style.\n\t\tconst reopenOnNestedClose = close === 22;\n\t\tconst replaceCode = (reopenOnNestedClose ? closeCode : '') + openCode;\n\n\t\twhile (index !== -1) {\n\t\t\tresult += string.slice(lastIndex, index) + replaceCode;\n\t\t\tlastIndex = index + closeCode.length;\n\t\t\tindex = string.indexOf(closeCode, lastIndex);\n\t\t}\n\n\t\tresult += string.slice(lastIndex) + closeCode;\n\n\t\treturn result;\n\t};\n};\n\nexport const reset = format(0, 0);\nexport const bold = format(1, 22);\nexport const dim = format(2, 22);\nexport const italic = format(3, 23);\nexport const underline = format(4, 24);\nexport const overline = format(53, 55);\nexport const inverse = format(7, 27);\nexport const hidden = format(8, 28);\nexport const strikethrough = format(9, 29);\n\nexport const black = format(30, 39);\nexport const red = format(31, 39);\nexport const green = format(32, 39);\nexport const yellow = format(33, 39);\nexport const blue = format(34, 39);\nexport const magenta = format(35, 39);\nexport const cyan = format(36, 39);\nexport const white = format(37, 39);\nexport const gray = format(90, 39);\n\nexport const bgBlack = format(40, 49);\nexport const bgRed = format(41, 49);\nexport const bgGreen = format(42, 49);\nexport const bgYellow = format(43, 49);\nexport const bgBlue = format(44, 49);\nexport const bgMagenta = format(45, 49);\nexport const bgCyan = format(46, 49);\nexport const bgWhite = format(47, 49);\nexport const bgGray = format(100, 49);\n\nexport const redBright = format(91, 39);\nexport const greenBright = format(92, 39);\nexport const yellowBright = format(93, 39);\nexport const blueBright = format(94, 39);\nexport const magentaBright = format(95, 39);\nexport const cyanBright = format(96, 39);\nexport const whiteBright = format(97, 39);\n\nexport const bgRedBright = format(101, 49);\nexport const bgGreenBright = format(102, 49);\nexport const bgYellowBright = format(103, 49);\nexport const bgBlueBright = format(104, 49);\nexport const bgMagentaBright = format(105, 49);\nexport const bgCyanBright = format(106, 49);\nexport const bgWhiteBright = format(107, 49);\n", "export * from './base.js';\nexport * as default from './base.js';\n", "import figures from 'figures';\nimport {\n\tgray,\n\tbold,\n\tredBright,\n\tyellowBright,\n} from 'yoctocolors';\n\n// Default when `verbose` is not a function\nexport const defaultVerboseFunction = ({\n\ttype,\n\tmessage,\n\ttimestamp,\n\tpiped,\n\tcommandId,\n\tresult: {failed = false} = {},\n\toptions: {reject = true},\n}) => {\n\tconst timestampString = serializeTimestamp(timestamp);\n\tconst icon = ICONS[type]({failed, reject, piped});\n\tconst color = COLORS[type]({reject});\n\treturn `${gray(`[${timestampString}]`)} ${gray(`[${commandId}]`)} ${color(icon)} ${color(message)}`;\n};\n\n// Prepending the timestamp allows debugging the slow paths of a subprocess\nconst serializeTimestamp = timestamp => `${padField(timestamp.getHours(), 2)}:${padField(timestamp.getMinutes(), 2)}:${padField(timestamp.getSeconds(), 2)}.${padField(timestamp.getMilliseconds(), 3)}`;\n\nconst padField = (field, padding) => String(field).padStart(padding, '0');\n\nconst getFinalIcon = ({failed, reject}) => {\n\tif (!failed) {\n\t\treturn figures.tick;\n\t}\n\n\treturn reject ? figures.cross : figures.warning;\n};\n\nconst ICONS = {\n\tcommand: ({piped}) => piped ? '|' : '$',\n\toutput: () => ' ',\n\tipc: () => '*',\n\terror: getFinalIcon,\n\tduration: getFinalIcon,\n};\n\nconst identity = string => string;\n\nconst COLORS = {\n\tcommand: () => bold,\n\toutput: () => identity,\n\tipc: () => identity,\n\terror: ({reject}) => reject ? redBright : yellowBright,\n\tduration: () => gray,\n};\n", "import {getVerboseFunction} from './values.js';\n\n// Apply the `verbose` function on each line\nexport const applyVerboseOnLines = (printedLines, verboseInfo, fdNumber) => {\n\tconst verboseFunction = getVerboseFunction(verboseInfo, fdNumber);\n\treturn printedLines\n\t\t.map(({verboseLine, verboseObject}) => applyVerboseFunction(verboseLine, verboseObject, verboseFunction))\n\t\t.filter(printedLine => printedLine !== undefined)\n\t\t.map(printedLine => appendNewline(printedLine))\n\t\t.join('');\n};\n\nconst applyVerboseFunction = (verboseLine, verboseObject, verboseFunction) => {\n\tif (verboseFunction === undefined) {\n\t\treturn verboseLine;\n\t}\n\n\tconst printedLine = verboseFunction(verboseLine, verboseObject);\n\tif (typeof printedLine === 'string') {\n\t\treturn printedLine;\n\t}\n};\n\nconst appendNewline = printedLine => printedLine.endsWith('\\n')\n\t? printedLine\n\t: `${printedLine}\\n`;\n", "import {inspect} from 'node:util';\nimport {escapeLines} from '../arguments/escape.js';\nimport {defaultVerboseFunction} from './default.js';\nimport {applyVerboseOnLines} from './custom.js';\n\n// This prints on stderr.\n// If the subprocess prints on stdout and is using `stdout: 'inherit'`,\n// there is a chance both writes will compete (introducing a race condition).\n// This means their respective order is not deterministic.\n// In particular, this means the verbose command lines might be after the start of the subprocess output.\n// Using synchronous I/O does not solve this problem.\n// However, this only seems to happen when the stdout/stderr target\n// (e.g. a terminal) is being written to by many subprocesses at once, which is unlikely in real scenarios.\nexport const verboseLog = ({type, verboseMessage, fdNumber, verboseInfo, result}) => {\n\tconst verboseObject = getVerboseObject({type, result, verboseInfo});\n\tconst printedLines = getPrintedLines(verboseMessage, verboseObject);\n\tconst finalLines = applyVerboseOnLines(printedLines, verboseInfo, fdNumber);\n\tif (finalLines !== '') {\n\t\tconsole.warn(finalLines.slice(0, -1));\n\t}\n};\n\nconst getVerboseObject = ({\n\ttype,\n\tresult,\n\tverboseInfo: {escapedCommand, commandId, rawOptions: {piped = false, ...options}},\n}) => ({\n\ttype,\n\tescapedCommand,\n\tcommandId: `${commandId}`,\n\ttimestamp: new Date(),\n\tpiped,\n\tresult,\n\toptions,\n});\n\nconst getPrintedLines = (verboseMessage, verboseObject) => verboseMessage\n\t.split('\\n')\n\t.map(message => getPrintedLine({...verboseObject, message}));\n\nconst getPrintedLine = verboseObject => {\n\tconst verboseLine = defaultVerboseFunction(verboseObject);\n\treturn {verboseLine, verboseObject};\n};\n\n// Serialize any type to a line string, for logging\nexport const serializeVerboseMessage = message => {\n\tconst messageString = typeof message === 'string' ? message : inspect(message);\n\tconst escapedMessage = escapeLines(messageString);\n\treturn escapedMessage.replaceAll('\\t', ' '.repeat(TAB_SIZE));\n};\n\n// Same as `util.inspect()`\nconst TAB_SIZE = 2;\n", "import {isVerbose} from './values.js';\nimport {verboseLog} from './log.js';\n\n// When `verbose` is `short|full|custom`, print each command\nexport const logCommand = (escapedCommand, verboseInfo) => {\n\tif (!isVerbose(verboseInfo)) {\n\t\treturn;\n\t}\n\n\tverboseLog({\n\t\ttype: 'command',\n\t\tverboseMessage: escapedCommand,\n\t\tverboseInfo,\n\t});\n};\n", "import {isVerbose, VERBOSE_VALUES, isVerboseFunction} from './values.js';\n\n// Information computed before spawning, used by the `verbose` option\nexport const getVerboseInfo = (verbose, escapedCommand, rawOptions) => {\n\tvalidateVerbose(verbose);\n\tconst commandId = getCommandId(verbose);\n\treturn {\n\t\tverbose,\n\t\tescapedCommand,\n\t\tcommandId,\n\t\trawOptions,\n\t};\n};\n\nconst getCommandId = verbose => isVerbose({verbose}) ? COMMAND_ID++ : undefined;\n\n// Prepending the `pid` is useful when multiple commands print their output at the same time.\n// However, we cannot use the real PID since this is not available with `child_process.spawnSync()`.\n// Also, we cannot use the real PID if we want to print it before `child_process.spawn()` is run.\n// As a pro, it is shorter than a normal PID and never re-uses the same id.\n// As a con, it cannot be used to send signals.\nlet COMMAND_ID = 0n;\n\nconst validateVerbose = verbose => {\n\tfor (const fdVerbose of verbose) {\n\t\tif (fdVerbose === false) {\n\t\t\tthrow new TypeError('The \"verbose: false\" option was renamed to \"verbose: \\'none\\'\".');\n\t\t}\n\n\t\tif (fdVerbose === true) {\n\t\t\tthrow new TypeError('The \"verbose: true\" option was renamed to \"verbose: \\'short\\'\".');\n\t\t}\n\n\t\tif (!VERBOSE_VALUES.includes(fdVerbose) && !isVerboseFunction(fdVerbose)) {\n\t\t\tconst allowedValues = VERBOSE_VALUES.map(allowedValue => `'${allowedValue}'`).join(', ');\n\t\t\tthrow new TypeError(`The \"verbose\" option must not be ${fdVerbose}. Allowed values are: ${allowedValues} or a function.`);\n\t\t}\n\t}\n};\n", "import {hrtime} from 'node:process';\n\n// Start counting time before spawning the subprocess\nexport const getStartTime = () => hrtime.bigint();\n\n// Compute duration after the subprocess ended.\n// Printed by the `verbose` option.\nexport const getDurationMs = startTime => Number(hrtime.bigint() - startTime) / 1e6;\n", "import {logCommand} from '../verbose/start.js';\nimport {getVerboseInfo} from '../verbose/info.js';\nimport {getStartTime} from '../return/duration.js';\nimport {joinCommand} from './escape.js';\nimport {normalizeFdSpecificOption} from './specific.js';\n\n// Compute `result.command`, `result.escapedCommand` and `verbose`-related information\nexport const handleCommand = (filePath, rawArguments, rawOptions) => {\n\tconst startTime = getStartTime();\n\tconst {command, escapedCommand} = joinCommand(filePath, rawArguments);\n\tconst verbose = normalizeFdSpecificOption(rawOptions, 'verbose');\n\tconst verboseInfo = getVerboseInfo(verbose, escapedCommand, {...rawOptions});\n\tlogCommand(escapedCommand, verboseInfo);\n\treturn {\n\t\tcommand,\n\t\tescapedCommand,\n\t\tstartTime,\n\t\tverboseInfo,\n\t};\n};\n", "module.exports = isexe\nisexe.sync = sync\n\nvar fs = require('fs')\n\nfunction checkPathExt (path, options) {\n  var pathext = options.pathExt !== undefined ?\n    options.pathExt : process.env.PATHEXT\n\n  if (!pathext) {\n    return true\n  }\n\n  pathext = pathext.split(';')\n  if (pathext.indexOf('') !== -1) {\n    return true\n  }\n  for (var i = 0; i < pathext.length; i++) {\n    var p = pathext[i].toLowerCase()\n    if (p && path.substr(-p.length).toLowerCase() === p) {\n      return true\n    }\n  }\n  return false\n}\n\nfunction checkStat (stat, path, options) {\n  if (!stat.isSymbolicLink() && !stat.isFile()) {\n    return false\n  }\n  return checkPathExt(path, options)\n}\n\nfunction isexe (path, options, cb) {\n  fs.stat(path, function (er, stat) {\n    cb(er, er ? false : checkStat(stat, path, options))\n  })\n}\n\nfunction sync (path, options) {\n  return checkStat(fs.statSync(path), path, options)\n}\n", "module.exports = isexe\nisexe.sync = sync\n\nvar fs = require('fs')\n\nfunction isexe (path, options, cb) {\n  fs.stat(path, function (er, stat) {\n    cb(er, er ? false : checkStat(stat, options))\n  })\n}\n\nfunction sync (path, options) {\n  return checkStat(fs.statSync(path), options)\n}\n\nfunction checkStat (stat, options) {\n  return stat.isFile() && checkMode(stat, options)\n}\n\nfunction checkMode (stat, options) {\n  var mod = stat.mode\n  var uid = stat.uid\n  var gid = stat.gid\n\n  var myUid = options.uid !== undefined ?\n    options.uid : process.getuid && process.getuid()\n  var myGid = options.gid !== undefined ?\n    options.gid : process.getgid && process.getgid()\n\n  var u = parseInt('100', 8)\n  var g = parseInt('010', 8)\n  var o = parseInt('001', 8)\n  var ug = u | g\n\n  var ret = (mod & o) ||\n    (mod & g) && gid === myGid ||\n    (mod & u) && uid === myUid ||\n    (mod & ug) && myUid === 0\n\n  return ret\n}\n", "var fs = require('fs')\nvar core\nif (process.platform === 'win32' || global.TESTING_WINDOWS) {\n  core = require('./windows.js')\n} else {\n  core = require('./mode.js')\n}\n\nmodule.exports = isexe\nisexe.sync = sync\n\nfunction isexe (path, options, cb) {\n  if (typeof options === 'function') {\n    cb = options\n    options = {}\n  }\n\n  if (!cb) {\n    if (typeof Promise !== 'function') {\n      throw new TypeError('callback not provided')\n    }\n\n    return new Promise(function (resolve, reject) {\n      isexe(path, options || {}, function (er, is) {\n        if (er) {\n          reject(er)\n        } else {\n          resolve(is)\n        }\n      })\n    })\n  }\n\n  core(path, options || {}, function (er, is) {\n    // ignore EACCES because that just means we aren't allowed to run it\n    if (er) {\n      if (er.code === 'EACCES' || options && options.ignoreErrors) {\n        er = null\n        is = false\n      }\n    }\n    cb(er, is)\n  })\n}\n\nfunction sync (path, options) {\n  // my kingdom for a filtered catch\n  try {\n    return core.sync(path, options || {})\n  } catch (er) {\n    if (options && options.ignoreErrors || er.code === 'EACCES') {\n      return false\n    } else {\n      throw er\n    }\n  }\n}\n", "const isWindows = process.platform === 'win32' ||\n    process.env.OSTYPE === 'cygwin' ||\n    process.env.OSTYPE === 'msys'\n\nconst path = require('path')\nconst COLON = isWindows ? ';' : ':'\nconst isexe = require('isexe')\n\nconst getNotFoundError = (cmd) =>\n  Object.assign(new Error(`not found: ${cmd}`), { code: 'ENOENT' })\n\nconst getPathInfo = (cmd, opt) => {\n  const colon = opt.colon || COLON\n\n  // If it has a slash, then we don't bother searching the pathenv.\n  // just check the file itself, and that's it.\n  const pathEnv = cmd.match(/\\//) || isWindows && cmd.match(/\\\\/) ? ['']\n    : (\n      [\n        // windows always checks the cwd first\n        ...(isWindows ? [process.cwd()] : []),\n        ...(opt.path || process.env.PATH ||\n          /* istanbul ignore next: very unusual */ '').split(colon),\n      ]\n    )\n  const pathExtExe = isWindows\n    ? opt.pathExt || process.env.PATHEXT || '.EXE;.CMD;.BAT;.COM'\n    : ''\n  const pathExt = isWindows ? pathExtExe.split(colon) : ['']\n\n  if (isWindows) {\n    if (cmd.indexOf('.') !== -1 && pathExt[0] !== '')\n      pathExt.unshift('')\n  }\n\n  return {\n    pathEnv,\n    pathExt,\n    pathExtExe,\n  }\n}\n\nconst which = (cmd, opt, cb) => {\n  if (typeof opt === 'function') {\n    cb = opt\n    opt = {}\n  }\n  if (!opt)\n    opt = {}\n\n  const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt)\n  const found = []\n\n  const step = i => new Promise((resolve, reject) => {\n    if (i === pathEnv.length)\n      return opt.all && found.length ? resolve(found)\n        : reject(getNotFoundError(cmd))\n\n    const ppRaw = pathEnv[i]\n    const pathPart = /^\".*\"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw\n\n    const pCmd = path.join(pathPart, cmd)\n    const p = !pathPart && /^\\.[\\\\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd\n      : pCmd\n\n    resolve(subStep(p, i, 0))\n  })\n\n  const subStep = (p, i, ii) => new Promise((resolve, reject) => {\n    if (ii === pathExt.length)\n      return resolve(step(i + 1))\n    const ext = pathExt[ii]\n    isexe(p + ext, { pathExt: pathExtExe }, (er, is) => {\n      if (!er && is) {\n        if (opt.all)\n          found.push(p + ext)\n        else\n          return resolve(p + ext)\n      }\n      return resolve(subStep(p, i, ii + 1))\n    })\n  })\n\n  return cb ? step(0).then(res => cb(null, res), cb) : step(0)\n}\n\nconst whichSync = (cmd, opt) => {\n  opt = opt || {}\n\n  const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt)\n  const found = []\n\n  for (let i = 0; i < pathEnv.length; i ++) {\n    const ppRaw = pathEnv[i]\n    const pathPart = /^\".*\"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw\n\n    const pCmd = path.join(pathPart, cmd)\n    const p = !pathPart && /^\\.[\\\\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd\n      : pCmd\n\n    for (let j = 0; j < pathExt.length; j ++) {\n      const cur = p + pathExt[j]\n      try {\n        const is = isexe.sync(cur, { pathExt: pathExtExe })\n        if (is) {\n          if (opt.all)\n            found.push(cur)\n          else\n            return cur\n        }\n      } catch (ex) {}\n    }\n  }\n\n  if (opt.all && found.length)\n    return found\n\n  if (opt.nothrow)\n    return null\n\n  throw getNotFoundError(cmd)\n}\n\nmodule.exports = which\nwhich.sync = whichSync\n", "'use strict';\n\nconst pathKey = (options = {}) => {\n\tconst environment = options.env || process.env;\n\tconst platform = options.platform || process.platform;\n\n\tif (platform !== 'win32') {\n\t\treturn 'PATH';\n\t}\n\n\treturn Object.keys(environment).reverse().find(key => key.toUpperCase() === 'PATH') || 'Path';\n};\n\nmodule.exports = pathKey;\n// TODO: Remove this for the next major release\nmodule.exports.default = pathKey;\n", "'use strict';\n\nconst path = require('path');\nconst which = require('which');\nconst getPathKey = require('path-key');\n\nfunction resolveCommandAttempt(parsed, withoutPathExt) {\n    const env = parsed.options.env || process.env;\n    const cwd = process.cwd();\n    const hasCustomCwd = parsed.options.cwd != null;\n    // Worker threads do not have process.chdir()\n    const shouldSwitchCwd = hasCustomCwd && process.chdir !== undefined && !process.chdir.disabled;\n\n    // If a custom `cwd` was specified, we need to change the process cwd\n    // because `which` will do stat calls but does not support a custom cwd\n    if (shouldSwitchCwd) {\n        try {\n            process.chdir(parsed.options.cwd);\n        } catch (err) {\n            /* Empty */\n        }\n    }\n\n    let resolved;\n\n    try {\n        resolved = which.sync(parsed.command, {\n            path: env[getPathKey({ env })],\n            pathExt: withoutPathExt ? path.delimiter : undefined,\n        });\n    } catch (e) {\n        /* Empty */\n    } finally {\n        if (shouldSwitchCwd) {\n            process.chdir(cwd);\n        }\n    }\n\n    // If we successfully resolved, ensure that an absolute path is returned\n    // Note that when a custom `cwd` was used, we need to resolve to an absolute path based on it\n    if (resolved) {\n        resolved = path.resolve(hasCustomCwd ? parsed.options.cwd : '', resolved);\n    }\n\n    return resolved;\n}\n\nfunction resolveCommand(parsed) {\n    return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, true);\n}\n\nmodule.exports = resolveCommand;\n", "'use strict';\n\n// See http://www.robvanderwoude.com/escapechars.php\nconst metaCharsRegExp = /([()\\][%!^\"`<>&|;, *?])/g;\n\nfunction escapeCommand(arg) {\n    // Escape meta chars\n    arg = arg.replace(metaCharsRegExp, '^$1');\n\n    return arg;\n}\n\nfunction escapeArgument(arg, doubleEscapeMetaChars) {\n    // Convert to string\n    arg = `${arg}`;\n\n    // Algorithm below is based on https://qntm.org/cmd\n    // It's slightly altered to disable JS backtracking to avoid hanging on specially crafted input\n    // Please see https://github.com/moxystudio/node-cross-spawn/pull/160 for more information\n\n    // Sequence of backslashes followed by a double quote:\n    // double up all the backslashes and escape the double quote\n    arg = arg.replace(/(?=(\\\\+?)?)\\1\"/g, '$1$1\\\\\"');\n\n    // Sequence of backslashes followed by the end of the string\n    // (which will become a double quote later):\n    // double up all the backslashes\n    arg = arg.replace(/(?=(\\\\+?)?)\\1$/, '$1$1');\n\n    // All other backslashes occur literally\n\n    // Quote the whole thing:\n    arg = `\"${arg}\"`;\n\n    // Escape meta chars\n    arg = arg.replace(metaCharsRegExp, '^$1');\n\n    // Double escape meta chars if necessary\n    if (doubleEscapeMetaChars) {\n        arg = arg.replace(metaCharsRegExp, '^$1');\n    }\n\n    return arg;\n}\n\nmodule.exports.command = escapeCommand;\nmodule.exports.argument = escapeArgument;\n", "'use strict';\nmodule.exports = /^#!(.*)/;\n", "'use strict';\nconst shebangRegex = require('shebang-regex');\n\nmodule.exports = (string = '') => {\n\tconst match = string.match(shebangRegex);\n\n\tif (!match) {\n\t\treturn null;\n\t}\n\n\tconst [path, argument] = match[0].replace(/#! ?/, '').split(' ');\n\tconst binary = path.split('/').pop();\n\n\tif (binary === 'env') {\n\t\treturn argument;\n\t}\n\n\treturn argument ? `${binary} ${argument}` : binary;\n};\n", "'use strict';\n\nconst fs = require('fs');\nconst shebangCommand = require('shebang-command');\n\nfunction readShebang(command) {\n    // Read the first 150 bytes from the file\n    const size = 150;\n    const buffer = Buffer.alloc(size);\n\n    let fd;\n\n    try {\n        fd = fs.openSync(command, 'r');\n        fs.readSync(fd, buffer, 0, size, 0);\n        fs.closeSync(fd);\n    } catch (e) { /* Empty */ }\n\n    // Attempt to extract shebang (null is returned if not a shebang)\n    return shebangCommand(buffer.toString());\n}\n\nmodule.exports = readShebang;\n", "'use strict';\n\nconst path = require('path');\nconst resolveCommand = require('./util/resolveCommand');\nconst escape = require('./util/escape');\nconst readShebang = require('./util/readShebang');\n\nconst isWin = process.platform === 'win32';\nconst isExecutableRegExp = /\\.(?:com|exe)$/i;\nconst isCmdShimRegExp = /node_modules[\\\\/].bin[\\\\/][^\\\\/]+\\.cmd$/i;\n\nfunction detectShebang(parsed) {\n    parsed.file = resolveCommand(parsed);\n\n    const shebang = parsed.file && readShebang(parsed.file);\n\n    if (shebang) {\n        parsed.args.unshift(parsed.file);\n        parsed.command = shebang;\n\n        return resolveCommand(parsed);\n    }\n\n    return parsed.file;\n}\n\nfunction parseNonShell(parsed) {\n    if (!isWin) {\n        return parsed;\n    }\n\n    // Detect & add support for shebangs\n    const commandFile = detectShebang(parsed);\n\n    // We don't need a shell if the command filename is an executable\n    const needsShell = !isExecutableRegExp.test(commandFile);\n\n    // If a shell is required, use cmd.exe and take care of escaping everything correctly\n    // Note that `forceShell` is an hidden option used only in tests\n    if (parsed.options.forceShell || needsShell) {\n        // Need to double escape meta chars if the command is a cmd-shim located in `node_modules/.bin/`\n        // The cmd-shim simply calls execute the package bin file with NodeJS, proxying any argument\n        // Because the escape of metachars with ^ gets interpreted when the cmd.exe is first called,\n        // we need to double escape them\n        const needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);\n\n        // Normalize posix paths into OS compatible paths (e.g.: foo/bar -> foo\\bar)\n        // This is necessary otherwise it will always fail with ENOENT in those cases\n        parsed.command = path.normalize(parsed.command);\n\n        // Escape command & arguments\n        parsed.command = escape.command(parsed.command);\n        parsed.args = parsed.args.map((arg) => escape.argument(arg, needsDoubleEscapeMetaChars));\n\n        const shellCommand = [parsed.command].concat(parsed.args).join(' ');\n\n        parsed.args = ['/d', '/s', '/c', `\"${shellCommand}\"`];\n        parsed.command = process.env.comspec || 'cmd.exe';\n        parsed.options.windowsVerbatimArguments = true; // Tell node's spawn that the arguments are already escaped\n    }\n\n    return parsed;\n}\n\nfunction parse(command, args, options) {\n    // Normalize arguments, similar to nodejs\n    if (args && !Array.isArray(args)) {\n        options = args;\n        args = null;\n    }\n\n    args = args ? args.slice(0) : []; // Clone array to avoid changing the original\n    options = Object.assign({}, options); // Clone object to avoid changing the original\n\n    // Build our parsed object\n    const parsed = {\n        command,\n        args,\n        options,\n        file: undefined,\n        original: {\n            command,\n            args,\n        },\n    };\n\n    // Delegate further parsing to shell or non-shell\n    return options.shell ? parsed : parseNonShell(parsed);\n}\n\nmodule.exports = parse;\n", "'use strict';\n\nconst isWin = process.platform === 'win32';\n\nfunction notFoundError(original, syscall) {\n    return Object.assign(new Error(`${syscall} ${original.command} ENOENT`), {\n        code: 'ENOENT',\n        errno: 'ENOENT',\n        syscall: `${syscall} ${original.command}`,\n        path: original.command,\n        spawnargs: original.args,\n    });\n}\n\nfunction hookChildProcess(cp, parsed) {\n    if (!isWin) {\n        return;\n    }\n\n    const originalEmit = cp.emit;\n\n    cp.emit = function (name, arg1) {\n        // If emitting \"exit\" event and exit code is 1, we need to check if\n        // the command exists and emit an \"error\" instead\n        // See https://github.com/IndigoUnited/node-cross-spawn/issues/16\n        if (name === 'exit') {\n            const err = verifyENOENT(arg1, parsed);\n\n            if (err) {\n                return originalEmit.call(cp, 'error', err);\n            }\n        }\n\n        return originalEmit.apply(cp, arguments); // eslint-disable-line prefer-rest-params\n    };\n}\n\nfunction verifyENOENT(status, parsed) {\n    if (isWin && status === 1 && !parsed.file) {\n        return notFoundError(parsed.original, 'spawn');\n    }\n\n    return null;\n}\n\nfunction verifyENOENTSync(status, parsed) {\n    if (isWin && status === 1 && !parsed.file) {\n        return notFoundError(parsed.original, 'spawnSync');\n    }\n\n    return null;\n}\n\nmodule.exports = {\n    hookChildProcess,\n    verifyENOENT,\n    verifyENOENTSync,\n    notFoundError,\n};\n", "'use strict';\n\nconst cp = require('child_process');\nconst parse = require('./lib/parse');\nconst enoent = require('./lib/enoent');\n\nfunction spawn(command, args, options) {\n    // Parse the arguments\n    const parsed = parse(command, args, options);\n\n    // Spawn the child process\n    const spawned = cp.spawn(parsed.command, parsed.args, parsed.options);\n\n    // Hook into child process \"exit\" event to emit an error if the command\n    // does not exists, see: https://github.com/IndigoUnited/node-cross-spawn/issues/16\n    enoent.hookChildProcess(spawned, parsed);\n\n    return spawned;\n}\n\nfunction spawnSync(command, args, options) {\n    // Parse the arguments\n    const parsed = parse(command, args, options);\n\n    // Spawn the child process\n    const result = cp.spawnSync(parsed.command, parsed.args, parsed.options);\n\n    // Analyze if the command does not exist, see: https://github.com/IndigoUnited/node-cross-spawn/issues/16\n    result.error = result.error || enoent.verifyENOENTSync(result.status, parsed);\n\n    return result;\n}\n\nmodule.exports = spawn;\nmodule.exports.spawn = spawn;\nmodule.exports.sync = spawnSync;\n\nmodule.exports._parse = parse;\nmodule.exports._enoent = enoent;\n", "export default function pathKey(options = {}) {\n\tconst {\n\t\tenv = process.env,\n\t\tplatform = process.platform\n\t} = options;\n\n\tif (platform !== 'win32') {\n\t\treturn 'PATH';\n\t}\n\n\treturn Object.keys(env).reverse().find(key => key.toUpperCase() === 'PATH') || 'Path';\n}\n", "export async function delay({seconds, milliseconds} = {}) {\n\tlet duration;\n\tif (typeof seconds === 'number') {\n\t\tduration = seconds * 1000;\n\t} else if (typeof milliseconds === 'number') {\n\t\tduration = milliseconds;\n\t} else {\n\t\tthrow new TypeError('Expected an object with either `seconds` or `milliseconds`.');\n\t}\n\n\treturn new Promise(resolve => {\n\t\tsetTimeout(resolve, duration);\n\t});\n}\n", "import {promisify} from 'node:util';\nimport {execFile as execFileCallback, execFileSync as execFileSyncOriginal} from 'node:child_process';\nimport path from 'node:path';\nimport {fileURLToPath} from 'node:url';\n\nconst execFileOriginal = promisify(execFileCallback);\n\nexport function toPath(urlOrPath) {\n\treturn urlOrPath instanceof URL ? fileURLToPath(urlOrPath) : urlOrPath;\n}\n\nexport function rootDirectory(pathInput) {\n\treturn path.parse(toPath(pathInput)).root;\n}\n\nexport function traversePathUp(startPath) {\n\treturn {\n\t\t* [Symbol.iterator]() {\n\t\t\tlet currentPath = path.resolve(toPath(startPath));\n\t\t\tlet previousPath;\n\n\t\t\twhile (previousPath !== currentPath) {\n\t\t\t\tyield currentPath;\n\t\t\t\tpreviousPath = currentPath;\n\t\t\t\tcurrentPath = path.resolve(currentPath, '..');\n\t\t\t}\n\t\t},\n\t};\n}\n\nconst TEN_MEGABYTES_IN_BYTES = 10 * 1024 * 1024;\n\nexport async function execFile(file, arguments_, options = {}) {\n\treturn execFileOriginal(file, arguments_, {\n\t\tmaxBuffer: TEN_MEGABYTES_IN_BYTES,\n\t\t...options,\n\t});\n}\n\nexport function execFileSync(file, arguments_ = [], options = {}) {\n\treturn execFileSyncOriginal(file, arguments_, {\n\t\tmaxBuffer: TEN_MEGABYTES_IN_BYTES,\n\t\tencoding: 'utf8',\n\t\tstdio: 'pipe',\n\t\t...options,\n\t});\n}\n\nexport * from './default.js';\n", "import process from 'node:process';\nimport path from 'node:path';\nimport pathKey from 'path-key';\nimport {toPath, traversePathUp} from 'unicorn-magic';\n\nexport const npmRunPath = ({\n\tcwd = process.cwd(),\n\tpath: pathOption = process.env[pathKey()],\n\tpreferLocal = true,\n\texecPath = process.execPath,\n\taddExecPath = true,\n} = {}) => {\n\tconst cwdPath = path.resolve(toPath(cwd));\n\tconst result = [];\n\tconst pathParts = pathOption.split(path.delimiter);\n\n\tif (preferLocal) {\n\t\tapplyPreferLocal(result, pathParts, cwdPath);\n\t}\n\n\tif (addExecPath) {\n\t\tapplyExecPath(result, pathParts, execPath, cwdPath);\n\t}\n\n\treturn pathOption === '' || pathOption === path.delimiter\n\t\t? `${result.join(path.delimiter)}${pathOption}`\n\t\t: [...result, pathOption].join(path.delimiter);\n};\n\nconst applyPreferLocal = (result, pathParts, cwdPath) => {\n\tfor (const directory of traversePathUp(cwdPath)) {\n\t\tconst pathPart = path.join(directory, 'node_modules/.bin');\n\t\tif (!pathParts.includes(pathPart)) {\n\t\t\tresult.push(pathPart);\n\t\t}\n\t}\n};\n\n// Ensure the running `node` binary is used\nconst applyExecPath = (result, pathParts, execPath, cwdPath) => {\n\tconst pathPart = path.resolve(cwdPath, toPath(execPath), '..');\n\tif (!pathParts.includes(pathPart)) {\n\t\tresult.push(pathPart);\n\t}\n};\n\nexport const npmRunPathEnv = ({env = process.env, ...options} = {}) => {\n\tenv = {...env};\n\n\tconst pathName = pathKey({env});\n\toptions.path = env[pathName];\n\tenv[pathName] = npmRunPath(options);\n\n\treturn env;\n};\n", "// When the subprocess fails, this is the error instance being returned.\n// If another error instance is being thrown, it is kept as `error.cause`.\nexport const getFinalError = (originalError, message, isSync) => {\n\tconst ErrorClass = isSync ? ExecaSyncError : ExecaError;\n\tconst options = originalError instanceof DiscardedError ? {} : {cause: originalError};\n\treturn new ErrorClass(message, options);\n};\n\n// Indicates that the error is used only to interrupt control flow, but not in the return value\nexport class DiscardedError extends Error {}\n\n// Proper way to set `error.name`: it should be inherited and non-enumerable\nconst setErrorName = (ErrorClass, value) => {\n\tObject.defineProperty(ErrorClass.prototype, 'name', {\n\t\tvalue,\n\t\twritable: true,\n\t\tenumerable: false,\n\t\tconfigurable: true,\n\t});\n\tObject.defineProperty(ErrorClass.prototype, execaErrorSymbol, {\n\t\tvalue: true,\n\t\twritable: false,\n\t\tenumerable: false,\n\t\tconfigurable: false,\n\t});\n};\n\n// Unlike `instanceof`, this works across realms\nexport const isExecaError = error => isErrorInstance(error) && execaErrorSymbol in error;\n\nconst execaErrorSymbol = Symbol('isExecaError');\n\nexport const isErrorInstance = value => Object.prototype.toString.call(value) === '[object Error]';\n\n// We use two different Error classes for async/sync methods since they have slightly different shape and types\nexport class ExecaError extends Error {}\nsetErrorName(ExecaError, ExecaError.name);\n\nexport class ExecaSyncError extends Error {}\nsetErrorName(ExecaSyncError, ExecaSyncError.name);\n", "\nexport const getRealtimeSignals=()=>{\nconst length=SIGRTMAX-SIGRTMIN+1;\nreturn Array.from({length},getRealtimeSignal)\n};\n\nconst getRealtimeSignal=(value,index)=>({\nname:`SIGRT${index+1}`,\nnumber:SIGRTMIN+index,\naction:\"terminate\",\ndescription:\"Application-specific signal (realtime)\",\nstandard:\"posix\"\n});\n\nconst SIGRTMIN=34;\nexport const SIGRTMAX=64;", "\n\nexport const SIGNALS=[\n{\nname:\"SIGHUP\",\nnumber:1,\naction:\"terminate\",\ndescription:\"Terminal closed\",\nstandard:\"posix\"\n},\n{\nname:\"SIGINT\",\nnumber:2,\naction:\"terminate\",\ndescription:\"User interruption with CTRL-C\",\nstandard:\"ansi\"\n},\n{\nname:\"SIGQUIT\",\nnumber:3,\naction:\"core\",\ndescription:\"User interruption with CTRL-\\\\\",\nstandard:\"posix\"\n},\n{\nname:\"SIGILL\",\nnumber:4,\naction:\"core\",\ndescription:\"Invalid machine instruction\",\nstandard:\"ansi\"\n},\n{\nname:\"SIGTRAP\",\nnumber:5,\naction:\"core\",\ndescription:\"Debugger breakpoint\",\nstandard:\"posix\"\n},\n{\nname:\"SIGABRT\",\nnumber:6,\naction:\"core\",\ndescription:\"Aborted\",\nstandard:\"ansi\"\n},\n{\nname:\"SIGIOT\",\nnumber:6,\naction:\"core\",\ndescription:\"Aborted\",\nstandard:\"bsd\"\n},\n{\nname:\"SIGBUS\",\nnumber:7,\naction:\"core\",\ndescription:\n\"Bus error due to misaligned, non-existing address or paging error\",\nstandard:\"bsd\"\n},\n{\nname:\"SIGEMT\",\nnumber:7,\naction:\"terminate\",\ndescription:\"Command should be emulated but is not implemented\",\nstandard:\"other\"\n},\n{\nname:\"SIGFPE\",\nnumber:8,\naction:\"core\",\ndescription:\"Floating point arithmetic error\",\nstandard:\"ansi\"\n},\n{\nname:\"SIGKILL\",\nnumber:9,\naction:\"terminate\",\ndescription:\"Forced termination\",\nstandard:\"posix\",\nforced:true\n},\n{\nname:\"SIGUSR1\",\nnumber:10,\naction:\"terminate\",\ndescription:\"Application-specific signal\",\nstandard:\"posix\"\n},\n{\nname:\"SIGSEGV\",\nnumber:11,\naction:\"core\",\ndescription:\"Segmentation fault\",\nstandard:\"ansi\"\n},\n{\nname:\"SIGUSR2\",\nnumber:12,\naction:\"terminate\",\ndescription:\"Application-specific signal\",\nstandard:\"posix\"\n},\n{\nname:\"SIGPIPE\",\nnumber:13,\naction:\"terminate\",\ndescription:\"Broken pipe or socket\",\nstandard:\"posix\"\n},\n{\nname:\"SIGALRM\",\nnumber:14,\naction:\"terminate\",\ndescription:\"Timeout or timer\",\nstandard:\"posix\"\n},\n{\nname:\"SIGTERM\",\nnumber:15,\naction:\"terminate\",\ndescription:\"Termination\",\nstandard:\"ansi\"\n},\n{\nname:\"SIGSTKFLT\",\nnumber:16,\naction:\"terminate\",\ndescription:\"Stack is empty or overflowed\",\nstandard:\"other\"\n},\n{\nname:\"SIGCHLD\",\nnumber:17,\naction:\"ignore\",\ndescription:\"Child process terminated, paused or unpaused\",\nstandard:\"posix\"\n},\n{\nname:\"SIGCLD\",\nnumber:17,\naction:\"ignore\",\ndescription:\"Child process terminated, paused or unpaused\",\nstandard:\"other\"\n},\n{\nname:\"SIGCONT\",\nnumber:18,\naction:\"unpause\",\ndescription:\"Unpaused\",\nstandard:\"posix\",\nforced:true\n},\n{\nname:\"SIGSTOP\",\nnumber:19,\naction:\"pause\",\ndescription:\"Paused\",\nstandard:\"posix\",\nforced:true\n},\n{\nname:\"SIGTSTP\",\nnumber:20,\naction:\"pause\",\ndescription:\"Paused using CTRL-Z or \\\"suspend\\\"\",\nstandard:\"posix\"\n},\n{\nname:\"SIGTTIN\",\nnumber:21,\naction:\"pause\",\ndescription:\"Background process cannot read terminal input\",\nstandard:\"posix\"\n},\n{\nname:\"SIGBREAK\",\nnumber:21,\naction:\"terminate\",\ndescription:\"User interruption with CTRL-BREAK\",\nstandard:\"other\"\n},\n{\nname:\"SIGTTOU\",\nnumber:22,\naction:\"pause\",\ndescription:\"Background process cannot write to terminal output\",\nstandard:\"posix\"\n},\n{\nname:\"SIGURG\",\nnumber:23,\naction:\"ignore\",\ndescription:\"Socket received out-of-band data\",\nstandard:\"bsd\"\n},\n{\nname:\"SIGXCPU\",\nnumber:24,\naction:\"core\",\ndescription:\"Process timed out\",\nstandard:\"bsd\"\n},\n{\nname:\"SIGXFSZ\",\nnumber:25,\naction:\"core\",\ndescription:\"File too big\",\nstandard:\"bsd\"\n},\n{\nname:\"SIGVTALRM\",\nnumber:26,\naction:\"terminate\",\ndescription:\"Timeout or timer\",\nstandard:\"bsd\"\n},\n{\nname:\"SIGPROF\",\nnumber:27,\naction:\"terminate\",\ndescription:\"Timeout or timer\",\nstandard:\"bsd\"\n},\n{\nname:\"SIGWINCH\",\nnumber:28,\naction:\"ignore\",\ndescription:\"Terminal window size changed\",\nstandard:\"bsd\"\n},\n{\nname:\"SIGIO\",\nnumber:29,\naction:\"terminate\",\ndescription:\"I/O is available\",\nstandard:\"other\"\n},\n{\nname:\"SIGPOLL\",\nnumber:29,\naction:\"terminate\",\ndescription:\"Watched event\",\nstandard:\"other\"\n},\n{\nname:\"SIGINFO\",\nnumber:29,\naction:\"ignore\",\ndescription:\"Request for process information\",\nstandard:\"other\"\n},\n{\nname:\"SIGPWR\",\nnumber:30,\naction:\"terminate\",\ndescription:\"Device running out of power\",\nstandard:\"systemv\"\n},\n{\nname:\"SIGSYS\",\nnumber:31,\naction:\"core\",\ndescription:\"Invalid system call\",\nstandard:\"other\"\n},\n{\nname:\"SIGUNUSED\",\nnumber:31,\naction:\"terminate\",\ndescription:\"Invalid system call\",\nstandard:\"other\"\n}];", "import{constants}from\"node:os\";\n\nimport{SIGNALS}from\"./core.js\";\nimport{getRealtimeSignals}from\"./realtime.js\";\n\n\n\nexport const getSignals=()=>{\nconst realtimeSignals=getRealtimeSignals();\nconst signals=[...SIGNALS,...realtimeSignals].map(normalizeSignal);\nreturn signals\n};\n\n\n\n\n\n\n\nconst normalizeSignal=({\nname,\nnumber:defaultNumber,\ndescription,\naction,\nforced=false,\nstandard\n})=>{\nconst{\nsignals:{[name]:constantSignal}\n}=constants;\nconst supported=constantSignal!==undefined;\nconst number=supported?constantSignal:defaultNumber;\nreturn{name,number,description,supported,action,forced,standard}\n};", "import{constants}from\"node:os\";\n\nimport{SIGRTMAX}from\"./realtime.js\";\nimport{getSignals}from\"./signals.js\";\n\n\n\nconst getSignalsByName=()=>{\nconst signals=getSignals();\nreturn Object.fromEntries(signals.map(getSignalByName))\n};\n\nconst getSignalByName=({\nname,\nnumber,\ndescription,\nsupported,\naction,\nforced,\nstandard\n})=>[name,{name,number,description,supported,action,forced,standard}];\n\nexport const signalsByName=getSignalsByName();\n\n\n\n\nconst getSignalsByNumber=()=>{\nconst signals=getSignals();\nconst length=SIGRTMAX+1;\nconst signalsA=Array.from({length},(value,number)=>\ngetSignalByNumber(number,signals)\n);\nreturn Object.assign({},...signalsA)\n};\n\nconst getSignalByNumber=(number,signals)=>{\nconst signal=findSignalByNumber(number,signals);\n\nif(signal===undefined){\nreturn{}\n}\n\nconst{name,description,supported,action,forced,standard}=signal;\nreturn{\n[number]:{\nname,\nnumber,\ndescription,\nsupported,\naction,\nforced,\nstandard\n}\n}\n};\n\n\n\nconst findSignalByNumber=(number,signals)=>{\nconst signal=signals.find(({name})=>constants.signals[name]===number);\n\nif(signal!==undefined){\nreturn signal\n}\n\nreturn signals.find((signalA)=>signalA.number===number)\n};\n\nexport const signalsByNumber=getSignalsByNumber();", "import {constants} from 'node:os';\nimport {signalsByName} from 'human-signals';\n\n// Normalize signals for comparison purpose.\n// Also validate the signal exists.\nexport const normalizeKillSignal = killSignal => {\n\tconst optionName = 'option `killSignal`';\n\tif (killSignal === 0) {\n\t\tthrow new TypeError(`Invalid ${optionName}: 0 cannot be used.`);\n\t}\n\n\treturn normalizeSignal(killSignal, optionName);\n};\n\nexport const normalizeSignalArgument = signal => signal === 0\n\t? signal\n\t: normalizeSignal(signal, '`subprocess.kill()`\\'s argument');\n\nconst normalizeSignal = (signalNameOrInteger, optionName) => {\n\tif (Number.isInteger(signalNameOrInteger)) {\n\t\treturn normalizeSignalInteger(signalNameOrInteger, optionName);\n\t}\n\n\tif (typeof signalNameOrInteger === 'string') {\n\t\treturn normalizeSignalName(signalNameOrInteger, optionName);\n\t}\n\n\tthrow new TypeError(`Invalid ${optionName} ${String(signalNameOrInteger)}: it must be a string or an integer.\\n${getAvailableSignals()}`);\n};\n\nconst normalizeSignalInteger = (signalInteger, optionName) => {\n\tif (signalsIntegerToName.has(signalInteger)) {\n\t\treturn signalsIntegerToName.get(signalInteger);\n\t}\n\n\tthrow new TypeError(`Invalid ${optionName} ${signalInteger}: this signal integer does not exist.\\n${getAvailableSignals()}`);\n};\n\nconst getSignalsIntegerToName = () => new Map(Object.entries(constants.signals)\n\t.reverse()\n\t.map(([signalName, signalInteger]) => [signalInteger, signalName]));\n\nconst signalsIntegerToName = getSignalsIntegerToName();\n\nconst normalizeSignalName = (signalName, optionName) => {\n\tif (signalName in constants.signals) {\n\t\treturn signalName;\n\t}\n\n\tif (signalName.toUpperCase() in constants.signals) {\n\t\tthrow new TypeError(`Invalid ${optionName} '${signalName}': please rename it to '${signalName.toUpperCase()}'.`);\n\t}\n\n\tthrow new TypeError(`Invalid ${optionName} '${signalName}': this signal name does not exist.\\n${getAvailableSignals()}`);\n};\n\nconst getAvailableSignals = () => `Available signal names: ${getAvailableSignalNames()}.\nAvailable signal numbers: ${getAvailableSignalIntegers()}.`;\n\nconst getAvailableSignalNames = () => Object.keys(constants.signals)\n\t.sort()\n\t.map(signalName => `'${signalName}'`)\n\t.join(', ');\n\nconst getAvailableSignalIntegers = () => [...new Set(Object.values(constants.signals)\n\t.sort((signalInteger, signalIntegerTwo) => signalInteger - signalIntegerTwo))]\n\t.join(', ');\n\n// Human-friendly description of a signal\nexport const getSignalDescription = signal => signalsByName[signal].description;\n", "import {setTimeout} from 'node:timers/promises';\nimport {isErrorInstance} from '../return/final-error.js';\nimport {normalizeSignalArgument} from './signal.js';\n\n// Normalize the `forceKillAfterDelay` option\nexport const normalizeForceKillAfterDelay = forceKillAfterDelay => {\n\tif (forceKillAfterDelay === false) {\n\t\treturn forceKillAfterDelay;\n\t}\n\n\tif (forceKillAfterDelay === true) {\n\t\treturn DEFAULT_FORCE_KILL_TIMEOUT;\n\t}\n\n\tif (!Number.isFinite(forceKillAfterDelay) || forceKillAfterDelay < 0) {\n\t\tthrow new TypeError(`Expected the \\`forceKillAfterDelay\\` option to be a non-negative integer, got \\`${forceKillAfterDelay}\\` (${typeof forceKillAfterDelay})`);\n\t}\n\n\treturn forceKillAfterDelay;\n};\n\nconst DEFAULT_FORCE_KILL_TIMEOUT = 1000 * 5;\n\n// Monkey-patches `subprocess.kill()` to add `forceKillAfterDelay` behavior and `.kill(error)`\nexport const subprocessKill = (\n\t{kill, options: {forceKillAfterDelay, killSignal}, onInternalError, context, controller},\n\tsignalOrError,\n\terrorArgument,\n) => {\n\tconst {signal, error} = parseKillArguments(signalOrError, errorArgument, killSignal);\n\temitKillError(error, onInternalError);\n\tconst killResult = kill(signal);\n\tsetKillTimeout({\n\t\tkill,\n\t\tsignal,\n\t\tforceKillAfterDelay,\n\t\tkillSignal,\n\t\tkillResult,\n\t\tcontext,\n\t\tcontroller,\n\t});\n\treturn killResult;\n};\n\nconst parseKillArguments = (signalOrError, errorArgument, killSignal) => {\n\tconst [signal = killSignal, error] = isErrorInstance(signalOrError)\n\t\t? [undefined, signalOrError]\n\t\t: [signalOrError, errorArgument];\n\n\tif (typeof signal !== 'string' && !Number.isInteger(signal)) {\n\t\tthrow new TypeError(`The first argument must be an error instance or a signal name string/integer: ${String(signal)}`);\n\t}\n\n\tif (error !== undefined && !isErrorInstance(error)) {\n\t\tthrow new TypeError(`The second argument is optional. If specified, it must be an error instance: ${error}`);\n\t}\n\n\treturn {signal: normalizeSignalArgument(signal), error};\n};\n\n// Fails right away when calling `subprocess.kill(error)`.\n// Does not wait for actual signal termination.\n// Uses a deferred promise instead of the `error` event on the subprocess, as this is less intrusive.\nconst emitKillError = (error, onInternalError) => {\n\tif (error !== undefined) {\n\t\tonInternalError.reject(error);\n\t}\n};\n\nconst setKillTimeout = async ({kill, signal, forceKillAfterDelay, killSignal, killResult, context, controller}) => {\n\tif (signal === killSignal && killResult) {\n\t\tkillOnTimeout({\n\t\t\tkill,\n\t\t\tforceKillAfterDelay,\n\t\t\tcontext,\n\t\t\tcontrollerSignal: controller.signal,\n\t\t});\n\t}\n};\n\n// Forcefully terminate a subprocess after a timeout\nexport const killOnTimeout = async ({kill, forceKillAfterDelay, context, controllerSignal}) => {\n\tif (forceKillAfterDelay === false) {\n\t\treturn;\n\t}\n\n\ttry {\n\t\tawait setTimeout(forceKillAfterDelay, undefined, {signal: controllerSignal});\n\t\tif (kill('SIGKILL')) {\n\t\t\tcontext.isForcefullyTerminated ??= true;\n\t\t}\n\t} catch {}\n};\n", "import {once} from 'node:events';\n\n// Combines `util.aborted()` and `events.addAbortListener()`: promise-based and cleaned up with a stop signal\nexport const onAbortedSignal = async (mainSignal, stopSignal) => {\n\tif (!mainSignal.aborted) {\n\t\tawait once(mainSignal, 'abort', {signal: stopSignal});\n\t}\n};\n", "import {onAbortedSignal} from '../utils/abort-signal.js';\n\n// Validate the `cancelSignal` option\nexport const validateCancelSignal = ({cancelSignal}) => {\n\tif (cancelSignal !== undefined && Object.prototype.toString.call(cancelSignal) !== '[object AbortSignal]') {\n\t\tthrow new Error(`The \\`cancelSignal\\` option must be an AbortSignal: ${String(cancelSignal)}`);\n\t}\n};\n\n// Terminate the subprocess when aborting the `cancelSignal` option and `gracefulSignal` is `false`\nexport const throwOnCancel = ({subprocess, cancelSignal, gracefulCancel, context, controller}) => cancelSignal === undefined || gracefulCancel\n\t? []\n\t: [terminateOnCancel(subprocess, cancelSignal, context, controller)];\n\nconst terminateOnCancel = async (subprocess, cancelSignal, context, {signal}) => {\n\tawait onAbortedSignal(cancelSignal, signal);\n\tcontext.terminationReason ??= 'cancel';\n\tsubprocess.kill();\n\tthrow cancelSignal.reason;\n};\n", "// Validate the IPC channel is connected before receiving/sending messages\nexport const validateIpcMethod = ({methodName, isSubprocess, ipc, isConnected}) => {\n\tvalidateIpcOption(methodName, isSubprocess, ipc);\n\tvalidateConnection(methodName, isSubprocess, isConnected);\n};\n\n// Better error message when forgetting to set `ipc: true` and using the IPC methods\nconst validateIpcOption = (methodName, isSubprocess, ipc) => {\n\tif (!ipc) {\n\t\tthrow new Error(`${getMethodName(methodName, isSubprocess)} can only be used if the \\`ipc\\` option is \\`true\\`.`);\n\t}\n};\n\n// Better error message when one process does not send/receive messages once the other process has disconnected.\n// This also makes it clear that any buffered messages are lost once either process has disconnected.\n// Also when aborting `cancelSignal` after disconnecting the IPC.\nexport const validateConnection = (methodName, isSubprocess, isConnected) => {\n\tif (!isConnected) {\n\t\tthrow new Error(`${getMethodName(methodName, isSubprocess)} cannot be used: the ${getOtherProcessName(isSubprocess)} has already exited or disconnected.`);\n\t}\n};\n\n// When `getOneMessage()` could not complete due to an early disconnection\nexport const throwOnEarlyDisconnect = isSubprocess => {\n\tthrow new Error(`${getMethodName('getOneMessage', isSubprocess)} could not complete: the ${getOtherProcessName(isSubprocess)} exited or disconnected.`);\n};\n\n// When both processes use `sendMessage()` with `strict` at the same time\nexport const throwOnStrictDeadlockError = isSubprocess => {\n\tthrow new Error(`${getMethodName('sendMessage', isSubprocess)} failed: the ${getOtherProcessName(isSubprocess)} is sending a message too, instead of listening to incoming messages.\nThis can be fixed by both sending a message and listening to incoming messages at the same time:\n\nconst [receivedMessage] = await Promise.all([\n\t${getMethodName('getOneMessage', isSubprocess)},\n\t${getMethodName('sendMessage', isSubprocess, 'message, {strict: true}')},\n]);`);\n};\n\n// When the other process used `strict` but the current process had I/O error calling `sendMessage()` for the response\nexport const getStrictResponseError = (error, isSubprocess) => new Error(`${getMethodName('sendMessage', isSubprocess)} failed when sending an acknowledgment response to the ${getOtherProcessName(isSubprocess)}.`, {cause: error});\n\n// When using `strict` but the other process was not listening for messages\nexport const throwOnMissingStrict = isSubprocess => {\n\tthrow new Error(`${getMethodName('sendMessage', isSubprocess)} failed: the ${getOtherProcessName(isSubprocess)} is not listening to incoming messages.`);\n};\n\n// When using `strict` but the other process disconnected before receiving the message\nexport const throwOnStrictDisconnect = isSubprocess => {\n\tthrow new Error(`${getMethodName('sendMessage', isSubprocess)} failed: the ${getOtherProcessName(isSubprocess)} exited without listening to incoming messages.`);\n};\n\n// When the current process disconnects while the subprocess is listening to `cancelSignal`\nexport const getAbortDisconnectError = () => new Error(`\\`cancelSignal\\` aborted: the ${getOtherProcessName(true)} disconnected.`);\n\n// When the subprocess uses `cancelSignal` but not the current process\nexport const throwOnMissingParent = () => {\n\tthrow new Error('`getCancelSignal()` cannot be used without setting the `cancelSignal` subprocess option.');\n};\n\n// EPIPE can happen when sending a message to a subprocess that is closing but has not disconnected yet\nexport const handleEpipeError = ({error, methodName, isSubprocess}) => {\n\tif (error.code === 'EPIPE') {\n\t\tthrow new Error(`${getMethodName(methodName, isSubprocess)} cannot be used: the ${getOtherProcessName(isSubprocess)} is disconnecting.`, {cause: error});\n\t}\n};\n\n// Better error message when sending messages which cannot be serialized.\n// Works with both `serialization: 'advanced'` and `serialization: 'json'`.\nexport const handleSerializationError = ({error, methodName, isSubprocess, message}) => {\n\tif (isSerializationError(error)) {\n\t\tthrow new Error(`${getMethodName(methodName, isSubprocess)}'s argument type is invalid: the message cannot be serialized: ${String(message)}.`, {cause: error});\n\t}\n};\n\nconst isSerializationError = ({code, message}) => SERIALIZATION_ERROR_CODES.has(code)\n\t|| SERIALIZATION_ERROR_MESSAGES.some(serializationErrorMessage => message.includes(serializationErrorMessage));\n\n// `error.code` set by Node.js when it failed to serialize the message\nconst SERIALIZATION_ERROR_CODES = new Set([\n\t// Message is `undefined`\n\t'ERR_MISSING_ARGS',\n\t// Message is a function, a bigint, a symbol\n\t'ERR_INVALID_ARG_TYPE',\n]);\n\n// `error.message` set by Node.js when it failed to serialize the message\nconst SERIALIZATION_ERROR_MESSAGES = [\n\t// Message is a promise or a proxy, with `serialization: 'advanced'`\n\t'could not be cloned',\n\t// Message has cycles, with `serialization: 'json'`\n\t'circular structure',\n\t// Message has cycles inside toJSON(), with `serialization: 'json'`\n\t'call stack size exceeded',\n];\n\nconst getMethodName = (methodName, isSubprocess, parameters = '') => methodName === 'cancelSignal'\n\t? '`cancelSignal`\\'s `controller.abort()`'\n\t: `${getNamespaceName(isSubprocess)}${methodName}(${parameters})`;\n\nconst getNamespaceName = isSubprocess => isSubprocess ? '' : 'subprocess.';\n\nconst getOtherProcessName = isSubprocess => isSubprocess ? 'parent process' : 'subprocess';\n\n// When any error arises, we disconnect the IPC.\n// Otherwise, it is likely that one of the processes will stop sending/receiving messages.\n// This would leave the other process hanging.\nexport const disconnect = anyProcess => {\n\tif (anyProcess.connected) {\n\t\tanyProcess.disconnect();\n\t}\n};\n", "export const createDeferred = () => {\n\tconst methods = {};\n\tconst promise = new Promise((resolve, reject) => {\n\t\tObject.assign(methods, {resolve, reject});\n\t});\n\treturn Object.assign(promise, methods);\n};\n", "import {parseFd} from './specific.js';\n\n// Retrieve stream targeted by the `to` option\nexport const getToStream = (destination, to = 'stdin') => {\n\tconst isWritable = true;\n\tconst {options, fileDescriptors} = SUBPROCESS_OPTIONS.get(destination);\n\tconst fdNumber = getFdNumber(fileDescriptors, to, isWritable);\n\tconst destinationStream = destination.stdio[fdNumber];\n\n\tif (destinationStream === null) {\n\t\tthrow new TypeError(getInvalidStdioOptionMessage(fdNumber, to, options, isWritable));\n\t}\n\n\treturn destinationStream;\n};\n\n// Retrieve stream targeted by the `from` option\nexport const getFromStream = (source, from = 'stdout') => {\n\tconst isWritable = false;\n\tconst {options, fileDescriptors} = SUBPROCESS_OPTIONS.get(source);\n\tconst fdNumber = getFdNumber(fileDescriptors, from, isWritable);\n\tconst sourceStream = fdNumber === 'all' ? source.all : source.stdio[fdNumber];\n\n\tif (sourceStream === null || sourceStream === undefined) {\n\t\tthrow new TypeError(getInvalidStdioOptionMessage(fdNumber, from, options, isWritable));\n\t}\n\n\treturn sourceStream;\n};\n\n// Keeps track of the options passed to each Execa call\nexport const SUBPROCESS_OPTIONS = new WeakMap();\n\nconst getFdNumber = (fileDescriptors, fdName, isWritable) => {\n\tconst fdNumber = parseFdNumber(fdName, isWritable);\n\tvalidateFdNumber(fdNumber, fdName, isWritable, fileDescriptors);\n\treturn fdNumber;\n};\n\nconst parseFdNumber = (fdName, isWritable) => {\n\tconst fdNumber = parseFd(fdName);\n\tif (fdNumber !== undefined) {\n\t\treturn fdNumber;\n\t}\n\n\tconst {validOptions, defaultValue} = isWritable\n\t\t? {validOptions: '\"stdin\"', defaultValue: 'stdin'}\n\t\t: {validOptions: '\"stdout\", \"stderr\", \"all\"', defaultValue: 'stdout'};\n\tthrow new TypeError(`\"${getOptionName(isWritable)}\" must not be \"${fdName}\".\nIt must be ${validOptions} or \"fd3\", \"fd4\" (and so on).\nIt is optional and defaults to \"${defaultValue}\".`);\n};\n\nconst validateFdNumber = (fdNumber, fdName, isWritable, fileDescriptors) => {\n\tconst fileDescriptor = fileDescriptors[getUsedDescriptor(fdNumber)];\n\tif (fileDescriptor === undefined) {\n\t\tthrow new TypeError(`\"${getOptionName(isWritable)}\" must not be ${fdName}. That file descriptor does not exist.\nPlease set the \"stdio\" option to ensure that file descriptor exists.`);\n\t}\n\n\tif (fileDescriptor.direction === 'input' && !isWritable) {\n\t\tthrow new TypeError(`\"${getOptionName(isWritable)}\" must not be ${fdName}. It must be a readable stream, not writable.`);\n\t}\n\n\tif (fileDescriptor.direction !== 'input' && isWritable) {\n\t\tthrow new TypeError(`\"${getOptionName(isWritable)}\" must not be ${fdName}. It must be a writable stream, not readable.`);\n\t}\n};\n\nconst getInvalidStdioOptionMessage = (fdNumber, fdName, options, isWritable) => {\n\tif (fdNumber === 'all' && !options.all) {\n\t\treturn 'The \"all\" option must be true to use \"from: \\'all\\'\".';\n\t}\n\n\tconst {optionName, optionValue} = getInvalidStdioOption(fdNumber, options);\n\treturn `The \"${optionName}: ${serializeOptionValue(optionValue)}\" option is incompatible with using \"${getOptionName(isWritable)}: ${serializeOptionValue(fdName)}\".\nPlease set this option with \"pipe\" instead.`;\n};\n\nconst getInvalidStdioOption = (fdNumber, {stdin, stdout, stderr, stdio}) => {\n\tconst usedDescriptor = getUsedDescriptor(fdNumber);\n\n\tif (usedDescriptor === 0 && stdin !== undefined) {\n\t\treturn {optionName: 'stdin', optionValue: stdin};\n\t}\n\n\tif (usedDescriptor === 1 && stdout !== undefined) {\n\t\treturn {optionName: 'stdout', optionValue: stdout};\n\t}\n\n\tif (usedDescriptor === 2 && stderr !== undefined) {\n\t\treturn {optionName: 'stderr', optionValue: stderr};\n\t}\n\n\treturn {optionName: `stdio[${usedDescriptor}]`, optionValue: stdio[usedDescriptor]};\n};\n\nconst getUsedDescriptor = fdNumber => fdNumber === 'all' ? 1 : fdNumber;\n\nconst getOptionName = isWritable => isWritable ? 'to' : 'from';\n\nexport const serializeOptionValue = value => {\n\tif (typeof value === 'string') {\n\t\treturn `'${value}'`;\n\t}\n\n\treturn typeof value === 'number' ? `${value}` : 'Stream';\n};\n", "import {addAbortListener} from 'node:events';\n\n// Temporarily increase the maximum number of listeners on an eventEmitter\nexport const incrementMaxListeners = (eventEmitter, maxListenersIncrement, signal) => {\n\tconst maxListeners = eventEmitter.getMaxListeners();\n\tif (maxListeners === 0 || maxListeners === Number.POSITIVE_INFINITY) {\n\t\treturn;\n\t}\n\n\teventEmitter.setMaxListeners(maxListeners + maxListenersIncrement);\n\taddAbortListener(signal, () => {\n\t\teventEmitter.setMaxListeners(eventEmitter.getMaxListeners() - maxListenersIncrement);\n\t});\n};\n", "// By default, Node.js keeps the subprocess alive while it has a `message` or `disconnect` listener.\n// We replicate the same logic for the events that we proxy.\n// This ensures the subprocess is kept alive while `getOneMessage()` and `getEachMessage()` are ongoing.\n// This is not a problem with `sendMessage()` since Node.js handles that method automatically.\n// We do not use `anyProcess.channel.ref()` since this would prevent the automatic `.channel.refCounted()` Node.js is doing.\n// We keep a reference to `anyProcess.channel` since it might be `null` while `getOneMessage()` or `getEachMessage()` is still processing debounced messages.\n// See https://github.com/nodejs/node/blob/2aaeaa863c35befa2ebaa98fb7737ec84df4d8e9/lib/internal/child_process.js#L547\nexport const addReference = (channel, reference) => {\n\tif (reference) {\n\t\taddReferenceCount(channel);\n\t}\n};\n\nconst addReferenceCount = channel => {\n\tchannel.refCounted();\n};\n\nexport const removeReference = (channel, reference) => {\n\tif (reference) {\n\t\tremoveReferenceCount(channel);\n\t}\n};\n\nconst removeReferenceCount = channel => {\n\tchannel.unrefCounted();\n};\n\n// To proxy events, we setup some global listeners on the `message` and `disconnect` events.\n// Those should not keep the subprocess alive, so we remove the automatic counting that Node.js is doing.\n// See https://github.com/nodejs/node/blob/1b965270a9c273d4cf70e8808e9d28b9ada7844f/lib/child_process.js#L180\nexport const undoAddedReferences = (channel, isSubprocess) => {\n\tif (isSubprocess) {\n\t\tremoveReferenceCount(channel);\n\t\tremoveReferenceCount(channel);\n\t}\n};\n\n// Reverse it during `disconnect`\nexport const redoAddedReferences = (channel, isSubprocess) => {\n\tif (isSubprocess) {\n\t\taddReferenceCount(channel);\n\t\taddReferenceCount(channel);\n\t}\n};\n", "import {once} from 'node:events';\nimport {scheduler} from 'node:timers/promises';\nimport {waitForOutgoingMessages} from './outgoing.js';\nimport {redoAddedReferences} from './reference.js';\nimport {handleStrictRequest, handleStrictResponse} from './strict.js';\nimport {handleAbort, abortOnDisconnect} from './graceful.js';\n\n// By default, Node.js buffers `message` events.\n//  - Buffering happens when there is a `message` event is emitted but there is no handler.\n//  - As soon as a `message` event handler is set, all buffered `message` events are emitted, emptying the buffer.\n//  - This happens both in the current process and the subprocess.\n//  - See https://github.com/nodejs/node/blob/501546e8f37059cd577041e23941b640d0d4d406/lib/internal/child_process.js#L719\n// This is helpful. Notably, this allows sending messages to a subprocess that's still initializing.\n// However, it has several problems.\n//  - This works with `events.on()` but not `events.once()` since all buffered messages are emitted at once.\n//    For example, users cannot call `await getOneMessage()`/`getEachMessage()` multiple times in a row.\n//  - When a user intentionally starts listening to `message` at a specific point in time, past `message` events are replayed, which might be unexpected.\n//  - Buffering is unlimited, which might lead to an out-of-memory crash.\n//  - This does not work well with multiple consumers.\n//    For example, Execa consumes events with both `result.ipcOutput` and manual IPC calls like `getOneMessage()`.\n//    Since `result.ipcOutput` reads all incoming messages, no buffering happens for manual IPC calls.\n//  - Forgetting to setup a `message` listener, or setting it up too late, is a programming mistake.\n//    The default behavior does not allow users to realize they made that mistake.\n// To solve those problems, instead of buffering messages, we debounce them.\n// The `message` event so it is emitted at most once per macrotask.\nexport const onMessage = async ({anyProcess, channel, isSubprocess, ipcEmitter}, wrappedMessage) => {\n\tif (handleStrictResponse(wrappedMessage) || handleAbort(wrappedMessage)) {\n\t\treturn;\n\t}\n\n\tif (!INCOMING_MESSAGES.has(anyProcess)) {\n\t\tINCOMING_MESSAGES.set(anyProcess, []);\n\t}\n\n\tconst incomingMessages = INCOMING_MESSAGES.get(anyProcess);\n\tincomingMessages.push(wrappedMessage);\n\n\tif (incomingMessages.length > 1) {\n\t\treturn;\n\t}\n\n\twhile (incomingMessages.length > 0) {\n\t\t// eslint-disable-next-line no-await-in-loop\n\t\tawait waitForOutgoingMessages(anyProcess, ipcEmitter, wrappedMessage);\n\t\t// eslint-disable-next-line no-await-in-loop\n\t\tawait scheduler.yield();\n\n\t\t// eslint-disable-next-line no-await-in-loop\n\t\tconst message = await handleStrictRequest({\n\t\t\twrappedMessage: incomingMessages[0],\n\t\t\tanyProcess,\n\t\t\tchannel,\n\t\t\tisSubprocess,\n\t\t\tipcEmitter,\n\t\t});\n\n\t\tincomingMessages.shift();\n\t\tipcEmitter.emit('message', message);\n\t\tipcEmitter.emit('message:done');\n\t}\n};\n\n// If the `message` event is currently debounced, the `disconnect` event must wait for it\nexport const onDisconnect = async ({anyProcess, channel, isSubprocess, ipcEmitter, boundOnMessage}) => {\n\tabortOnDisconnect();\n\n\tconst incomingMessages = INCOMING_MESSAGES.get(anyProcess);\n\twhile (incomingMessages?.length > 0) {\n\t\t// eslint-disable-next-line no-await-in-loop\n\t\tawait once(ipcEmitter, 'message:done');\n\t}\n\n\tanyProcess.removeListener('message', boundOnMessage);\n\tredoAddedReferences(channel, isSubprocess);\n\tipcEmitter.connected = false;\n\tipcEmitter.emit('disconnect');\n};\n\nconst INCOMING_MESSAGES = new WeakMap();\n", "import {EventEmitter} from 'node:events';\nimport {onMessage, onDisconnect} from './incoming.js';\nimport {undoAddedReferences} from './reference.js';\n\n// Forward the `message` and `disconnect` events from the process and subprocess to a proxy emitter.\n// This prevents the `error` event from stopping IPC.\n// This also allows debouncing the `message` event.\nexport const getIpcEmitter = (anyProcess, channel, isSubprocess) => {\n\tif (IPC_EMITTERS.has(anyProcess)) {\n\t\treturn IPC_EMITTERS.get(anyProcess);\n\t}\n\n\t// Use an `EventEmitter`, like the `process` that is being proxied\n\t// eslint-disable-next-line unicorn/prefer-event-target\n\tconst ipcEmitter = new EventEmitter();\n\tipcEmitter.connected = true;\n\tIPC_EMITTERS.set(anyProcess, ipcEmitter);\n\tforwardEvents({\n\t\tipcEmitter,\n\t\tanyProcess,\n\t\tchannel,\n\t\tisSubprocess,\n\t});\n\treturn ipcEmitter;\n};\n\nconst IPC_EMITTERS = new WeakMap();\n\n// The `message` and `disconnect` events are buffered in the subprocess until the first listener is setup.\n// However, unbuffering happens after one tick, so this give enough time for the caller to setup the listener on the proxy emitter first.\n// See https://github.com/nodejs/node/blob/2aaeaa863c35befa2ebaa98fb7737ec84df4d8e9/lib/internal/child_process.js#L721\nconst forwardEvents = ({ipcEmitter, anyProcess, channel, isSubprocess}) => {\n\tconst boundOnMessage = onMessage.bind(undefined, {\n\t\tanyProcess,\n\t\tchannel,\n\t\tisSubprocess,\n\t\tipcEmitter,\n\t});\n\tanyProcess.on('message', boundOnMessage);\n\tanyProcess.once('disconnect', onDisconnect.bind(undefined, {\n\t\tanyProcess,\n\t\tchannel,\n\t\tisSubprocess,\n\t\tipcEmitter,\n\t\tboundOnMessage,\n\t}));\n\tundoAddedReferences(channel, isSubprocess);\n};\n\n// Check whether there might still be some `message` events to receive\nexport const isConnected = anyProcess => {\n\tconst ipcEmitter = IPC_EMITTERS.get(anyProcess);\n\treturn ipcEmitter === undefined\n\t\t? anyProcess.channel !== null\n\t\t: ipcEmitter.connected;\n};\n", "import {once} from 'node:events';\nimport {createDeferred} from '../utils/deferred.js';\nimport {incrementMaxListeners} from '../utils/max-listeners.js';\nimport {sendMessage} from './send.js';\nimport {throwOnMissingStrict, throwOnStrictDisconnect, throwOnStrictDeadlockError} from './validation.js';\nimport {getIpcEmitter} from './forward.js';\nimport {hasMessageListeners} from './outgoing.js';\n\n// When using the `strict` option, wrap the message with metadata during `sendMessage()`\nexport const handleSendStrict = ({anyProcess, channel, isSubprocess, message, strict}) => {\n\tif (!strict) {\n\t\treturn message;\n\t}\n\n\tconst ipcEmitter = getIpcEmitter(anyProcess, channel, isSubprocess);\n\tconst hasListeners = hasMessageListeners(anyProcess, ipcEmitter);\n\treturn {\n\t\tid: count++,\n\t\ttype: REQUEST_TYPE,\n\t\tmessage,\n\t\thasListeners,\n\t};\n};\n\nlet count = 0n;\n\n// Handles when both processes are calling `sendMessage()` with `strict` at the same time.\n// If neither process is listening, this would create a deadlock. We detect it and throw.\nexport const validateStrictDeadlock = (outgoingMessages, wrappedMessage) => {\n\tif (wrappedMessage?.type !== REQUEST_TYPE || wrappedMessage.hasListeners) {\n\t\treturn;\n\t}\n\n\tfor (const {id} of outgoingMessages) {\n\t\tif (id !== undefined) {\n\t\t\tSTRICT_RESPONSES[id].resolve({isDeadlock: true, hasListeners: false});\n\t\t}\n\t}\n};\n\n// The other process then sends the acknowledgment back as a response\nexport const handleStrictRequest = async ({wrappedMessage, anyProcess, channel, isSubprocess, ipcEmitter}) => {\n\tif (wrappedMessage?.type !== REQUEST_TYPE || !anyProcess.connected) {\n\t\treturn wrappedMessage;\n\t}\n\n\tconst {id, message} = wrappedMessage;\n\tconst response = {id, type: RESPONSE_TYPE, message: hasMessageListeners(anyProcess, ipcEmitter)};\n\n\ttry {\n\t\tawait sendMessage({\n\t\t\tanyProcess,\n\t\t\tchannel,\n\t\t\tisSubprocess,\n\t\t\tipc: true,\n\t\t}, response);\n\t} catch (error) {\n\t\tipcEmitter.emit('strict:error', error);\n\t}\n\n\treturn message;\n};\n\n// Reception of the acknowledgment response\nexport const handleStrictResponse = wrappedMessage => {\n\tif (wrappedMessage?.type !== RESPONSE_TYPE) {\n\t\treturn false;\n\t}\n\n\tconst {id, message: hasListeners} = wrappedMessage;\n\tSTRICT_RESPONSES[id]?.resolve({isDeadlock: false, hasListeners});\n\treturn true;\n};\n\n// Wait for the other process to receive the message from `sendMessage()`\nexport const waitForStrictResponse = async (wrappedMessage, anyProcess, isSubprocess) => {\n\tif (wrappedMessage?.type !== REQUEST_TYPE) {\n\t\treturn;\n\t}\n\n\tconst deferred = createDeferred();\n\tSTRICT_RESPONSES[wrappedMessage.id] = deferred;\n\tconst controller = new AbortController();\n\n\ttry {\n\t\tconst {isDeadlock, hasListeners} = await Promise.race([\n\t\t\tdeferred,\n\t\t\tthrowOnDisconnect(anyProcess, isSubprocess, controller),\n\t\t]);\n\n\t\tif (isDeadlock) {\n\t\t\tthrowOnStrictDeadlockError(isSubprocess);\n\t\t}\n\n\t\tif (!hasListeners) {\n\t\t\tthrowOnMissingStrict(isSubprocess);\n\t\t}\n\t} finally {\n\t\tcontroller.abort();\n\t\tdelete STRICT_RESPONSES[wrappedMessage.id];\n\t}\n};\n\nconst STRICT_RESPONSES = {};\n\nconst throwOnDisconnect = async (anyProcess, isSubprocess, {signal}) => {\n\tincrementMaxListeners(anyProcess, 1, signal);\n\tawait once(anyProcess, 'disconnect', {signal});\n\tthrowOnStrictDisconnect(isSubprocess);\n};\n\nconst REQUEST_TYPE = 'execa:ipc:request';\nconst RESPONSE_TYPE = 'execa:ipc:response';\n", "import {createDeferred} from '../utils/deferred.js';\nimport {getFdSpecificValue} from '../arguments/specific.js';\nimport {SUBPROCESS_OPTIONS} from '../arguments/fd-options.js';\nimport {validateStrictDeadlock} from './strict.js';\n\n// When `sendMessage()` is ongoing, any `message` being received waits before being emitted.\n// This allows calling one or multiple `await sendMessage()` followed by `await getOneMessage()`/`await getEachMessage()`.\n// Without running into a race condition when the other process sends a response too fast, before the current process set up a listener.\nexport const startSendMessage = (anyProcess, wrappedMessage, strict) => {\n\tif (!OUTGOING_MESSAGES.has(anyProcess)) {\n\t\tOUTGOING_MESSAGES.set(anyProcess, new Set());\n\t}\n\n\tconst outgoingMessages = OUTGOING_MESSAGES.get(anyProcess);\n\tconst onMessageSent = createDeferred();\n\tconst id = strict ? wrappedMessage.id : undefined;\n\tconst outgoingMessage = {onMessageSent, id};\n\toutgoingMessages.add(outgoingMessage);\n\treturn {outgoingMessages, outgoingMessage};\n};\n\nexport const endSendMessage = ({outgoingMessages, outgoingMessage}) => {\n\toutgoingMessages.delete(outgoingMessage);\n\toutgoingMessage.onMessageSent.resolve();\n};\n\n// Await while `sendMessage()` is ongoing, unless there is already a `message` listener\nexport const waitForOutgoingMessages = async (anyProcess, ipcEmitter, wrappedMessage) => {\n\twhile (!hasMessageListeners(anyProcess, ipcEmitter) && OUTGOING_MESSAGES.get(anyProcess)?.size > 0) {\n\t\tconst outgoingMessages = [...OUTGOING_MESSAGES.get(anyProcess)];\n\t\tvalidateStrictDeadlock(outgoingMessages, wrappedMessage);\n\t\t// eslint-disable-next-line no-await-in-loop\n\t\tawait Promise.all(outgoingMessages.map(({onMessageSent}) => onMessageSent));\n\t}\n};\n\nconst OUTGOING_MESSAGES = new WeakMap();\n\n// Whether any `message` listener is setup\nexport const hasMessageListeners = (anyProcess, ipcEmitter) => ipcEmitter.listenerCount('message') > getMinListenerCount(anyProcess);\n\n// When `buffer` is `false`, we set up a `message` listener that should be ignored.\n// That listener is only meant to intercept `strict` acknowledgement responses.\nconst getMinListenerCount = anyProcess => SUBPROCESS_OPTIONS.has(anyProcess)\n\t&& !getFdSpecificValue(SUBPROCESS_OPTIONS.get(anyProcess).options.buffer, 'ipc')\n\t? 1\n\t: 0;\n", "import {promisify} from 'node:util';\nimport {\n\tvalidateIpcMethod,\n\thandleEpipeError,\n\thandleSerializationError,\n\tdisconnect,\n} from './validation.js';\nimport {startSendMessage, endSendMessage} from './outgoing.js';\nimport {handleSendStrict, waitForStrictResponse} from './strict.js';\n\n// Like `[sub]process.send()` but promise-based.\n// We do not `await subprocess` during `.sendMessage()` nor `.getOneMessage()` since those methods are transient.\n// Users would still need to `await subprocess` after the method is done.\n// Also, this would prevent `unhandledRejection` event from being emitted, making it silent.\nexport const sendMessage = ({anyProcess, channel, isSubprocess, ipc}, message, {strict = false} = {}) => {\n\tconst methodName = 'sendMessage';\n\tvalidateIpcMethod({\n\t\tmethodName,\n\t\tisSubprocess,\n\t\tipc,\n\t\tisConnected: anyProcess.connected,\n\t});\n\n\treturn sendMessageAsync({\n\t\tanyProcess,\n\t\tchannel,\n\t\tmethodName,\n\t\tisSubprocess,\n\t\tmessage,\n\t\tstrict,\n\t});\n};\n\nconst sendMessageAsync = async ({anyProcess, channel, methodName, isSubprocess, message, strict}) => {\n\tconst wrappedMessage = handleSendStrict({\n\t\tanyProcess,\n\t\tchannel,\n\t\tisSubprocess,\n\t\tmessage,\n\t\tstrict,\n\t});\n\tconst outgoingMessagesState = startSendMessage(anyProcess, wrappedMessage, strict);\n\ttry {\n\t\tawait sendOneMessage({\n\t\t\tanyProcess,\n\t\t\tmethodName,\n\t\t\tisSubprocess,\n\t\t\twrappedMessage,\n\t\t\tmessage,\n\t\t});\n\t} catch (error) {\n\t\tdisconnect(anyProcess);\n\t\tthrow error;\n\t} finally {\n\t\tendSendMessage(outgoingMessagesState);\n\t}\n};\n\n// Used internally by `cancelSignal`\nexport const sendOneMessage = async ({anyProcess, methodName, isSubprocess, wrappedMessage, message}) => {\n\tconst sendMethod = getSendMethod(anyProcess);\n\n\ttry {\n\t\tawait Promise.all([\n\t\t\twaitForStrictResponse(wrappedMessage, anyProcess, isSubprocess),\n\t\t\tsendMethod(wrappedMessage),\n\t\t]);\n\t} catch (error) {\n\t\thandleEpipeError({error, methodName, isSubprocess});\n\t\thandleSerializationError({\n\t\t\terror,\n\t\t\tmethodName,\n\t\t\tisSubprocess,\n\t\t\tmessage,\n\t\t});\n\t\tthrow error;\n\t}\n};\n\n// [sub]process.send() promisified, memoized\nconst getSendMethod = anyProcess => {\n\tif (PROCESS_SEND_METHODS.has(anyProcess)) {\n\t\treturn PROCESS_SEND_METHODS.get(anyProcess);\n\t}\n\n\tconst sendMethod = promisify(anyProcess.send.bind(anyProcess));\n\tPROCESS_SEND_METHODS.set(anyProcess, sendMethod);\n\treturn sendMethod;\n};\n\nconst PROCESS_SEND_METHODS = new WeakMap();\n", "import {scheduler} from 'node:timers/promises';\nimport {sendOneMessage} from './send.js';\nimport {getIpcEmitter} from './forward.js';\nimport {validateConnection, getAbortDisconnectError, throwOnMissingParent} from './validation.js';\n\n// Send an IPC message so the subprocess performs a graceful termination\nexport const sendAbort = (subprocess, message) => {\n\tconst methodName = 'cancelSignal';\n\tvalidateConnection(methodName, false, subprocess.connected);\n\treturn sendOneMessage({\n\t\tanyProcess: subprocess,\n\t\tmethodName,\n\t\tisSubprocess: false,\n\t\twrappedMessage: {type: GRACEFUL_CANCEL_TYPE, message},\n\t\tmessage,\n\t});\n};\n\n// When the signal is being used, start listening for incoming messages.\n// Unbuffering messages takes one microtask to complete, so this must be async.\nexport const getCancelSignal = async ({anyProcess, channel, isSubprocess, ipc}) => {\n\tawait startIpc({\n\t\tanyProcess,\n\t\tchannel,\n\t\tisSubprocess,\n\t\tipc,\n\t});\n\treturn cancelController.signal;\n};\n\nconst startIpc = async ({anyProcess, channel, isSubprocess, ipc}) => {\n\tif (cancelListening) {\n\t\treturn;\n\t}\n\n\tcancelListening = true;\n\n\tif (!ipc) {\n\t\tthrowOnMissingParent();\n\t\treturn;\n\t}\n\n\tif (channel === null) {\n\t\tabortOnDisconnect();\n\t\treturn;\n\t}\n\n\tgetIpcEmitter(anyProcess, channel, isSubprocess);\n\tawait scheduler.yield();\n};\n\nlet cancelListening = false;\n\n// Reception of IPC message to perform a graceful termination\nexport const handleAbort = wrappedMessage => {\n\tif (wrappedMessage?.type !== GRACEFUL_CANCEL_TYPE) {\n\t\treturn false;\n\t}\n\n\tcancelController.abort(wrappedMessage.message);\n\treturn true;\n};\n\nconst GRACEFUL_CANCEL_TYPE = 'execa:ipc:cancel';\n\n// When the current process disconnects early, the subprocess `cancelSignal` is aborted.\n// Otherwise, the signal would never be able to be aborted later on.\nexport const abortOnDisconnect = () => {\n\tcancelController.abort(getAbortDisconnectError());\n};\n\nconst cancelController = new AbortController();\n", "import {onAbortedSignal} from '../utils/abort-signal.js';\nimport {sendAbort} from '../ipc/graceful.js';\nimport {killOnTimeout} from './kill.js';\n\n// Validate the `gracefulCancel` option\nexport const validateGracefulCancel = ({gracefulCancel, cancelSignal, ipc, serialization}) => {\n\tif (!gracefulCancel) {\n\t\treturn;\n\t}\n\n\tif (cancelSignal === undefined) {\n\t\tthrow new Error('The `cancelSignal` option must be defined when setting the `gracefulCancel` option.');\n\t}\n\n\tif (!ipc) {\n\t\tthrow new Error('The `ipc` option cannot be false when setting the `gracefulCancel` option.');\n\t}\n\n\tif (serialization === 'json') {\n\t\tthrow new Error('The `serialization` option cannot be \\'json\\' when setting the `gracefulCancel` option.');\n\t}\n};\n\n// Send abort reason to the subprocess when aborting the `cancelSignal` option and `gracefulCancel` is `true`\nexport const throwOnGracefulCancel = ({\n\tsubprocess,\n\tcancelSignal,\n\tgracefulCancel,\n\tforceKillAfterDelay,\n\tcontext,\n\tcontroller,\n}) => gracefulCancel\n\t? [sendOnAbort({\n\t\tsubprocess,\n\t\tcancelSignal,\n\t\tforceKillAfterDelay,\n\t\tcontext,\n\t\tcontroller,\n\t})]\n\t: [];\n\nconst sendOnAbort = async ({subprocess, cancelSignal, forceKillAfterDelay, context, controller: {signal}}) => {\n\tawait onAbortedSignal(cancelSignal, signal);\n\tconst reason = getReason(cancelSignal);\n\tawait sendAbort(subprocess, reason);\n\tkillOnTimeout({\n\t\tkill: subprocess.kill,\n\t\tforceKillAfterDelay,\n\t\tcontext,\n\t\tcontrollerSignal: signal,\n\t});\n\tcontext.terminationReason ??= 'gracefulCancel';\n\tthrow cancelSignal.reason;\n};\n\n// The default `reason` is a DOMException, which is not serializable with V8\n// See https://github.com/nodejs/node/issues/53225\nconst getReason = ({reason}) => {\n\tif (!(reason instanceof DOMException)) {\n\t\treturn reason;\n\t}\n\n\tconst error = new Error(reason.message);\n\tObject.defineProperty(error, 'stack', {\n\t\tvalue: reason.stack,\n\t\tenumerable: false,\n\t\tconfigurable: true,\n\t\twritable: true,\n\t});\n\treturn error;\n};\n", "import {setTimeout} from 'node:timers/promises';\nimport {DiscardedError} from '../return/final-error.js';\n\n// Validate `timeout` option\nexport const validateTimeout = ({timeout}) => {\n\tif (timeout !== undefined && (!Number.isFinite(timeout) || timeout < 0)) {\n\t\tthrow new TypeError(`Expected the \\`timeout\\` option to be a non-negative integer, got \\`${timeout}\\` (${typeof timeout})`);\n\t}\n};\n\n// Fails when the `timeout` option is exceeded\nexport const throwOnTimeout = (subprocess, timeout, context, controller) => timeout === 0 || timeout === undefined\n\t? []\n\t: [killAfterTimeout(subprocess, timeout, context, controller)];\n\nconst killAfterTimeout = async (subprocess, timeout, context, {signal}) => {\n\tawait setTimeout(timeout, undefined, {signal});\n\tcontext.terminationReason ??= 'timeout';\n\tsubprocess.kill();\n\tthrow new DiscardedError();\n};\n", "import {execPath, execArgv} from 'node:process';\nimport path from 'node:path';\nimport {safeNormalizeFileUrl} from '../arguments/file-url.js';\n\n// `execaNode()` is a shortcut for `execa(..., {node: true})`\nexport const mapNode = ({options}) => {\n\tif (options.node === false) {\n\t\tthrow new TypeError('The \"node\" option cannot be false with `execaNode()`.');\n\t}\n\n\treturn {options: {...options, node: true}};\n};\n\n// Applies the `node: true` option, and the related `nodePath`/`nodeOptions` options.\n// Modifies the file commands/arguments to ensure the same Node binary and flags are re-used.\n// Also adds `ipc: true` and `shell: false`.\nexport const handleNodeOption = (file, commandArguments, {\n\tnode: shouldHandleNode = false,\n\tnodePath = execPath,\n\tnodeOptions = execArgv.filter(nodeOption => !nodeOption.startsWith('--inspect')),\n\tcwd,\n\texecPath: formerNodePath,\n\t...options\n}) => {\n\tif (formerNodePath !== undefined) {\n\t\tthrow new TypeError('The \"execPath\" option has been removed. Please use the \"nodePath\" option instead.');\n\t}\n\n\tconst normalizedNodePath = safeNormalizeFileUrl(nodePath, 'The \"nodePath\" option');\n\tconst resolvedNodePath = path.resolve(cwd, normalizedNodePath);\n\tconst newOptions = {\n\t\t...options,\n\t\tnodePath: resolvedNodePath,\n\t\tnode: shouldHandleNode,\n\t\tcwd,\n\t};\n\n\tif (!shouldHandleNode) {\n\t\treturn [file, commandArguments, newOptions];\n\t}\n\n\tif (path.basename(file, '.exe') === 'node') {\n\t\tthrow new TypeError('When the \"node\" option is true, the first argument does not need to be \"node\".');\n\t}\n\n\treturn [\n\t\tresolvedNodePath,\n\t\t[...nodeOptions, file, ...commandArguments],\n\t\t{ipc: true, ...newOptions, shell: false},\n\t];\n};\n", "import {serialize} from 'node:v8';\n\n// Validate the `ipcInput` option\nexport const validateIpcInputOption = ({ipcInput, ipc, serialization}) => {\n\tif (ipcInput === undefined) {\n\t\treturn;\n\t}\n\n\tif (!ipc) {\n\t\tthrow new Error('The `ipcInput` option cannot be set unless the `ipc` option is `true`.');\n\t}\n\n\tvalidateIpcInput[serialization](ipcInput);\n};\n\nconst validateAdvancedInput = ipcInput => {\n\ttry {\n\t\tserialize(ipcInput);\n\t} catch (error) {\n\t\tthrow new Error('The `ipcInput` option is not serializable with a structured clone.', {cause: error});\n\t}\n};\n\nconst validateJsonInput = ipcInput => {\n\ttry {\n\t\tJSON.stringify(ipcInput);\n\t} catch (error) {\n\t\tthrow new Error('The `ipcInput` option is not serializable with JSON.', {cause: error});\n\t}\n};\n\nconst validateIpcInput = {\n\tadvanced: validateAdvancedInput,\n\tjson: validateJsonInput,\n};\n\n// When the `ipcInput` option is set, it is sent as an initial IPC message to the subprocess\nexport const sendIpcInput = async (subprocess, ipcInput) => {\n\tif (ipcInput === undefined) {\n\t\treturn;\n\t}\n\n\tawait subprocess.sendMessage(ipcInput);\n};\n", "// Validate `encoding` option\nexport const validateEncoding = ({encoding}) => {\n\tif (ENCODINGS.has(encoding)) {\n\t\treturn;\n\t}\n\n\tconst correctEncoding = getCorrectEncoding(encoding);\n\tif (correctEncoding !== undefined) {\n\t\tthrow new TypeError(`Invalid option \\`encoding: ${serializeEncoding(encoding)}\\`.\nPlease rename it to ${serializeEncoding(correctEncoding)}.`);\n\t}\n\n\tconst correctEncodings = [...ENCODINGS].map(correctEncoding => serializeEncoding(correctEncoding)).join(', ');\n\tthrow new TypeError(`Invalid option \\`encoding: ${serializeEncoding(encoding)}\\`.\nPlease rename it to one of: ${correctEncodings}.`);\n};\n\nconst TEXT_ENCODINGS = new Set(['utf8', 'utf16le']);\nexport const BINARY_ENCODINGS = new Set(['buffer', 'hex', 'base64', 'base64url', 'latin1', 'ascii']);\nconst ENCODINGS = new Set([...TEXT_ENCODINGS, ...BINARY_ENCODINGS]);\n\nconst getCorrectEncoding = encoding => {\n\tif (encoding === null) {\n\t\treturn 'buffer';\n\t}\n\n\tif (typeof encoding !== 'string') {\n\t\treturn;\n\t}\n\n\tconst lowerEncoding = encoding.toLowerCase();\n\tif (lowerEncoding in ENCODING_ALIASES) {\n\t\treturn ENCODING_ALIASES[lowerEncoding];\n\t}\n\n\tif (ENCODINGS.has(lowerEncoding)) {\n\t\treturn lowerEncoding;\n\t}\n};\n\nconst ENCODING_ALIASES = {\n\t// eslint-disable-next-line unicorn/text-encoding-identifier-case\n\t'utf-8': 'utf8',\n\t'utf-16le': 'utf16le',\n\t'ucs-2': 'utf16le',\n\tucs2: 'utf16le',\n\tbinary: 'latin1',\n};\n\nconst serializeEncoding = encoding => typeof encoding === 'string' ? `\"${encoding}\"` : String(encoding);\n", "import {statSync} from 'node:fs';\nimport path from 'node:path';\nimport process from 'node:process';\nimport {safeNormalizeFileUrl} from './file-url.js';\n\n// Normalize `cwd` option\nexport const normalizeCwd = (cwd = getDefaultCwd()) => {\n\tconst cwdString = safeNormalizeFileUrl(cwd, 'The \"cwd\" option');\n\treturn path.resolve(cwdString);\n};\n\nconst getDefaultCwd = () => {\n\ttry {\n\t\treturn process.cwd();\n\t} catch (error) {\n\t\terror.message = `The current directory does not exist.\\n${error.message}`;\n\t\tthrow error;\n\t}\n};\n\n// When `cwd` option has an invalid value, provide with a better error message\nexport const fixCwdError = (originalMessage, cwd) => {\n\tif (cwd === getDefaultCwd()) {\n\t\treturn originalMessage;\n\t}\n\n\tlet cwdStat;\n\ttry {\n\t\tcwdStat = statSync(cwd);\n\t} catch (error) {\n\t\treturn `The \"cwd\" option is invalid: ${cwd}.\\n${error.message}\\n${originalMessage}`;\n\t}\n\n\tif (!cwdStat.isDirectory()) {\n\t\treturn `The \"cwd\" option is not a directory: ${cwd}.\\n${originalMessage}`;\n\t}\n\n\treturn originalMessage;\n};\n", "import path from 'node:path';\nimport process from 'node:process';\nimport crossSpawn from 'cross-spawn';\nimport {npmRunPathEnv} from 'npm-run-path';\nimport {normalizeForceKillAfterDelay} from '../terminate/kill.js';\nimport {normalizeKillSignal} from '../terminate/signal.js';\nimport {validateCancelSignal} from '../terminate/cancel.js';\nimport {validateGracefulCancel} from '../terminate/graceful.js';\nimport {validateTimeout} from '../terminate/timeout.js';\nimport {handleNodeOption} from '../methods/node.js';\nimport {validateIpcInputOption} from '../ipc/ipc-input.js';\nimport {validateEncoding, BINARY_ENCODINGS} from './encoding-option.js';\nimport {normalizeCwd} from './cwd.js';\nimport {normalizeFileUrl} from './file-url.js';\nimport {normalizeFdSpecificOptions} from './specific.js';\n\n// Normalize the options object, and sometimes also the file paths and arguments.\n// Applies default values, validate allowed options, normalize them.\nexport const normalizeOptions = (filePath, rawArguments, rawOptions) => {\n\trawOptions.cwd = normalizeCwd(rawOptions.cwd);\n\tconst [processedFile, processedArguments, processedOptions] = handleNodeOption(filePath, rawArguments, rawOptions);\n\n\tconst {command: file, args: commandArguments, options: initialOptions} = crossSpawn._parse(processedFile, processedArguments, processedOptions);\n\n\tconst fdOptions = normalizeFdSpecificOptions(initialOptions);\n\tconst options = addDefaultOptions(fdOptions);\n\tvalidateTimeout(options);\n\tvalidateEncoding(options);\n\tvalidateIpcInputOption(options);\n\tvalidateCancelSignal(options);\n\tvalidateGracefulCancel(options);\n\toptions.shell = normalizeFileUrl(options.shell);\n\toptions.env = getEnv(options);\n\toptions.killSignal = normalizeKillSignal(options.killSignal);\n\toptions.forceKillAfterDelay = normalizeForceKillAfterDelay(options.forceKillAfterDelay);\n\toptions.lines = options.lines.map((lines, fdNumber) => lines && !BINARY_ENCODINGS.has(options.encoding) && options.buffer[fdNumber]);\n\n\tif (process.platform === 'win32' && path.basename(file, '.exe') === 'cmd') {\n\t\t// #116\n\t\tcommandArguments.unshift('/q');\n\t}\n\n\treturn {file, commandArguments, options};\n};\n\nconst addDefaultOptions = ({\n\textendEnv = true,\n\tpreferLocal = false,\n\tcwd,\n\tlocalDir: localDirectory = cwd,\n\tencoding = 'utf8',\n\treject = true,\n\tcleanup = true,\n\tall = false,\n\twindowsHide = true,\n\tkillSignal = 'SIGTERM',\n\tforceKillAfterDelay = true,\n\tgracefulCancel = false,\n\tipcInput,\n\tipc = ipcInput !== undefined || gracefulCancel,\n\tserialization = 'advanced',\n\t...options\n}) => ({\n\t...options,\n\textendEnv,\n\tpreferLocal,\n\tcwd,\n\tlocalDirectory,\n\tencoding,\n\treject,\n\tcleanup,\n\tall,\n\twindowsHide,\n\tkillSignal,\n\tforceKillAfterDelay,\n\tgracefulCancel,\n\tipcInput,\n\tipc,\n\tserialization,\n});\n\nconst getEnv = ({env: envOption, extendEnv, preferLocal, node, localDirectory, nodePath}) => {\n\tconst env = extendEnv ? {...process.env, ...envOption} : envOption;\n\n\tif (preferLocal || node) {\n\t\treturn npmRunPathEnv({\n\t\t\tenv,\n\t\t\tcwd: localDirectory,\n\t\t\texecPath: nodePath,\n\t\t\tpreferLocal,\n\t\t\taddExecPath: node,\n\t\t});\n\t}\n\n\treturn env;\n};\n", "// When the `shell` option is set, any command argument is concatenated as a single string by Node.js:\n// https://github.com/nodejs/node/blob/e38ce27f3ca0a65f68a31cedd984cddb927d4002/lib/child_process.js#L614-L624\n// However, since Node 24, it also prints a deprecation warning.\n// To avoid this warning, we perform that same operation before calling `node:child_process`.\n// Shells only understand strings, which is why Node.js performs that concatenation.\n// However, we rely on users splitting command arguments as an array.\n// For example, this allows us to easily detect which arguments are passed.\n// So we do want users to pass array of arguments even with `shell: true`, but we also want to avoid any warning.\nexport const concatenateShell = (file, commandArguments, options) => options.shell && commandArguments.length > 0\n\t? [[file, ...commandArguments].join(' '), [], options]\n\t: [file, commandArguments, options];\n", "export default function stripFinalNewline(input) {\n\tif (typeof input === 'string') {\n\t\treturn stripFinalNewlineString(input);\n\t}\n\n\tif (!(ArrayBuffer.isView(input) && input.BYTES_PER_ELEMENT === 1)) {\n\t\tthrow new Error('Input must be a string or a Uint8Array');\n\t}\n\n\treturn stripFinalNewlineBinary(input);\n}\n\nconst stripFinalNewlineString = input =>\n\tinput.at(-1) === LF\n\t\t? input.slice(0, input.at(-2) === CR ? -2 : -1)\n\t\t: input;\n\nconst stripFinalNewlineBinary = input =>\n\tinput.at(-1) === LF_BINARY\n\t\t? input.subarray(0, input.at(-2) === CR_BINARY ? -2 : -1)\n\t\t: input;\n\nconst LF = '\\n';\nconst LF_BINARY = LF.codePointAt(0);\nconst CR = '\\r';\nconst CR_BINARY = CR.codePointAt(0);\n", "export function isStream(stream, {checkOpen = true} = {}) {\n\treturn stream !== null\n\t\t&& typeof stream === 'object'\n\t\t&& (stream.writable || stream.readable || !checkOpen || (stream.writable === undefined && stream.readable === undefined))\n\t\t&& typeof stream.pipe === 'function';\n}\n\nexport function isWritableStream(stream, {checkOpen = true} = {}) {\n\treturn isStream(stream, {checkOpen})\n\t\t&& (stream.writable || !checkOpen)\n\t\t&& typeof stream.write === 'function'\n\t\t&& typeof stream.end === 'function'\n\t\t&& typeof stream.writable === 'boolean'\n\t\t&& typeof stream.writableObjectMode === 'boolean'\n\t\t&& typeof stream.destroy === 'function'\n\t\t&& typeof stream.destroyed === 'boolean';\n}\n\nexport function isReadableStream(stream, {checkOpen = true} = {}) {\n\treturn isStream(stream, {checkOpen})\n\t\t&& (stream.readable || !checkOpen)\n\t\t&& typeof stream.read === 'function'\n\t\t&& typeof stream.readable === 'boolean'\n\t\t&& typeof stream.readableObjectMode === 'boolean'\n\t\t&& typeof stream.destroy === 'function'\n\t\t&& typeof stream.destroyed === 'boolean';\n}\n\nexport function isDuplexStream(stream, options) {\n\treturn isWritableStream(stream, options)\n\t\t&& isReadableStream(stream, options);\n}\n\nexport function isTransformStream(stream, options) {\n\treturn isDuplexStream(stream, options)\n\t\t&& typeof stream._transform === 'function';\n}\n", "const a = Object.getPrototypeOf(\n  Object.getPrototypeOf(\n    /* istanbul ignore next */\n    async function* () {\n    }\n  ).prototype\n);\nclass c {\n  #t;\n  #n;\n  #r = !1;\n  #e = void 0;\n  constructor(e, t) {\n    this.#t = e, this.#n = t;\n  }\n  next() {\n    const e = () => this.#s();\n    return this.#e = this.#e ? this.#e.then(e, e) : e(), this.#e;\n  }\n  return(e) {\n    const t = () => this.#i(e);\n    return this.#e ? this.#e.then(t, t) : t();\n  }\n  async #s() {\n    if (this.#r)\n      return {\n        done: !0,\n        value: void 0\n      };\n    let e;\n    try {\n      e = await this.#t.read();\n    } catch (t) {\n      throw this.#e = void 0, this.#r = !0, this.#t.releaseLock(), t;\n    }\n    return e.done && (this.#e = void 0, this.#r = !0, this.#t.releaseLock()), e;\n  }\n  async #i(e) {\n    if (this.#r)\n      return {\n        done: !0,\n        value: e\n      };\n    if (this.#r = !0, !this.#n) {\n      const t = this.#t.cancel(e);\n      return this.#t.releaseLock(), await t, {\n        done: !0,\n        value: e\n      };\n    }\n    return this.#t.releaseLock(), {\n      done: !0,\n      value: e\n    };\n  }\n}\nconst n = Symbol();\nfunction i() {\n  return this[n].next();\n}\nObject.defineProperty(i, \"name\", { value: \"next\" });\nfunction o(r) {\n  return this[n].return(r);\n}\nObject.defineProperty(o, \"name\", { value: \"return\" });\nconst u = Object.create(a, {\n  next: {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: i\n  },\n  return: {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: o\n  }\n});\nfunction h({ preventCancel: r = !1 } = {}) {\n  const e = this.getReader(), t = new c(\n    e,\n    r\n  ), s = Object.create(u);\n  return s[n] = t, s;\n}\nexport {\n  h as asyncIterator\n};\n", "function c(n) {\n  const t = a(n);\n  return new ReadableStream(\n    {\n      async pull(e) {\n        const { value: r, done: o } = await t.next();\n        o ? e.close() : e.enqueue(r);\n      },\n      async cancel(e) {\n        if (typeof t.return == \"function\" && typeof await t.return(e) != \"object\")\n          throw new TypeError(\"return() fulfills with a non-object.\");\n        return e;\n      }\n    },\n    new CountQueuingStrategy({\n      highWaterMark: 0\n    })\n  );\n}\nfunction a(n) {\n  let t = n[Symbol.asyncIterator]?.bind(n);\n  if (t === void 0) {\n    const r = n[Symbol.iterator](), o = {\n      [Symbol.iterator]: () => r\n    };\n    t = async function* () {\n      return yield* o;\n    };\n  }\n  return t();\n}\nexport {\n  c as fromAnyIterable\n};\n", "import { asyncIterator as e } from \"./asyncIterator.js\";\nimport { fromAnyIterable as a } from \"./fromAnyIterable.js\";\nexport {\n  e as asyncIterator,\n  a as fromAnyIterable\n};\n", "import {isReadableStream} from 'is-stream';\nimport {asyncIterator} from '@sec-ant/readable-stream/ponyfill';\n\nexport const getAsyncIterable = stream => {\n\tif (isReadableStream(stream, {checkOpen: false}) && nodeImports.on !== undefined) {\n\t\treturn getStreamIterable(stream);\n\t}\n\n\tif (typeof stream?.[Symbol.asyncIterator] === 'function') {\n\t\treturn stream;\n\t}\n\n\t// `ReadableStream[Symbol.asyncIterator]` support is missing in multiple browsers, so we ponyfill it\n\tif (toString.call(stream) === '[object ReadableStream]') {\n\t\treturn asyncIterator.call(stream);\n\t}\n\n\tthrow new TypeError('The first argument must be a Readable, a ReadableStream, or an async iterable.');\n};\n\nconst {toString} = Object.prototype;\n\n// The default iterable for Node.js streams does not allow for multiple readers at once, so we re-implement it\nconst getStreamIterable = async function * (stream) {\n\tconst controller = new AbortController();\n\tconst state = {};\n\thandleStreamEnd(stream, controller, state);\n\n\ttry {\n\t\tfor await (const [chunk] of nodeImports.on(stream, 'data', {signal: controller.signal})) {\n\t\t\tyield chunk;\n\t\t}\n\t} catch (error) {\n\t\t// Stream failure, for example due to `stream.destroy(error)`\n\t\tif (state.error !== undefined) {\n\t\t\tthrow state.error;\n\t\t// `error` event directly emitted on stream\n\t\t} else if (!controller.signal.aborted) {\n\t\t\tthrow error;\n\t\t// Otherwise, stream completed successfully\n\t\t}\n\t\t// The `finally` block also runs when the caller throws, for example due to the `maxBuffer` option\n\t} finally {\n\t\tstream.destroy();\n\t}\n};\n\nconst handleStreamEnd = async (stream, controller, state) => {\n\ttry {\n\t\tawait nodeImports.finished(stream, {\n\t\t\tcleanup: true,\n\t\t\treadable: true,\n\t\t\twritable: false,\n\t\t\terror: false,\n\t\t});\n\t} catch (error) {\n\t\tstate.error = error;\n\t} finally {\n\t\tcontroller.abort();\n\t}\n};\n\n// Loaded by the Node entrypoint, but not by the browser one.\n// This prevents using dynamic imports.\nexport const nodeImports = {};\n", "import {getAsyncIterable} from './stream.js';\n\nexport const getStreamContents = async (stream, {init, convertChunk, getSize, truncateChunk, addChunk, getFinalChunk, finalize}, {maxBuffer = Number.POSITIVE_INFINITY} = {}) => {\n\tconst asyncIterable = getAsyncIterable(stream);\n\n\tconst state = init();\n\tstate.length = 0;\n\n\ttry {\n\t\tfor await (const chunk of asyncIterable) {\n\t\t\tconst chunkType = getChunkType(chunk);\n\t\t\tconst convertedChunk = convertChunk[chunkType](chunk, state);\n\t\t\tappendChunk({\n\t\t\t\tconvertedChunk,\n\t\t\t\tstate,\n\t\t\t\tgetSize,\n\t\t\t\ttruncateChunk,\n\t\t\t\taddChunk,\n\t\t\t\tmaxBuffer,\n\t\t\t});\n\t\t}\n\n\t\tappendFinalChunk({\n\t\t\tstate,\n\t\t\tconvertChunk,\n\t\t\tgetSize,\n\t\t\ttruncateChunk,\n\t\t\taddChunk,\n\t\t\tgetFinalChunk,\n\t\t\tmaxBuffer,\n\t\t});\n\t\treturn finalize(state);\n\t} catch (error) {\n\t\tconst normalizedError = typeof error === 'object' && error !== null ? error : new Error(error);\n\t\tnormalizedError.bufferedData = finalize(state);\n\t\tthrow normalizedError;\n\t}\n};\n\nconst appendFinalChunk = ({state, getSize, truncateChunk, addChunk, getFinalChunk, maxBuffer}) => {\n\tconst convertedChunk = getFinalChunk(state);\n\tif (convertedChunk !== undefined) {\n\t\tappendChunk({\n\t\t\tconvertedChunk,\n\t\t\tstate,\n\t\t\tgetSize,\n\t\t\ttruncateChunk,\n\t\t\taddChunk,\n\t\t\tmaxBuffer,\n\t\t});\n\t}\n};\n\nconst appendChunk = ({convertedChunk, state, getSize, truncateChunk, addChunk, maxBuffer}) => {\n\tconst chunkSize = getSize(convertedChunk);\n\tconst newLength = state.length + chunkSize;\n\n\tif (newLength <= maxBuffer) {\n\t\taddNewChunk(convertedChunk, state, addChunk, newLength);\n\t\treturn;\n\t}\n\n\tconst truncatedChunk = truncateChunk(convertedChunk, maxBuffer - state.length);\n\n\tif (truncatedChunk !== undefined) {\n\t\taddNewChunk(truncatedChunk, state, addChunk, maxBuffer);\n\t}\n\n\tthrow new MaxBufferError();\n};\n\nconst addNewChunk = (convertedChunk, state, addChunk, newLength) => {\n\tstate.contents = addChunk(convertedChunk, state, newLength);\n\tstate.length = newLength;\n};\n\nconst getChunkType = chunk => {\n\tconst typeOfChunk = typeof chunk;\n\n\tif (typeOfChunk === 'string') {\n\t\treturn 'string';\n\t}\n\n\tif (typeOfChunk !== 'object' || chunk === null) {\n\t\treturn 'others';\n\t}\n\n\tif (globalThis.Buffer?.isBuffer(chunk)) {\n\t\treturn 'buffer';\n\t}\n\n\tconst prototypeName = objectToString.call(chunk);\n\n\tif (prototypeName === '[object ArrayBuffer]') {\n\t\treturn 'arrayBuffer';\n\t}\n\n\tif (prototypeName === '[object DataView]') {\n\t\treturn 'dataView';\n\t}\n\n\tif (\n\t\tNumber.isInteger(chunk.byteLength)\n\t\t&& Number.isInteger(chunk.byteOffset)\n\t\t&& objectToString.call(chunk.buffer) === '[object ArrayBuffer]'\n\t) {\n\t\treturn 'typedArray';\n\t}\n\n\treturn 'others';\n};\n\nconst {toString: objectToString} = Object.prototype;\n\nexport class MaxBufferError extends Error {\n\tname = 'MaxBufferError';\n\n\tconstructor() {\n\t\tsuper('maxBuffer exceeded');\n\t}\n}\n", "export const identity = value => value;\n\nexport const noop = () => undefined;\n\nexport const getContentsProperty = ({contents}) => contents;\n\nexport const throwObjectStream = chunk => {\n\tthrow new Error(`Streams in object mode are not supported: ${String(chunk)}`);\n};\n\nexport const getLengthProperty = convertedChunk => convertedChunk.length;\n", "import {getStreamContents} from './contents.js';\nimport {identity, noop, getContentsProperty} from './utils.js';\n\nexport async function getStreamAsArray(stream, options) {\n\treturn getStreamContents(stream, arrayMethods, options);\n}\n\nconst initArray = () => ({contents: []});\n\nconst increment = () => 1;\n\nconst addArrayChunk = (convertedChunk, {contents}) => {\n\tcontents.push(convertedChunk);\n\treturn contents;\n};\n\nconst arrayMethods = {\n\tinit: initArray,\n\tconvertChunk: {\n\t\tstring: identity,\n\t\tbuffer: identity,\n\t\tarrayBuffer: identity,\n\t\tdataView: identity,\n\t\ttypedArray: identity,\n\t\tothers: identity,\n\t},\n\tgetSize: increment,\n\ttruncateChunk: noop,\n\taddChunk: addArrayChunk,\n\tgetFinalChunk: noop,\n\tfinalize: getContentsProperty,\n};\n", "import {getStreamContents} from './contents.js';\nimport {noop, throwObjectStream, getLengthProperty} from './utils.js';\n\nexport async function getStreamAsArrayBuffer(stream, options) {\n\treturn getStreamContents(stream, arrayBufferMethods, options);\n}\n\nconst initArrayBuffer = () => ({contents: new ArrayBuffer(0)});\n\nconst useTextEncoder = chunk => textEncoder.encode(chunk);\nconst textEncoder = new TextEncoder();\n\nconst useUint8Array = chunk => new Uint8Array(chunk);\n\nconst useUint8ArrayWithOffset = chunk => new Uint8Array(chunk.buffer, chunk.byteOffset, chunk.byteLength);\n\nconst truncateArrayBufferChunk = (convertedChunk, chunkSize) => convertedChunk.slice(0, chunkSize);\n\n// `contents` is an increasingly growing `Uint8Array`.\nconst addArrayBufferChunk = (convertedChunk, {contents, length: previousLength}, length) => {\n\tconst newContents = hasArrayBufferResize() ? resizeArrayBuffer(contents, length) : resizeArrayBufferSlow(contents, length);\n\tnew Uint8Array(newContents).set(convertedChunk, previousLength);\n\treturn newContents;\n};\n\n// Without `ArrayBuffer.resize()`, `contents` size is always a power of 2.\n// This means its last bytes are zeroes (not stream data), which need to be\n// trimmed at the end with `ArrayBuffer.slice()`.\nconst resizeArrayBufferSlow = (contents, length) => {\n\tif (length <= contents.byteLength) {\n\t\treturn contents;\n\t}\n\n\tconst arrayBuffer = new ArrayBuffer(getNewContentsLength(length));\n\tnew Uint8Array(arrayBuffer).set(new Uint8Array(contents), 0);\n\treturn arrayBuffer;\n};\n\n// With `ArrayBuffer.resize()`, `contents` size matches exactly the size of\n// the stream data. It does not include extraneous zeroes to trim at the end.\n// The underlying `ArrayBuffer` does allocate a number of bytes that is a power\n// of 2, but those bytes are only visible after calling `ArrayBuffer.resize()`.\nconst resizeArrayBuffer = (contents, length) => {\n\tif (length <= contents.maxByteLength) {\n\t\tcontents.resize(length);\n\t\treturn contents;\n\t}\n\n\tconst arrayBuffer = new ArrayBuffer(length, {maxByteLength: getNewContentsLength(length)});\n\tnew Uint8Array(arrayBuffer).set(new Uint8Array(contents), 0);\n\treturn arrayBuffer;\n};\n\n// Retrieve the closest `length` that is both >= and a power of 2\nconst getNewContentsLength = length => SCALE_FACTOR ** Math.ceil(Math.log(length) / Math.log(SCALE_FACTOR));\n\nconst SCALE_FACTOR = 2;\n\nconst finalizeArrayBuffer = ({contents, length}) => hasArrayBufferResize() ? contents : contents.slice(0, length);\n\n// `ArrayBuffer.slice()` is slow. When `ArrayBuffer.resize()` is available\n// (Node >=20.0.0, Safari >=16.4 and Chrome), we can use it instead.\n// eslint-disable-next-line no-warning-comments\n// TODO: remove after dropping support for Node 20.\n// eslint-disable-next-line no-warning-comments\n// TODO: use `ArrayBuffer.transferToFixedLength()` instead once it is available\nconst hasArrayBufferResize = () => 'resize' in ArrayBuffer.prototype;\n\nconst arrayBufferMethods = {\n\tinit: initArrayBuffer,\n\tconvertChunk: {\n\t\tstring: useTextEncoder,\n\t\tbuffer: useUint8Array,\n\t\tarrayBuffer: useUint8Array,\n\t\tdataView: useUint8ArrayWithOffset,\n\t\ttypedArray: useUint8ArrayWithOffset,\n\t\tothers: throwObjectStream,\n\t},\n\tgetSize: getLengthProperty,\n\ttruncateChunk: truncateArrayBufferChunk,\n\taddChunk: addArrayBufferChunk,\n\tgetFinalChunk: noop,\n\tfinalize: finalizeArrayBuffer,\n};\n", "import {getStreamContents} from './contents.js';\nimport {\n\tidentity,\n\tgetContentsProperty,\n\tthrowObjectStream,\n\tgetLengthProperty,\n} from './utils.js';\n\nexport async function getStreamAsString(stream, options) {\n\treturn getStreamContents(stream, stringMethods, options);\n}\n\nconst initString = () => ({contents: '', textDecoder: new TextDecoder()});\n\nconst useTextDecoder = (chunk, {textDecoder}) => textDecoder.decode(chunk, {stream: true});\n\nconst addStringChunk = (convertedChunk, {contents}) => contents + convertedChunk;\n\nconst truncateStringChunk = (convertedChunk, chunkSize) => convertedChunk.slice(0, chunkSize);\n\nconst getFinalStringChunk = ({textDecoder}) => {\n\tconst finalChunk = textDecoder.decode();\n\treturn finalChunk === '' ? undefined : finalChunk;\n};\n\nconst stringMethods = {\n\tinit: initString,\n\tconvertChunk: {\n\t\tstring: identity,\n\t\tbuffer: useTextDecoder,\n\t\tarrayBuffer: useTextDecoder,\n\t\tdataView: useTextDecoder,\n\t\ttypedArray: useTextDecoder,\n\t\tothers: throwObjectStream,\n\t},\n\tgetSize: getLengthProperty,\n\ttruncateChunk: truncateStringChunk,\n\taddChunk: addStringChunk,\n\tgetFinalChunk: getFinalStringChunk,\n\tfinalize: getContentsProperty,\n};\n", "export {getStreamAsArray} from './array.js';\nexport {getStreamAsArrayBuffer} from './array-buffer.js';\nexport {getStreamAsBuffer} from './buffer.js';\nexport {getStreamAsString as default} from './string.js';\nexport {MaxBufferError} from './contents.js';\n", "import {on} from 'node:events';\nimport {finished} from 'node:stream/promises';\nimport {nodeImports} from './stream.js';\n\nObject.assign(nodeImports, {on, finished});\n\nexport {\n\tdefault,\n\tgetStreamAsArray,\n\tgetStreamAsArrayBuffer,\n\tgetStreamAsBuffer,\n\tMaxBufferError,\n} from './exports.js';\n", "import {MaxBufferError} from 'get-stream';\nimport {getStreamName} from '../utils/standard-stream.js';\nimport {getFdSpecificValue} from '../arguments/specific.js';\n\n// When the `maxBuffer` option is hit, a MaxBufferError is thrown.\n// The stream is aborted, then specific information is kept for the error message.\nexport const handleMaxBuffer = ({error, stream, readableObjectMode, lines, encoding, fdNumber}) => {\n\tif (!(error instanceof MaxBufferError)) {\n\t\tthrow error;\n\t}\n\n\tif (fdNumber === 'all') {\n\t\treturn error;\n\t}\n\n\tconst unit = getMaxBufferUnit(readableObjectMode, lines, encoding);\n\terror.maxBufferInfo = {fdNumber, unit};\n\tstream.destroy();\n\tthrow error;\n};\n\nconst getMaxBufferUnit = (readableObjectMode, lines, encoding) => {\n\tif (readableObjectMode) {\n\t\treturn 'objects';\n\t}\n\n\tif (lines) {\n\t\treturn 'lines';\n\t}\n\n\tif (encoding === 'buffer') {\n\t\treturn 'bytes';\n\t}\n\n\treturn 'characters';\n};\n\n// Check the `maxBuffer` option with `result.ipcOutput`\nexport const checkIpcMaxBuffer = (subprocess, ipcOutput, maxBuffer) => {\n\tif (ipcOutput.length !== maxBuffer) {\n\t\treturn;\n\t}\n\n\tconst error = new MaxBufferError();\n\terror.maxBufferInfo = {fdNumber: 'ipc'};\n\tthrow error;\n};\n\n// Error message when `maxBuffer` is hit\nexport const getMaxBufferMessage = (error, maxBuffer) => {\n\tconst {streamName, threshold, unit} = getMaxBufferInfo(error, maxBuffer);\n\treturn `Command's ${streamName} was larger than ${threshold} ${unit}`;\n};\n\nconst getMaxBufferInfo = (error, maxBuffer) => {\n\tif (error?.maxBufferInfo === undefined) {\n\t\treturn {streamName: 'output', threshold: maxBuffer[1], unit: 'bytes'};\n\t}\n\n\tconst {maxBufferInfo: {fdNumber, unit}} = error;\n\tdelete error.maxBufferInfo;\n\n\tconst threshold = getFdSpecificValue(maxBuffer, fdNumber);\n\tif (fdNumber === 'ipc') {\n\t\treturn {streamName: 'IPC output', threshold, unit: 'messages'};\n\t}\n\n\treturn {streamName: getStreamName(fdNumber), threshold, unit};\n};\n\n// The only way to apply `maxBuffer` with `spawnSync()` is to use the native `maxBuffer` option Node.js provides.\n// However, this has multiple limitations, and cannot behave the exact same way as the async behavior.\n// When the `maxBuffer` is hit, a `ENOBUFS` error is thrown.\nexport const isMaxBufferSync = (resultError, output, maxBuffer) => resultError?.code === 'ENOBUFS'\n\t&& output !== null\n\t&& output.some(result => result !== null && result.length > getMaxBufferSync(maxBuffer));\n\n// When `maxBuffer` is hit, ensure the result is truncated\nexport const truncateMaxBufferSync = (result, isMaxBuffer, maxBuffer) => {\n\tif (!isMaxBuffer) {\n\t\treturn result;\n\t}\n\n\tconst maxBufferValue = getMaxBufferSync(maxBuffer);\n\treturn result.length > maxBufferValue ? result.slice(0, maxBufferValue) : result;\n};\n\n// `spawnSync()` does not allow differentiating `maxBuffer` per file descriptor, so we always use `stdout`\nexport const getMaxBufferSync = ([, stdoutMaxBuffer]) => stdoutMaxBuffer;\n", "import {inspect} from 'node:util';\nimport stripFinalNewline from 'strip-final-newline';\nimport {isUint8Array, uint8ArrayToString} from '../utils/uint-array.js';\nimport {fixCwdError} from '../arguments/cwd.js';\nimport {escapeLines} from '../arguments/escape.js';\nimport {getMaxBufferMessage} from '../io/max-buffer.js';\nimport {getSignalDescription} from '../terminate/signal.js';\nimport {DiscardedError, isExecaError} from './final-error.js';\n\n// Computes `error.message`, `error.shortMessage` and `error.originalMessage`\nexport const createMessages = ({\n\tstdio,\n\tall,\n\tipcOutput,\n\toriginalError,\n\tsignal,\n\tsignalDescription,\n\texitCode,\n\tescapedCommand,\n\ttimedOut,\n\tisCanceled,\n\tisGracefullyCanceled,\n\tisMaxBuffer,\n\tisForcefullyTerminated,\n\tforceKillAfterDelay,\n\tkillSignal,\n\tmaxBuffer,\n\ttimeout,\n\tcwd,\n}) => {\n\tconst errorCode = originalError?.code;\n\tconst prefix = getErrorPrefix({\n\t\toriginalError,\n\t\ttimedOut,\n\t\ttimeout,\n\t\tisMaxBuffer,\n\t\tmaxBuffer,\n\t\terrorCode,\n\t\tsignal,\n\t\tsignalDescription,\n\t\texitCode,\n\t\tisCanceled,\n\t\tisGracefullyCanceled,\n\t\tisForcefullyTerminated,\n\t\tforceKillAfterDelay,\n\t\tkillSignal,\n\t});\n\tconst originalMessage = getOriginalMessage(originalError, cwd);\n\tconst suffix = originalMessage === undefined ? '' : `\\n${originalMessage}`;\n\tconst shortMessage = `${prefix}: ${escapedCommand}${suffix}`;\n\tconst messageStdio = all === undefined ? [stdio[2], stdio[1]] : [all];\n\tconst message = [\n\t\tshortMessage,\n\t\t...messageStdio,\n\t\t...stdio.slice(3),\n\t\tipcOutput.map(ipcMessage => serializeIpcMessage(ipcMessage)).join('\\n'),\n\t]\n\t\t.map(messagePart => escapeLines(stripFinalNewline(serializeMessagePart(messagePart))))\n\t\t.filter(Boolean)\n\t\t.join('\\n\\n');\n\treturn {originalMessage, shortMessage, message};\n};\n\nconst getErrorPrefix = ({\n\toriginalError,\n\ttimedOut,\n\ttimeout,\n\tisMaxBuffer,\n\tmaxBuffer,\n\terrorCode,\n\tsignal,\n\tsignalDescription,\n\texitCode,\n\tisCanceled,\n\tisGracefullyCanceled,\n\tisForcefullyTerminated,\n\tforceKillAfterDelay,\n\tkillSignal,\n}) => {\n\tconst forcefulSuffix = getForcefulSuffix(isForcefullyTerminated, forceKillAfterDelay);\n\n\tif (timedOut) {\n\t\treturn `Command timed out after ${timeout} milliseconds${forcefulSuffix}`;\n\t}\n\n\tif (isGracefullyCanceled) {\n\t\tif (signal === undefined) {\n\t\t\treturn `Command was gracefully canceled with exit code ${exitCode}`;\n\t\t}\n\n\t\treturn isForcefullyTerminated\n\t\t\t? `Command was gracefully canceled${forcefulSuffix}`\n\t\t\t: `Command was gracefully canceled with ${signal} (${signalDescription})`;\n\t}\n\n\tif (isCanceled) {\n\t\treturn `Command was canceled${forcefulSuffix}`;\n\t}\n\n\tif (isMaxBuffer) {\n\t\treturn `${getMaxBufferMessage(originalError, maxBuffer)}${forcefulSuffix}`;\n\t}\n\n\tif (errorCode !== undefined) {\n\t\treturn `Command failed with ${errorCode}${forcefulSuffix}`;\n\t}\n\n\tif (isForcefullyTerminated) {\n\t\treturn `Command was killed with ${killSignal} (${getSignalDescription(killSignal)})${forcefulSuffix}`;\n\t}\n\n\tif (signal !== undefined) {\n\t\treturn `Command was killed with ${signal} (${signalDescription})`;\n\t}\n\n\tif (exitCode !== undefined) {\n\t\treturn `Command failed with exit code ${exitCode}`;\n\t}\n\n\treturn 'Command failed';\n};\n\nconst getForcefulSuffix = (isForcefullyTerminated, forceKillAfterDelay) => isForcefullyTerminated\n\t? ` and was forcefully terminated after ${forceKillAfterDelay} milliseconds`\n\t: '';\n\nconst getOriginalMessage = (originalError, cwd) => {\n\tif (originalError instanceof DiscardedError) {\n\t\treturn;\n\t}\n\n\tconst originalMessage = isExecaError(originalError)\n\t\t? originalError.originalMessage\n\t\t: String(originalError?.message ?? originalError);\n\tconst escapedOriginalMessage = escapeLines(fixCwdError(originalMessage, cwd));\n\treturn escapedOriginalMessage === '' ? undefined : escapedOriginalMessage;\n};\n\nconst serializeIpcMessage = ipcMessage => typeof ipcMessage === 'string'\n\t? ipcMessage\n\t: inspect(ipcMessage);\n\nconst serializeMessagePart = messagePart => Array.isArray(messagePart)\n\t? messagePart.map(messageItem => stripFinalNewline(serializeMessageItem(messageItem))).filter(Boolean).join('\\n')\n\t: serializeMessageItem(messagePart);\n\nconst serializeMessageItem = messageItem => {\n\tif (typeof messageItem === 'string') {\n\t\treturn messageItem;\n\t}\n\n\tif (isUint8Array(messageItem)) {\n\t\treturn uint8ArrayToString(messageItem);\n\t}\n\n\treturn '';\n};\n", "import {getSignalDescription} from '../terminate/signal.js';\nimport {getDurationMs} from './duration.js';\nimport {getFinalError} from './final-error.js';\nimport {createMessages} from './message.js';\n\n// Object returned on subprocess success\nexport const makeSuccessResult = ({\n\tcommand,\n\tescapedCommand,\n\tstdio,\n\tall,\n\tipcOutput,\n\toptions: {cwd},\n\tstartTime,\n}) => omitUndefinedProperties({\n\tcommand,\n\tescapedCommand,\n\tcwd,\n\tdurationMs: getDurationMs(startTime),\n\tfailed: false,\n\ttimedOut: false,\n\tisCanceled: false,\n\tisGracefullyCanceled: false,\n\tisTerminated: false,\n\tisMaxBuffer: false,\n\tisForcefullyTerminated: false,\n\texitCode: 0,\n\tstdout: stdio[1],\n\tstderr: stdio[2],\n\tall,\n\tstdio,\n\tipcOutput,\n\tpipedFrom: [],\n});\n\n// Object returned on subprocess failure before spawning\nexport const makeEarlyError = ({\n\terror,\n\tcommand,\n\tescapedCommand,\n\tfileDescriptors,\n\toptions,\n\tstartTime,\n\tisSync,\n}) => makeError({\n\terror,\n\tcommand,\n\tescapedCommand,\n\tstartTime,\n\ttimedOut: false,\n\tisCanceled: false,\n\tisGracefullyCanceled: false,\n\tisMaxBuffer: false,\n\tisForcefullyTerminated: false,\n\tstdio: Array.from({length: fileDescriptors.length}),\n\tipcOutput: [],\n\toptions,\n\tisSync,\n});\n\n// Object returned on subprocess failure\nexport const makeError = ({\n\terror: originalError,\n\tcommand,\n\tescapedCommand,\n\tstartTime,\n\ttimedOut,\n\tisCanceled,\n\tisGracefullyCanceled,\n\tisMaxBuffer,\n\tisForcefullyTerminated,\n\texitCode: rawExitCode,\n\tsignal: rawSignal,\n\tstdio,\n\tall,\n\tipcOutput,\n\toptions: {\n\t\ttimeoutDuration,\n\t\ttimeout = timeoutDuration,\n\t\tforceKillAfterDelay,\n\t\tkillSignal,\n\t\tcwd,\n\t\tmaxBuffer,\n\t},\n\tisSync,\n}) => {\n\tconst {exitCode, signal, signalDescription} = normalizeExitPayload(rawExitCode, rawSignal);\n\tconst {originalMessage, shortMessage, message} = createMessages({\n\t\tstdio,\n\t\tall,\n\t\tipcOutput,\n\t\toriginalError,\n\t\tsignal,\n\t\tsignalDescription,\n\t\texitCode,\n\t\tescapedCommand,\n\t\ttimedOut,\n\t\tisCanceled,\n\t\tisGracefullyCanceled,\n\t\tisMaxBuffer,\n\t\tisForcefullyTerminated,\n\t\tforceKillAfterDelay,\n\t\tkillSignal,\n\t\tmaxBuffer,\n\t\ttimeout,\n\t\tcwd,\n\t});\n\tconst error = getFinalError(originalError, message, isSync);\n\tObject.assign(error, getErrorProperties({\n\t\terror,\n\t\tcommand,\n\t\tescapedCommand,\n\t\tstartTime,\n\t\ttimedOut,\n\t\tisCanceled,\n\t\tisGracefullyCanceled,\n\t\tisMaxBuffer,\n\t\tisForcefullyTerminated,\n\t\texitCode,\n\t\tsignal,\n\t\tsignalDescription,\n\t\tstdio,\n\t\tall,\n\t\tipcOutput,\n\t\tcwd,\n\t\toriginalMessage,\n\t\tshortMessage,\n\t}));\n\treturn error;\n};\n\nconst getErrorProperties = ({\n\terror,\n\tcommand,\n\tescapedCommand,\n\tstartTime,\n\ttimedOut,\n\tisCanceled,\n\tisGracefullyCanceled,\n\tisMaxBuffer,\n\tisForcefullyTerminated,\n\texitCode,\n\tsignal,\n\tsignalDescription,\n\tstdio,\n\tall,\n\tipcOutput,\n\tcwd,\n\toriginalMessage,\n\tshortMessage,\n}) => omitUndefinedProperties({\n\tshortMessage,\n\toriginalMessage,\n\tcommand,\n\tescapedCommand,\n\tcwd,\n\tdurationMs: getDurationMs(startTime),\n\tfailed: true,\n\ttimedOut,\n\tisCanceled,\n\tisGracefullyCanceled,\n\tisTerminated: signal !== undefined,\n\tisMaxBuffer,\n\tisForcefullyTerminated,\n\texitCode,\n\tsignal,\n\tsignalDescription,\n\tcode: error.cause?.code,\n\tstdout: stdio[1],\n\tstderr: stdio[2],\n\tall,\n\tstdio,\n\tipcOutput,\n\tpipedFrom: [],\n});\n\nconst omitUndefinedProperties = result => Object.fromEntries(Object.entries(result).filter(([, value]) => value !== undefined));\n\n// `signal` and `exitCode` emitted on `subprocess.on('exit')` event can be `null`.\n// We normalize them to `undefined`\nconst normalizeExitPayload = (rawExitCode, rawSignal) => {\n\tconst exitCode = rawExitCode === null ? undefined : rawExitCode;\n\tconst signal = rawSignal === null ? undefined : rawSignal;\n\tconst signalDescription = signal === undefined ? undefined : getSignalDescription(rawSignal);\n\treturn {exitCode, signal, signalDescription};\n};\n", "const toZeroIfInfinity = value => Number.isFinite(value) ? value : 0;\n\nfunction parseNumber(milliseconds) {\n\treturn {\n\t\tdays: Math.trunc(milliseconds / 86_400_000),\n\t\thours: Math.trunc(milliseconds / 3_600_000 % 24),\n\t\tminutes: Math.trunc(milliseconds / 60_000 % 60),\n\t\tseconds: Math.trunc(milliseconds / 1000 % 60),\n\t\tmilliseconds: Math.trunc(milliseconds % 1000),\n\t\tmicroseconds: Math.trunc(toZeroIfInfinity(milliseconds * 1000) % 1000),\n\t\tnanoseconds: Math.trunc(toZeroIfInfinity(milliseconds * 1e6) % 1000),\n\t};\n}\n\nfunction parseBigint(milliseconds) {\n\treturn {\n\t\tdays: milliseconds / 86_400_000n,\n\t\thours: milliseconds / 3_600_000n % 24n,\n\t\tminutes: milliseconds / 60_000n % 60n,\n\t\tseconds: milliseconds / 1000n % 60n,\n\t\tmilliseconds: milliseconds % 1000n,\n\t\tmicroseconds: 0n,\n\t\tnanoseconds: 0n,\n\t};\n}\n\nexport default function parseMilliseconds(milliseconds) {\n\tswitch (typeof milliseconds) {\n\t\tcase 'number': {\n\t\t\tif (Number.isFinite(milliseconds)) {\n\t\t\t\treturn parseNumber(milliseconds);\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\n\t\tcase 'bigint': {\n\t\t\treturn parseBigint(milliseconds);\n\t\t}\n\n\t\t// No default\n\t}\n\n\tthrow new TypeError('Expected a finite number or bigint');\n}\n", "import parseMilliseconds from 'parse-ms';\n\nconst isZero = value => value === 0 || value === 0n;\nconst pluralize = (word, count) => (count === 1 || count === 1n) ? word : `${word}s`;\n\nconst SECOND_ROUNDING_EPSILON = 0.000_000_1;\nconst ONE_DAY_IN_MILLISECONDS = 24n * 60n * 60n * 1000n;\n\nexport default function prettyMilliseconds(milliseconds, options) {\n\tconst isBigInt = typeof milliseconds === 'bigint';\n\tif (!isBigInt && !Number.isFinite(milliseconds)) {\n\t\tthrow new TypeError('Expected a finite number or bigint');\n\t}\n\n\toptions = {...options};\n\n\tconst sign = milliseconds < 0 ? '-' : '';\n\tmilliseconds = milliseconds < 0 ? -milliseconds : milliseconds; // Cannot use `Math.abs()` because of BigInt support.\n\n\tif (options.colonNotation) {\n\t\toptions.compact = false;\n\t\toptions.formatSubMilliseconds = false;\n\t\toptions.separateMilliseconds = false;\n\t\toptions.verbose = false;\n\t}\n\n\tif (options.compact) {\n\t\toptions.unitCount = 1;\n\t\toptions.secondsDecimalDigits = 0;\n\t\toptions.millisecondsDecimalDigits = 0;\n\t}\n\n\tlet result = [];\n\n\tconst floorDecimals = (value, decimalDigits) => {\n\t\tconst flooredInterimValue = Math.floor((value * (10 ** decimalDigits)) + SECOND_ROUNDING_EPSILON);\n\t\tconst flooredValue = Math.round(flooredInterimValue) / (10 ** decimalDigits);\n\t\treturn flooredValue.toFixed(decimalDigits);\n\t};\n\n\tconst add = (value, long, short, valueString) => {\n\t\tif (\n\t\t\t(result.length === 0 || !options.colonNotation)\n\t\t\t&& isZero(value)\n\t\t\t&& !(options.colonNotation && short === 'm')) {\n\t\t\treturn;\n\t\t}\n\n\t\tvalueString ??= String(value);\n\t\tif (options.colonNotation) {\n\t\t\tconst wholeDigits = valueString.includes('.') ? valueString.split('.')[0].length : valueString.length;\n\t\t\tconst minLength = result.length > 0 ? 2 : 1;\n\t\t\tvalueString = '0'.repeat(Math.max(0, minLength - wholeDigits)) + valueString;\n\t\t} else {\n\t\t\tvalueString += options.verbose ? ' ' + pluralize(long, value) : short;\n\t\t}\n\n\t\tresult.push(valueString);\n\t};\n\n\tconst parsed = parseMilliseconds(milliseconds);\n\tconst days = BigInt(parsed.days);\n\n\tif (options.hideYearAndDays) {\n\t\tadd((BigInt(days) * 24n) + BigInt(parsed.hours), 'hour', 'h');\n\t} else {\n\t\tif (options.hideYear) {\n\t\t\tadd(days, 'day', 'd');\n\t\t} else {\n\t\t\tadd(days / 365n, 'year', 'y');\n\t\t\tadd(days % 365n, 'day', 'd');\n\t\t}\n\n\t\tadd(Number(parsed.hours), 'hour', 'h');\n\t}\n\n\tadd(Number(parsed.minutes), 'minute', 'm');\n\n\tif (!options.hideSeconds) {\n\t\tif (\n\t\t\toptions.separateMilliseconds\n\t\t\t|| options.formatSubMilliseconds\n\t\t\t|| (!options.colonNotation && milliseconds < 1000 && !options.subSecondsAsDecimals)\n\t\t) {\n\t\t\tconst seconds = Number(parsed.seconds);\n\t\t\tconst milliseconds = Number(parsed.milliseconds);\n\t\t\tconst microseconds = Number(parsed.microseconds);\n\t\t\tconst nanoseconds = Number(parsed.nanoseconds);\n\n\t\t\tadd(seconds, 'second', 's');\n\n\t\t\tif (options.formatSubMilliseconds) {\n\t\t\t\tadd(milliseconds, 'millisecond', 'ms');\n\t\t\t\tadd(microseconds, 'microsecond', '\u00B5s');\n\t\t\t\tadd(nanoseconds, 'nanosecond', 'ns');\n\t\t\t} else {\n\t\t\t\tconst millisecondsAndBelow\n\t\t\t\t\t= milliseconds\n\t\t\t\t\t+ (microseconds / 1000)\n\t\t\t\t\t+ (nanoseconds / 1e6);\n\n\t\t\t\tconst millisecondsDecimalDigits\n\t\t\t\t\t= typeof options.millisecondsDecimalDigits === 'number'\n\t\t\t\t\t\t? options.millisecondsDecimalDigits\n\t\t\t\t\t\t: 0;\n\n\t\t\t\tconst roundedMilliseconds = millisecondsAndBelow >= 1\n\t\t\t\t\t? Math.round(millisecondsAndBelow)\n\t\t\t\t\t: Math.ceil(millisecondsAndBelow);\n\n\t\t\t\tconst millisecondsString = millisecondsDecimalDigits\n\t\t\t\t\t? millisecondsAndBelow.toFixed(millisecondsDecimalDigits)\n\t\t\t\t\t: roundedMilliseconds;\n\n\t\t\t\tadd(\n\t\t\t\t\tNumber.parseFloat(millisecondsString),\n\t\t\t\t\t'millisecond',\n\t\t\t\t\t'ms',\n\t\t\t\t\tmillisecondsString,\n\t\t\t\t);\n\t\t\t}\n\t\t} else {\n\t\t\tconst seconds = (\n\t\t\t\t(isBigInt ? Number(milliseconds % ONE_DAY_IN_MILLISECONDS) : milliseconds)\n\t\t\t\t/ 1000\n\t\t\t) % 60;\n\t\t\tconst secondsDecimalDigits\n\t\t\t\t= typeof options.secondsDecimalDigits === 'number'\n\t\t\t\t\t? options.secondsDecimalDigits\n\t\t\t\t\t: 1;\n\t\t\tconst secondsFixed = floorDecimals(seconds, secondsDecimalDigits);\n\t\t\tconst secondsString = options.keepDecimalsOnWholeSeconds\n\t\t\t\t? secondsFixed\n\t\t\t\t: secondsFixed.replace(/\\.0+$/, '');\n\t\t\tadd(Number.parseFloat(secondsString), 'second', 's', secondsString);\n\t\t}\n\t}\n\n\tif (result.length === 0) {\n\t\treturn sign + '0' + (options.verbose ? ' milliseconds' : 'ms');\n\t}\n\n\tconst separator = options.colonNotation ? ':' : ' ';\n\tif (typeof options.unitCount === 'number') {\n\t\tresult = result.slice(0, Math.max(options.unitCount, 1));\n\t}\n\n\treturn sign + result.join(separator);\n}\n", "import {verboseLog} from './log.js';\n\n// When `verbose` is `short|full|custom`, print each command's error when it fails\nexport const logError = (result, verboseInfo) => {\n\tif (result.failed) {\n\t\tverboseLog({\n\t\t\ttype: 'error',\n\t\t\tverboseMessage: result.shortMessage,\n\t\t\tverboseInfo,\n\t\t\tresult,\n\t\t});\n\t}\n};\n", "import prettyMs from 'pretty-ms';\nimport {isVerbose} from './values.js';\nimport {verboseLog} from './log.js';\nimport {logError} from './error.js';\n\n// When `verbose` is `short|full|custom`, print each command's completion, duration and error\nexport const logResult = (result, verboseInfo) => {\n\tif (!isVerbose(verboseInfo)) {\n\t\treturn;\n\t}\n\n\tlogError(result, verboseInfo);\n\tlogDuration(result, verboseInfo);\n};\n\nconst logDuration = (result, verboseInfo) => {\n\tconst verboseMessage = `(done in ${prettyMs(result.durationMs)})`;\n\tverboseLog({\n\t\ttype: 'duration',\n\t\tverboseMessage,\n\t\tverboseInfo,\n\t\tresult,\n\t});\n};\n", "import {logResult} from '../verbose/complete.js';\n\n// Applies the `reject` option.\n// Also print the final log line with `verbose`.\nexport const handleResult = (result, verboseInfo, {reject}) => {\n\tlogResult(result, verboseInfo);\n\n\tif (result.failed && reject) {\n\t\tthrow result;\n\t}\n\n\treturn result;\n};\n", "import {isStream as isNodeStream, isDuplexStream} from 'is-stream';\nimport isPlainObj from 'is-plain-obj';\nimport {isUint8Array} from '../utils/uint-array.js';\n\n// The `stdin`/`stdout`/`stderr` option can be of many types. This detects it.\nexport const getStdioItemType = (value, optionName) => {\n\tif (isAsyncGenerator(value)) {\n\t\treturn 'asyncGenerator';\n\t}\n\n\tif (isSyncGenerator(value)) {\n\t\treturn 'generator';\n\t}\n\n\tif (isUrl(value)) {\n\t\treturn 'fileUrl';\n\t}\n\n\tif (isFilePathObject(value)) {\n\t\treturn 'filePath';\n\t}\n\n\tif (isWebStream(value)) {\n\t\treturn 'webStream';\n\t}\n\n\tif (isNodeStream(value, {checkOpen: false})) {\n\t\treturn 'native';\n\t}\n\n\tif (isUint8Array(value)) {\n\t\treturn 'uint8Array';\n\t}\n\n\tif (isAsyncIterableObject(value)) {\n\t\treturn 'asyncIterable';\n\t}\n\n\tif (isIterableObject(value)) {\n\t\treturn 'iterable';\n\t}\n\n\tif (isTransformStream(value)) {\n\t\treturn getTransformStreamType({transform: value}, optionName);\n\t}\n\n\tif (isTransformOptions(value)) {\n\t\treturn getTransformObjectType(value, optionName);\n\t}\n\n\treturn 'native';\n};\n\nconst getTransformObjectType = (value, optionName) => {\n\tif (isDuplexStream(value.transform, {checkOpen: false})) {\n\t\treturn getDuplexType(value, optionName);\n\t}\n\n\tif (isTransformStream(value.transform)) {\n\t\treturn getTransformStreamType(value, optionName);\n\t}\n\n\treturn getGeneratorObjectType(value, optionName);\n};\n\nconst getDuplexType = (value, optionName) => {\n\tvalidateNonGeneratorType(value, optionName, 'Duplex stream');\n\treturn 'duplex';\n};\n\nconst getTransformStreamType = (value, optionName) => {\n\tvalidateNonGeneratorType(value, optionName, 'web TransformStream');\n\treturn 'webTransform';\n};\n\nconst validateNonGeneratorType = ({final, binary, objectMode}, optionName, typeName) => {\n\tcheckUndefinedOption(final, `${optionName}.final`, typeName);\n\tcheckUndefinedOption(binary, `${optionName}.binary`, typeName);\n\tcheckBooleanOption(objectMode, `${optionName}.objectMode`);\n};\n\nconst checkUndefinedOption = (value, optionName, typeName) => {\n\tif (value !== undefined) {\n\t\tthrow new TypeError(`The \\`${optionName}\\` option can only be defined when using a generator, not a ${typeName}.`);\n\t}\n};\n\nconst getGeneratorObjectType = ({transform, final, binary, objectMode}, optionName) => {\n\tif (transform !== undefined && !isGenerator(transform)) {\n\t\tthrow new TypeError(`The \\`${optionName}.transform\\` option must be a generator, a Duplex stream or a web TransformStream.`);\n\t}\n\n\tif (isDuplexStream(final, {checkOpen: false})) {\n\t\tthrow new TypeError(`The \\`${optionName}.final\\` option must not be a Duplex stream.`);\n\t}\n\n\tif (isTransformStream(final)) {\n\t\tthrow new TypeError(`The \\`${optionName}.final\\` option must not be a web TransformStream.`);\n\t}\n\n\tif (final !== undefined && !isGenerator(final)) {\n\t\tthrow new TypeError(`The \\`${optionName}.final\\` option must be a generator.`);\n\t}\n\n\tcheckBooleanOption(binary, `${optionName}.binary`);\n\tcheckBooleanOption(objectMode, `${optionName}.objectMode`);\n\n\treturn isAsyncGenerator(transform) || isAsyncGenerator(final) ? 'asyncGenerator' : 'generator';\n};\n\nconst checkBooleanOption = (value, optionName) => {\n\tif (value !== undefined && typeof value !== 'boolean') {\n\t\tthrow new TypeError(`The \\`${optionName}\\` option must use a boolean.`);\n\t}\n};\n\nconst isGenerator = value => isAsyncGenerator(value) || isSyncGenerator(value);\nexport const isAsyncGenerator = value => Object.prototype.toString.call(value) === '[object AsyncGeneratorFunction]';\nconst isSyncGenerator = value => Object.prototype.toString.call(value) === '[object GeneratorFunction]';\nconst isTransformOptions = value => isPlainObj(value)\n\t&& (value.transform !== undefined || value.final !== undefined);\n\nexport const isUrl = value => Object.prototype.toString.call(value) === '[object URL]';\nexport const isRegularUrl = value => isUrl(value) && value.protocol !== 'file:';\n\nconst isFilePathObject = value => isPlainObj(value)\n\t&& Object.keys(value).length > 0\n\t&& Object.keys(value).every(key => FILE_PATH_KEYS.has(key))\n\t&& isFilePathString(value.file);\nconst FILE_PATH_KEYS = new Set(['file', 'append']);\nexport const isFilePathString = file => typeof file === 'string';\n\nexport const isUnknownStdioString = (type, value) => type === 'native'\n\t&& typeof value === 'string'\n\t&& !KNOWN_STDIO_STRINGS.has(value);\nconst KNOWN_STDIO_STRINGS = new Set(['ipc', 'ignore', 'inherit', 'overlapped', 'pipe']);\n\nconst isReadableStream = value => Object.prototype.toString.call(value) === '[object ReadableStream]';\nexport const isWritableStream = value => Object.prototype.toString.call(value) === '[object WritableStream]';\nconst isWebStream = value => isReadableStream(value) || isWritableStream(value);\nconst isTransformStream = value => isReadableStream(value?.readable) && isWritableStream(value?.writable);\n\nconst isAsyncIterableObject = value => isObject(value) && typeof value[Symbol.asyncIterator] === 'function';\nconst isIterableObject = value => isObject(value) && typeof value[Symbol.iterator] === 'function';\nconst isObject = value => typeof value === 'object' && value !== null;\n\n// Types which modify `subprocess.std*`\nexport const TRANSFORM_TYPES = new Set(['generator', 'asyncGenerator', 'duplex', 'webTransform']);\n// Types which write to a file or a file descriptor\nexport const FILE_TYPES = new Set(['fileUrl', 'filePath', 'fileNumber']);\n// When two file descriptors of this type share the same target, we need to do some special logic\nexport const SPECIAL_DUPLICATE_TYPES_SYNC = new Set(['fileUrl', 'filePath']);\nexport const SPECIAL_DUPLICATE_TYPES = new Set([...SPECIAL_DUPLICATE_TYPES_SYNC, 'webStream', 'nodeStream']);\n// Do not allow two file descriptors of this type sharing the same target\nexport const FORBID_DUPLICATE_TYPES = new Set(['webTransform', 'duplex']);\n\n// Convert types to human-friendly strings for error messages\nexport const TYPE_TO_MESSAGE = {\n\tgenerator: 'a generator',\n\tasyncGenerator: 'an async generator',\n\tfileUrl: 'a file URL',\n\tfilePath: 'a file path string',\n\tfileNumber: 'a file descriptor number',\n\twebStream: 'a web stream',\n\tnodeStream: 'a Node.js stream',\n\twebTransform: 'a web TransformStream',\n\tduplex: 'a Duplex stream',\n\tnative: 'any value',\n\titerable: 'an iterable',\n\tasyncIterable: 'an async iterable',\n\tstring: 'a string',\n\tuint8Array: 'a Uint8Array',\n};\n", "import {TRANSFORM_TYPES} from '../stdio/type.js';\n\n/*\nRetrieve the `objectMode`s of a single transform.\n`objectMode` determines the return value's type, i.e. the `readableObjectMode`.\nThe chunk argument's type is based on the previous generator's return value, i.e. the `writableObjectMode` is based on the previous `readableObjectMode`.\nThe last input's generator is read by `subprocess.stdin` which:\n- should not be in `objectMode` for performance reasons.\n- can only be strings, Buffers and Uint8Arrays.\nTherefore its `readableObjectMode` must be `false`.\nThe same applies to the first output's generator's `writableObjectMode`.\n*/\nexport const getTransformObjectModes = (objectMode, index, newTransforms, direction) => direction === 'output'\n\t? getOutputObjectModes(objectMode, index, newTransforms)\n\t: getInputObjectModes(objectMode, index, newTransforms);\n\nconst getOutputObjectModes = (objectMode, index, newTransforms) => {\n\tconst writableObjectMode = index !== 0 && newTransforms[index - 1].value.readableObjectMode;\n\tconst readableObjectMode = objectMode ?? writableObjectMode;\n\treturn {writableObjectMode, readableObjectMode};\n};\n\nconst getInputObjectModes = (objectMode, index, newTransforms) => {\n\tconst writableObjectMode = index === 0\n\t\t? objectMode === true\n\t\t: newTransforms[index - 1].value.readableObjectMode;\n\tconst readableObjectMode = index !== newTransforms.length - 1 && (objectMode ?? writableObjectMode);\n\treturn {writableObjectMode, readableObjectMode};\n};\n\n// Retrieve the `objectMode` of a file descriptor, e.g. `stdout` or `stderr`\nexport const getFdObjectMode = (stdioItems, direction) => {\n\tconst lastTransform = stdioItems.findLast(({type}) => TRANSFORM_TYPES.has(type));\n\tif (lastTransform === undefined) {\n\t\treturn false;\n\t}\n\n\treturn direction === 'input'\n\t\t? lastTransform.value.writableObjectMode\n\t\t: lastTransform.value.readableObjectMode;\n};\n", "import isPlainObj from 'is-plain-obj';\nimport {BINARY_ENCODINGS} from '../arguments/encoding-option.js';\nimport {TRANSFORM_TYPES} from '../stdio/type.js';\nimport {getTransformObjectModes} from './object-mode.js';\n\n// Transforms generators/duplex/TransformStream can have multiple shapes.\n// This normalizes it and applies default values.\nexport const normalizeTransforms = (stdioItems, optionName, direction, options) => [\n\t...stdioItems.filter(({type}) => !TRANSFORM_TYPES.has(type)),\n\t...getTransforms(stdioItems, optionName, direction, options),\n];\n\nconst getTransforms = (stdioItems, optionName, direction, {encoding}) => {\n\tconst transforms = stdioItems.filter(({type}) => TRANSFORM_TYPES.has(type));\n\tconst newTransforms = Array.from({length: transforms.length});\n\n\tfor (const [index, stdioItem] of Object.entries(transforms)) {\n\t\tnewTransforms[index] = normalizeTransform({\n\t\t\tstdioItem,\n\t\t\tindex: Number(index),\n\t\t\tnewTransforms,\n\t\t\toptionName,\n\t\t\tdirection,\n\t\t\tencoding,\n\t\t});\n\t}\n\n\treturn sortTransforms(newTransforms, direction);\n};\n\nconst normalizeTransform = ({stdioItem, stdioItem: {type}, index, newTransforms, optionName, direction, encoding}) => {\n\tif (type === 'duplex') {\n\t\treturn normalizeDuplex({stdioItem, optionName});\n\t}\n\n\tif (type === 'webTransform') {\n\t\treturn normalizeTransformStream({\n\t\t\tstdioItem,\n\t\t\tindex,\n\t\t\tnewTransforms,\n\t\t\tdirection,\n\t\t});\n\t}\n\n\treturn normalizeGenerator({\n\t\tstdioItem,\n\t\tindex,\n\t\tnewTransforms,\n\t\tdirection,\n\t\tencoding,\n\t});\n};\n\nconst normalizeDuplex = ({\n\tstdioItem,\n\tstdioItem: {\n\t\tvalue: {\n\t\t\ttransform,\n\t\t\ttransform: {writableObjectMode, readableObjectMode},\n\t\t\tobjectMode = readableObjectMode,\n\t\t},\n\t},\n\toptionName,\n}) => {\n\tif (objectMode && !readableObjectMode) {\n\t\tthrow new TypeError(`The \\`${optionName}.objectMode\\` option can only be \\`true\\` if \\`new Duplex({objectMode: true})\\` is used.`);\n\t}\n\n\tif (!objectMode && readableObjectMode) {\n\t\tthrow new TypeError(`The \\`${optionName}.objectMode\\` option cannot be \\`false\\` if \\`new Duplex({objectMode: true})\\` is used.`);\n\t}\n\n\treturn {\n\t\t...stdioItem,\n\t\tvalue: {transform, writableObjectMode, readableObjectMode},\n\t};\n};\n\nconst normalizeTransformStream = ({stdioItem, stdioItem: {value}, index, newTransforms, direction}) => {\n\tconst {transform, objectMode} = isPlainObj(value) ? value : {transform: value};\n\tconst {writableObjectMode, readableObjectMode} = getTransformObjectModes(objectMode, index, newTransforms, direction);\n\treturn ({\n\t\t...stdioItem,\n\t\tvalue: {transform, writableObjectMode, readableObjectMode},\n\t});\n};\n\nconst normalizeGenerator = ({stdioItem, stdioItem: {value}, index, newTransforms, direction, encoding}) => {\n\tconst {\n\t\ttransform,\n\t\tfinal,\n\t\tbinary: binaryOption = false,\n\t\tpreserveNewlines = false,\n\t\tobjectMode,\n\t} = isPlainObj(value) ? value : {transform: value};\n\tconst binary = binaryOption || BINARY_ENCODINGS.has(encoding);\n\tconst {writableObjectMode, readableObjectMode} = getTransformObjectModes(objectMode, index, newTransforms, direction);\n\treturn {\n\t\t...stdioItem,\n\t\tvalue: {\n\t\t\ttransform,\n\t\t\tfinal,\n\t\t\tbinary,\n\t\t\tpreserveNewlines,\n\t\t\twritableObjectMode,\n\t\t\treadableObjectMode,\n\t\t},\n\t};\n};\n\nconst sortTransforms = (newTransforms, direction) => direction === 'input' ? newTransforms.reverse() : newTransforms;\n", "import process from 'node:process';\nimport {\n\tisStream as isNodeStream,\n\tisReadableStream as isNodeReadableStream,\n\tisWritableStream as isNodeWritableStream,\n} from 'is-stream';\nimport {isWritableStream} from './type.js';\n\n// For `stdio[fdNumber]` beyond stdin/stdout/stderr, we need to guess whether the value passed is intended for inputs or outputs.\n// This allows us to know whether to pipe _into_ or _from_ the stream.\n// When `stdio[fdNumber]` is a single value, this guess is fairly straightforward.\n// However, when it is an array instead, we also need to make sure the different values are not incompatible with each other.\nexport const getStreamDirection = (stdioItems, fdNumber, optionName) => {\n\tconst directions = stdioItems.map(stdioItem => getStdioItemDirection(stdioItem, fdNumber));\n\n\tif (directions.includes('input') && directions.includes('output')) {\n\t\tthrow new TypeError(`The \\`${optionName}\\` option must not be an array of both readable and writable values.`);\n\t}\n\n\treturn directions.find(Boolean) ?? DEFAULT_DIRECTION;\n};\n\nconst getStdioItemDirection = ({type, value}, fdNumber) => KNOWN_DIRECTIONS[fdNumber] ?? guessStreamDirection[type](value);\n\n// `stdin`/`stdout`/`stderr` have a known direction\nconst KNOWN_DIRECTIONS = ['input', 'output', 'output'];\n\nconst anyDirection = () => undefined;\nconst alwaysInput = () => 'input';\n\n// `string` can only be added through the `input` option, i.e. does not need to be handled here\nconst guessStreamDirection = {\n\tgenerator: anyDirection,\n\tasyncGenerator: anyDirection,\n\tfileUrl: anyDirection,\n\tfilePath: anyDirection,\n\titerable: alwaysInput,\n\tasyncIterable: alwaysInput,\n\tuint8Array: alwaysInput,\n\twebStream: value => isWritableStream(value) ? 'output' : 'input',\n\tnodeStream(value) {\n\t\tif (!isNodeReadableStream(value, {checkOpen: false})) {\n\t\t\treturn 'output';\n\t\t}\n\n\t\treturn isNodeWritableStream(value, {checkOpen: false}) ? undefined : 'input';\n\t},\n\twebTransform: anyDirection,\n\tduplex: anyDirection,\n\tnative(value) {\n\t\tconst standardStreamDirection = getStandardStreamDirection(value);\n\t\tif (standardStreamDirection !== undefined) {\n\t\t\treturn standardStreamDirection;\n\t\t}\n\n\t\tif (isNodeStream(value, {checkOpen: false})) {\n\t\t\treturn guessStreamDirection.nodeStream(value);\n\t\t}\n\t},\n};\n\nconst getStandardStreamDirection = value => {\n\tif ([0, process.stdin].includes(value)) {\n\t\treturn 'input';\n\t}\n\n\tif ([1, 2, process.stdout, process.stderr].includes(value)) {\n\t\treturn 'output';\n\t}\n};\n\n// When ambiguous, we initially keep the direction as `undefined`.\n// This allows arrays of `stdio` values to resolve the ambiguity.\n// For example, `stdio[3]: DuplexStream` is ambiguous, but `stdio[3]: [DuplexStream, WritableStream]` is not.\n// When the ambiguity remains, we default to `output` since it is the most common use case for additional file descriptors.\nconst DEFAULT_DIRECTION = 'output';\n", "// The `ipc` option adds an `ipc` item to the `stdio` option\nexport const normalizeIpcStdioArray = (stdioArray, ipc) => ipc && !stdioArray.includes('ipc')\n\t? [...stdioArray, 'ipc']\n\t: stdioArray;\n", "import {STANDARD_STREAMS_ALIASES} from '../utils/standard-stream.js';\nimport {normalizeIpcStdioArray} from '../ipc/array.js';\nimport {isFullVerbose} from '../verbose/values.js';\n\n// Add support for `stdin`/`stdout`/`stderr` as an alias for `stdio`.\n// Also normalize the `stdio` option.\nexport const normalizeStdioOption = ({stdio, ipc, buffer, ...options}, verboseInfo, isSync) => {\n\tconst stdioArray = getStdioArray(stdio, options).map((stdioOption, fdNumber) => addDefaultValue(stdioOption, fdNumber));\n\treturn isSync\n\t\t? normalizeStdioSync(stdioArray, buffer, verboseInfo)\n\t\t: normalizeIpcStdioArray(stdioArray, ipc);\n};\n\nconst getStdioArray = (stdio, options) => {\n\tif (stdio === undefined) {\n\t\treturn STANDARD_STREAMS_ALIASES.map(alias => options[alias]);\n\t}\n\n\tif (hasAlias(options)) {\n\t\tthrow new Error(`It's not possible to provide \\`stdio\\` in combination with one of ${STANDARD_STREAMS_ALIASES.map(alias => `\\`${alias}\\``).join(', ')}`);\n\t}\n\n\tif (typeof stdio === 'string') {\n\t\treturn [stdio, stdio, stdio];\n\t}\n\n\tif (!Array.isArray(stdio)) {\n\t\tthrow new TypeError(`Expected \\`stdio\\` to be of type \\`string\\` or \\`Array\\`, got \\`${typeof stdio}\\``);\n\t}\n\n\tconst length = Math.max(stdio.length, STANDARD_STREAMS_ALIASES.length);\n\treturn Array.from({length}, (_, fdNumber) => stdio[fdNumber]);\n};\n\nconst hasAlias = options => STANDARD_STREAMS_ALIASES.some(alias => options[alias] !== undefined);\n\nconst addDefaultValue = (stdioOption, fdNumber) => {\n\tif (Array.isArray(stdioOption)) {\n\t\treturn stdioOption.map(item => addDefaultValue(item, fdNumber));\n\t}\n\n\tif (stdioOption === null || stdioOption === undefined) {\n\t\treturn fdNumber >= STANDARD_STREAMS_ALIASES.length ? 'ignore' : 'pipe';\n\t}\n\n\treturn stdioOption;\n};\n\n// Using `buffer: false` with synchronous methods implies `stdout`/`stderr`: `ignore`.\n// Unless the output is needed, e.g. due to `verbose: 'full'` or to redirecting to a file.\nconst normalizeStdioSync = (stdioArray, buffer, verboseInfo) => stdioArray.map((stdioOption, fdNumber) =>\n\t!buffer[fdNumber]\n\t&& fdNumber !== 0\n\t&& !isFullVerbose(verboseInfo, fdNumber)\n\t&& isOutputPipeOnly(stdioOption)\n\t\t? 'ignore'\n\t\t: stdioOption);\n\nconst isOutputPipeOnly = stdioOption => stdioOption === 'pipe'\n\t|| (Array.isArray(stdioOption) && stdioOption.every(item => item === 'pipe'));\n", "import {readFileSync} from 'node:fs';\nimport tty from 'node:tty';\nimport {isStream as isNodeStream} from 'is-stream';\nimport {STANDARD_STREAMS} from '../utils/standard-stream.js';\nimport {bufferToUint8Array} from '../utils/uint-array.js';\nimport {serializeOptionValue} from '../arguments/fd-options.js';\n\n// When we use multiple `stdio` values for the same streams, we pass 'pipe' to `child_process.spawn()`.\n// We then emulate the piping done by core Node.js.\n// To do so, we transform the following values:\n//  - Node.js streams are marked as `type: nodeStream`\n//  - 'inherit' becomes `process.stdin|stdout|stderr`\n//  - any file descriptor integer becomes `process.stdio[fdNumber]`\n// All of the above transformations tell Execa to perform manual piping.\nexport const handleNativeStream = ({stdioItem, stdioItem: {type}, isStdioArray, fdNumber, direction, isSync}) => {\n\tif (!isStdioArray || type !== 'native') {\n\t\treturn stdioItem;\n\t}\n\n\treturn isSync\n\t\t? handleNativeStreamSync({stdioItem, fdNumber, direction})\n\t\t: handleNativeStreamAsync({stdioItem, fdNumber});\n};\n\n// Synchronous methods use a different logic.\n// 'inherit', file descriptors and process.std* are handled by readFileSync()/writeFileSync().\nconst handleNativeStreamSync = ({stdioItem, stdioItem: {value, optionName}, fdNumber, direction}) => {\n\tconst targetFd = getTargetFd({\n\t\tvalue,\n\t\toptionName,\n\t\tfdNumber,\n\t\tdirection,\n\t});\n\tif (targetFd !== undefined) {\n\t\treturn targetFd;\n\t}\n\n\tif (isNodeStream(value, {checkOpen: false})) {\n\t\tthrow new TypeError(`The \\`${optionName}: Stream\\` option cannot both be an array and include a stream with synchronous methods.`);\n\t}\n\n\treturn stdioItem;\n};\n\nconst getTargetFd = ({value, optionName, fdNumber, direction}) => {\n\tconst targetFdNumber = getTargetFdNumber(value, fdNumber);\n\tif (targetFdNumber === undefined) {\n\t\treturn;\n\t}\n\n\tif (direction === 'output') {\n\t\treturn {type: 'fileNumber', value: targetFdNumber, optionName};\n\t}\n\n\tif (tty.isatty(targetFdNumber)) {\n\t\tthrow new TypeError(`The \\`${optionName}: ${serializeOptionValue(value)}\\` option is invalid: it cannot be a TTY with synchronous methods.`);\n\t}\n\n\treturn {type: 'uint8Array', value: bufferToUint8Array(readFileSync(targetFdNumber)), optionName};\n};\n\nconst getTargetFdNumber = (value, fdNumber) => {\n\tif (value === 'inherit') {\n\t\treturn fdNumber;\n\t}\n\n\tif (typeof value === 'number') {\n\t\treturn value;\n\t}\n\n\tconst standardStreamIndex = STANDARD_STREAMS.indexOf(value);\n\tif (standardStreamIndex !== -1) {\n\t\treturn standardStreamIndex;\n\t}\n};\n\nconst handleNativeStreamAsync = ({stdioItem, stdioItem: {value, optionName}, fdNumber}) => {\n\tif (value === 'inherit') {\n\t\treturn {type: 'nodeStream', value: getStandardStream(fdNumber, value, optionName), optionName};\n\t}\n\n\tif (typeof value === 'number') {\n\t\treturn {type: 'nodeStream', value: getStandardStream(value, value, optionName), optionName};\n\t}\n\n\tif (isNodeStream(value, {checkOpen: false})) {\n\t\treturn {type: 'nodeStream', value, optionName};\n\t}\n\n\treturn stdioItem;\n};\n\n// Node.js does not allow to easily retrieve file descriptors beyond stdin/stdout/stderr as streams.\n//  - `fs.createReadStream()`/`fs.createWriteStream()` with the `fd` option do not work with character devices that use blocking reads/writes (such as interactive TTYs).\n//  - Using a TCP `Socket` would work but be rather complex to implement.\n// Since this is an edge case, we simply throw an error message.\n// See https://github.com/sindresorhus/execa/pull/643#discussion_r1435905707\nconst getStandardStream = (fdNumber, value, optionName) => {\n\tconst standardStream = STANDARD_STREAMS[fdNumber];\n\n\tif (standardStream === undefined) {\n\t\tthrow new TypeError(`The \\`${optionName}: ${value}\\` option is invalid: no such standard stream.`);\n\t}\n\n\treturn standardStream;\n};\n", "import {isReadableStream} from 'is-stream';\nimport {isUint8Array} from '../utils/uint-array.js';\nimport {isUrl, isFilePathString} from './type.js';\n\n// Append the `stdin` option with the `input` and `inputFile` options\nexport const handleInputOptions = ({input, inputFile}, fdNumber) => fdNumber === 0\n\t? [\n\t\t...handleInputOption(input),\n\t\t...handleInputFileOption(inputFile),\n\t]\n\t: [];\n\nconst handleInputOption = input => input === undefined ? [] : [{\n\ttype: getInputType(input),\n\tvalue: input,\n\toptionName: 'input',\n}];\n\nconst getInputType = input => {\n\tif (isReadableStream(input, {checkOpen: false})) {\n\t\treturn 'nodeStream';\n\t}\n\n\tif (typeof input === 'string') {\n\t\treturn 'string';\n\t}\n\n\tif (isUint8Array(input)) {\n\t\treturn 'uint8Array';\n\t}\n\n\tthrow new Error('The `input` option must be a string, a Uint8Array or a Node.js Readable stream.');\n};\n\nconst handleInputFileOption = inputFile => inputFile === undefined ? [] : [{\n\t...getInputFileType(inputFile),\n\toptionName: 'inputFile',\n}];\n\nconst getInputFileType = inputFile => {\n\tif (isUrl(inputFile)) {\n\t\treturn {type: 'fileUrl', value: inputFile};\n\t}\n\n\tif (isFilePathString(inputFile)) {\n\t\treturn {type: 'filePath', value: {file: inputFile}};\n\t}\n\n\tthrow new Error('The `inputFile` option must be a file path string or a file URL.');\n};\n", "import {\n\tSPECIAL_DUPLICATE_TYPES_SYNC,\n\tSPECIAL_DUPLICATE_TYPES,\n\tFORBID_DUPLICATE_TYPES,\n\tTYPE_TO_MESSAGE,\n} from './type.js';\n\n// Duplicates in the same file descriptor is most likely an error.\n// However, this can be useful with generators.\nexport const filterDuplicates = stdioItems => stdioItems.filter((stdioItemOne, indexOne) =>\n\tstdioItems.every((stdioItemTwo, indexTwo) => stdioItemOne.value !== stdioItemTwo.value\n\t\t|| indexOne >= indexTwo\n\t\t|| stdioItemOne.type === 'generator'\n\t\t|| stdioItemOne.type === 'asyncGenerator'));\n\n// Check if two file descriptors are sharing the same target.\n// For example `{stdout: {file: './output.txt'}, stderr: {file: './output.txt'}}`.\nexport const getDuplicateStream = ({stdioItem: {type, value, optionName}, direction, fileDescriptors, isSync}) => {\n\tconst otherStdioItems = getOtherStdioItems(fileDescriptors, type);\n\tif (otherStdioItems.length === 0) {\n\t\treturn;\n\t}\n\n\tif (isSync) {\n\t\tvalidateDuplicateStreamSync({\n\t\t\totherStdioItems,\n\t\t\ttype,\n\t\t\tvalue,\n\t\t\toptionName,\n\t\t\tdirection,\n\t\t});\n\t\treturn;\n\t}\n\n\tif (SPECIAL_DUPLICATE_TYPES.has(type)) {\n\t\treturn getDuplicateStreamInstance({\n\t\t\totherStdioItems,\n\t\t\ttype,\n\t\t\tvalue,\n\t\t\toptionName,\n\t\t\tdirection,\n\t\t});\n\t}\n\n\tif (FORBID_DUPLICATE_TYPES.has(type)) {\n\t\tvalidateDuplicateTransform({\n\t\t\totherStdioItems,\n\t\t\ttype,\n\t\t\tvalue,\n\t\t\toptionName,\n\t\t});\n\t}\n};\n\n// Values shared by multiple file descriptors\nconst getOtherStdioItems = (fileDescriptors, type) => fileDescriptors\n\t.flatMap(({direction, stdioItems}) => stdioItems\n\t\t.filter(stdioItem => stdioItem.type === type)\n\t\t.map((stdioItem => ({...stdioItem, direction}))));\n\n// With `execaSync()`, do not allow setting a file path both in input and output\nconst validateDuplicateStreamSync = ({otherStdioItems, type, value, optionName, direction}) => {\n\tif (SPECIAL_DUPLICATE_TYPES_SYNC.has(type)) {\n\t\tgetDuplicateStreamInstance({\n\t\t\totherStdioItems,\n\t\t\ttype,\n\t\t\tvalue,\n\t\t\toptionName,\n\t\t\tdirection,\n\t\t});\n\t}\n};\n\n// When two file descriptors share the file or stream, we need to re-use the same underlying stream.\n// Otherwise, the stream would be closed twice when piping ends.\n// This is only an issue with output file descriptors.\n// This is not a problem with generator functions since those create a new instance for each file descriptor.\n// We also forbid input and output file descriptors sharing the same file or stream, since that does not make sense.\nconst getDuplicateStreamInstance = ({otherStdioItems, type, value, optionName, direction}) => {\n\tconst duplicateStdioItems = otherStdioItems.filter(stdioItem => hasSameValue(stdioItem, value));\n\tif (duplicateStdioItems.length === 0) {\n\t\treturn;\n\t}\n\n\tconst differentStdioItem = duplicateStdioItems.find(stdioItem => stdioItem.direction !== direction);\n\tthrowOnDuplicateStream(differentStdioItem, optionName, type);\n\n\treturn direction === 'output' ? duplicateStdioItems[0].stream : undefined;\n};\n\nconst hasSameValue = ({type, value}, secondValue) => {\n\tif (type === 'filePath') {\n\t\treturn value.file === secondValue.file;\n\t}\n\n\tif (type === 'fileUrl') {\n\t\treturn value.href === secondValue.href;\n\t}\n\n\treturn value === secondValue;\n};\n\n// We do not allow two file descriptors to share the same Duplex or TransformStream.\n// This is because those are set directly to `subprocess.std*`.\n// For example, this could result in `subprocess.stdout` and `subprocess.stderr` being the same value.\n// This means reading from either would get data from both stdout and stderr.\nconst validateDuplicateTransform = ({otherStdioItems, type, value, optionName}) => {\n\tconst duplicateStdioItem = otherStdioItems.find(({value: {transform}}) => transform === value.transform);\n\tthrowOnDuplicateStream(duplicateStdioItem, optionName, type);\n};\n\nconst throwOnDuplicateStream = (stdioItem, optionName, type) => {\n\tif (stdioItem !== undefined) {\n\t\tthrow new TypeError(`The \\`${stdioItem.optionName}\\` and \\`${optionName}\\` options must not target ${TYPE_TO_MESSAGE[type]} that is the same.`);\n\t}\n};\n", "import {getStreamName, isStandardStream} from '../utils/standard-stream.js';\nimport {normalizeTransforms} from '../transform/normalize.js';\nimport {getFdObjectMode} from '../transform/object-mode.js';\nimport {\n\tgetStdioItemType,\n\tisRegularUrl,\n\tisUnknownStdioString,\n\tFILE_TYPES,\n} from './type.js';\nimport {getStreamDirection} from './direction.js';\nimport {normalizeStdioOption} from './stdio-option.js';\nimport {handleNativeStream} from './native.js';\nimport {handleInputOptions} from './input-option.js';\nimport {filterDuplicates, getDuplicateStream} from './duplicate.js';\n\n// Handle `input`, `inputFile`, `stdin`, `stdout` and `stderr` options, before spawning, in async/sync mode\n// They are converted into an array of `fileDescriptors`.\n// Each `fileDescriptor` is normalized, validated and contains all information necessary for further handling.\nexport const handleStdio = (addProperties, options, verboseInfo, isSync) => {\n\tconst stdio = normalizeStdioOption(options, verboseInfo, isSync);\n\tconst initialFileDescriptors = stdio.map((stdioOption, fdNumber) => getFileDescriptor({\n\t\tstdioOption,\n\t\tfdNumber,\n\t\toptions,\n\t\tisSync,\n\t}));\n\tconst fileDescriptors = getFinalFileDescriptors({\n\t\tinitialFileDescriptors,\n\t\taddProperties,\n\t\toptions,\n\t\tisSync,\n\t});\n\toptions.stdio = fileDescriptors.map(({stdioItems}) => forwardStdio(stdioItems));\n\treturn fileDescriptors;\n};\n\nconst getFileDescriptor = ({stdioOption, fdNumber, options, isSync}) => {\n\tconst optionName = getStreamName(fdNumber);\n\tconst {stdioItems: initialStdioItems, isStdioArray} = initializeStdioItems({\n\t\tstdioOption,\n\t\tfdNumber,\n\t\toptions,\n\t\toptionName,\n\t});\n\tconst direction = getStreamDirection(initialStdioItems, fdNumber, optionName);\n\tconst stdioItems = initialStdioItems.map(stdioItem => handleNativeStream({\n\t\tstdioItem,\n\t\tisStdioArray,\n\t\tfdNumber,\n\t\tdirection,\n\t\tisSync,\n\t}));\n\tconst normalizedStdioItems = normalizeTransforms(stdioItems, optionName, direction, options);\n\tconst objectMode = getFdObjectMode(normalizedStdioItems, direction);\n\tvalidateFileObjectMode(normalizedStdioItems, objectMode);\n\treturn {direction, objectMode, stdioItems: normalizedStdioItems};\n};\n\n// We make sure passing an array with a single item behaves the same as passing that item without an array.\n// This is what users would expect.\n// For example, `stdout: ['ignore']` behaves the same as `stdout: 'ignore'`.\nconst initializeStdioItems = ({stdioOption, fdNumber, options, optionName}) => {\n\tconst values = Array.isArray(stdioOption) ? stdioOption : [stdioOption];\n\tconst initialStdioItems = [\n\t\t...values.map(value => initializeStdioItem(value, optionName)),\n\t\t...handleInputOptions(options, fdNumber),\n\t];\n\n\tconst stdioItems = filterDuplicates(initialStdioItems);\n\tconst isStdioArray = stdioItems.length > 1;\n\tvalidateStdioArray(stdioItems, isStdioArray, optionName);\n\tvalidateStreams(stdioItems);\n\treturn {stdioItems, isStdioArray};\n};\n\nconst initializeStdioItem = (value, optionName) => ({\n\ttype: getStdioItemType(value, optionName),\n\tvalue,\n\toptionName,\n});\n\nconst validateStdioArray = (stdioItems, isStdioArray, optionName) => {\n\tif (stdioItems.length === 0) {\n\t\tthrow new TypeError(`The \\`${optionName}\\` option must not be an empty array.`);\n\t}\n\n\tif (!isStdioArray) {\n\t\treturn;\n\t}\n\n\tfor (const {value, optionName} of stdioItems) {\n\t\tif (INVALID_STDIO_ARRAY_OPTIONS.has(value)) {\n\t\t\tthrow new Error(`The \\`${optionName}\\` option must not include \\`${value}\\`.`);\n\t\t}\n\t}\n};\n\n// Using those `stdio` values together with others for the same stream does not make sense, so we make it fail.\n// However, we do allow it if the array has a single item.\nconst INVALID_STDIO_ARRAY_OPTIONS = new Set(['ignore', 'ipc']);\n\nconst validateStreams = stdioItems => {\n\tfor (const stdioItem of stdioItems) {\n\t\tvalidateFileStdio(stdioItem);\n\t}\n};\n\nconst validateFileStdio = ({type, value, optionName}) => {\n\tif (isRegularUrl(value)) {\n\t\tthrow new TypeError(`The \\`${optionName}: URL\\` option must use the \\`file:\\` scheme.\nFor example, you can use the \\`pathToFileURL()\\` method of the \\`url\\` core module.`);\n\t}\n\n\tif (isUnknownStdioString(type, value)) {\n\t\tthrow new TypeError(`The \\`${optionName}: { file: '...' }\\` option must be used instead of \\`${optionName}: '...'\\`.`);\n\t}\n};\n\nconst validateFileObjectMode = (stdioItems, objectMode) => {\n\tif (!objectMode) {\n\t\treturn;\n\t}\n\n\tconst fileStdioItem = stdioItems.find(({type}) => FILE_TYPES.has(type));\n\tif (fileStdioItem !== undefined) {\n\t\tthrow new TypeError(`The \\`${fileStdioItem.optionName}\\` option cannot use both files and transforms in objectMode.`);\n\t}\n};\n\n// Some `stdio` values require Execa to create streams.\n// For example, file paths create file read/write streams.\n// Those transformations are specified in `addProperties`, which is both direction-specific and type-specific.\nconst getFinalFileDescriptors = ({initialFileDescriptors, addProperties, options, isSync}) => {\n\tconst fileDescriptors = [];\n\n\ttry {\n\t\tfor (const fileDescriptor of initialFileDescriptors) {\n\t\t\tfileDescriptors.push(getFinalFileDescriptor({\n\t\t\t\tfileDescriptor,\n\t\t\t\tfileDescriptors,\n\t\t\t\taddProperties,\n\t\t\t\toptions,\n\t\t\t\tisSync,\n\t\t\t}));\n\t\t}\n\n\t\treturn fileDescriptors;\n\t} catch (error) {\n\t\tcleanupCustomStreams(fileDescriptors);\n\t\tthrow error;\n\t}\n};\n\nconst getFinalFileDescriptor = ({\n\tfileDescriptor: {direction, objectMode, stdioItems},\n\tfileDescriptors,\n\taddProperties,\n\toptions,\n\tisSync,\n}) => {\n\tconst finalStdioItems = stdioItems.map(stdioItem => addStreamProperties({\n\t\tstdioItem,\n\t\taddProperties,\n\t\tdirection,\n\t\toptions,\n\t\tfileDescriptors,\n\t\tisSync,\n\t}));\n\treturn {direction, objectMode, stdioItems: finalStdioItems};\n};\n\nconst addStreamProperties = ({stdioItem, addProperties, direction, options, fileDescriptors, isSync}) => {\n\tconst duplicateStream = getDuplicateStream({\n\t\tstdioItem,\n\t\tdirection,\n\t\tfileDescriptors,\n\t\tisSync,\n\t});\n\n\tif (duplicateStream !== undefined) {\n\t\treturn {...stdioItem, stream: duplicateStream};\n\t}\n\n\treturn {\n\t\t...stdioItem,\n\t\t...addProperties[direction][stdioItem.type](stdioItem, options),\n\t};\n};\n\n// The stream error handling is performed by the piping logic above, which cannot be performed before subprocess spawning.\n// If the subprocess spawning fails (e.g. due to an invalid command), the streams need to be manually destroyed.\n// We need to create those streams before subprocess spawning, in case their creation fails, e.g. when passing an invalid generator as argument.\n// Like this, an exception would be thrown, which would prevent spawning a subprocess.\nexport const cleanupCustomStreams = fileDescriptors => {\n\tfor (const {stdioItems} of fileDescriptors) {\n\t\tfor (const {stream} of stdioItems) {\n\t\t\tif (stream !== undefined && !isStandardStream(stream)) {\n\t\t\t\tstream.destroy();\n\t\t\t}\n\t\t}\n\t}\n};\n\n// When the `std*: Iterable | WebStream | URL | filePath`, `input` or `inputFile` option is used, we pipe to `subprocess.std*`.\n// When the `std*: Array` option is used, we emulate some of the native values ('inherit', Node.js stream and file descriptor integer). To do so, we also need to pipe to `subprocess.std*`.\n// Therefore the `std*` options must be either `pipe` or `overlapped`. Other values do not set `subprocess.std*`.\nconst forwardStdio = stdioItems => {\n\tif (stdioItems.length > 1) {\n\t\treturn stdioItems.some(({value}) => value === 'overlapped') ? 'overlapped' : 'pipe';\n\t}\n\n\tconst [{type, value}] = stdioItems;\n\treturn type === 'native' ? value : 'pipe';\n};\n", "import {readFileSync} from 'node:fs';\nimport {bufferToUint8Array} from '../utils/uint-array.js';\nimport {handleStdio} from './handle.js';\nimport {TYPE_TO_MESSAGE} from './type.js';\n\n// Normalize `input`, `inputFile`, `stdin`, `stdout` and `stderr` options, before spawning, in sync mode\nexport const handleStdioSync = (options, verboseInfo) => handleStdio(addPropertiesSync, options, verboseInfo, true);\n\nconst forbiddenIfSync = ({type, optionName}) => {\n\tthrowInvalidSyncValue(optionName, TYPE_TO_MESSAGE[type]);\n};\n\nconst forbiddenNativeIfSync = ({optionName, value}) => {\n\tif (value === 'ipc' || value === 'overlapped') {\n\t\tthrowInvalidSyncValue(optionName, `\"${value}\"`);\n\t}\n\n\treturn {};\n};\n\nconst throwInvalidSyncValue = (optionName, value) => {\n\tthrow new TypeError(`The \\`${optionName}\\` option cannot be ${value} with synchronous methods.`);\n};\n\n// Create streams used internally for redirecting when using specific values for the `std*` options, in sync mode.\n// For example, `stdin: {file}` reads the file synchronously, then passes it as the `input` option.\nconst addProperties = {\n\tgenerator() {},\n\tasyncGenerator: forbiddenIfSync,\n\twebStream: forbiddenIfSync,\n\tnodeStream: forbiddenIfSync,\n\twebTransform: forbiddenIfSync,\n\tduplex: forbiddenIfSync,\n\tasyncIterable: forbiddenIfSync,\n\tnative: forbiddenNativeIfSync,\n};\n\nconst addPropertiesSync = {\n\tinput: {\n\t\t...addProperties,\n\t\tfileUrl: ({value}) => ({contents: [bufferToUint8Array(readFileSync(value))]}),\n\t\tfilePath: ({value: {file}}) => ({contents: [bufferToUint8Array(readFileSync(file))]}),\n\t\tfileNumber: forbiddenIfSync,\n\t\titerable: ({value}) => ({contents: [...value]}),\n\t\tstring: ({value}) => ({contents: [value]}),\n\t\tuint8Array: ({value}) => ({contents: [value]}),\n\t},\n\toutput: {\n\t\t...addProperties,\n\t\tfileUrl: ({value}) => ({path: value}),\n\t\tfilePath: ({value: {file, append}}) => ({path: file, append}),\n\t\tfileNumber: ({value}) => ({path: value}),\n\t\titerable: forbiddenIfSync,\n\t\tstring: forbiddenIfSync,\n\t\tuint8Array: forbiddenIfSync,\n\t},\n};\n", "import stripFinalNewlineFunction from 'strip-final-newline';\n\n// Apply `stripFinalNewline` option, which applies to `result.stdout|stderr|all|stdio[*]`.\n// If the `lines` option is used, it is applied on each line, but using a different function.\nexport const stripNewline = (value, {stripFinalNewline}, fdNumber) => getStripFinalNewline(stripFinalNewline, fdNumber) && value !== undefined && !Array.isArray(value)\n\t? stripFinalNewlineFunction(value)\n\t: value;\n\n// Retrieve `stripFinalNewline` option value, including with `subprocess.all`\nexport const getStripFinalNewline = (stripFinalNewline, fdNumber) => fdNumber === 'all'\n\t? stripFinalNewline[1] || stripFinalNewline[2]\n\t: stripFinalNewline[fdNumber];\n", "// Split chunks line-wise for generators passed to the `std*` options\nexport const getSplitLinesGenerator = (binary, preserveNewlines, skipped, state) => binary || skipped\n\t? undefined\n\t: initializeSplitLines(preserveNewlines, state);\n\n// Same but for synchronous methods\nexport const splitLinesSync = (chunk, preserveNewlines, objectMode) => objectMode\n\t? chunk.flatMap(item => splitLinesItemSync(item, preserveNewlines))\n\t: splitLinesItemSync(chunk, preserveNewlines);\n\nconst splitLinesItemSync = (chunk, preserveNewlines) => {\n\tconst {transform, final} = initializeSplitLines(preserveNewlines, {});\n\treturn [...transform(chunk), ...final()];\n};\n\nconst initializeSplitLines = (preserveNewlines, state) => {\n\tstate.previousChunks = '';\n\treturn {\n\t\ttransform: splitGenerator.bind(undefined, state, preserveNewlines),\n\t\tfinal: linesFinal.bind(undefined, state),\n\t};\n};\n\n// This imperative logic is much faster than using `String.split()` and uses very low memory.\nconst splitGenerator = function * (state, preserveNewlines, chunk) {\n\tif (typeof chunk !== 'string') {\n\t\tyield chunk;\n\t\treturn;\n\t}\n\n\tlet {previousChunks} = state;\n\tlet start = -1;\n\n\tfor (let end = 0; end < chunk.length; end += 1) {\n\t\tif (chunk[end] === '\\n') {\n\t\t\tconst newlineLength = getNewlineLength(chunk, end, preserveNewlines, state);\n\t\t\tlet line = chunk.slice(start + 1, end + 1 - newlineLength);\n\n\t\t\tif (previousChunks.length > 0) {\n\t\t\t\tline = concatString(previousChunks, line);\n\t\t\t\tpreviousChunks = '';\n\t\t\t}\n\n\t\t\tyield line;\n\t\t\tstart = end;\n\t\t}\n\t}\n\n\tif (start !== chunk.length - 1) {\n\t\tpreviousChunks = concatString(previousChunks, chunk.slice(start + 1));\n\t}\n\n\tstate.previousChunks = previousChunks;\n};\n\nconst getNewlineLength = (chunk, end, preserveNewlines, state) => {\n\tif (preserveNewlines) {\n\t\treturn 0;\n\t}\n\n\tstate.isWindowsNewline = end !== 0 && chunk[end - 1] === '\\r';\n\treturn state.isWindowsNewline ? 2 : 1;\n};\n\nconst linesFinal = function * ({previousChunks}) {\n\tif (previousChunks.length > 0) {\n\t\tyield previousChunks;\n\t}\n};\n\n// Unless `preserveNewlines: true` is used, we strip the newline of each line.\n// This re-adds them after the user `transform` code has run.\nexport const getAppendNewlineGenerator = ({binary, preserveNewlines, readableObjectMode, state}) => binary || preserveNewlines || readableObjectMode\n\t? undefined\n\t: {transform: appendNewlineGenerator.bind(undefined, state)};\n\nconst appendNewlineGenerator = function * ({isWindowsNewline = false}, chunk) {\n\tconst {unixNewline, windowsNewline, LF, concatBytes} = typeof chunk === 'string' ? linesStringInfo : linesUint8ArrayInfo;\n\n\tif (chunk.at(-1) === LF) {\n\t\tyield chunk;\n\t\treturn;\n\t}\n\n\tconst newline = isWindowsNewline ? windowsNewline : unixNewline;\n\tyield concatBytes(chunk, newline);\n};\n\nconst concatString = (firstChunk, secondChunk) => `${firstChunk}${secondChunk}`;\n\nconst linesStringInfo = {\n\twindowsNewline: '\\r\\n',\n\tunixNewline: '\\n',\n\tLF: '\\n',\n\tconcatBytes: concatString,\n};\n\nconst concatUint8Array = (firstChunk, secondChunk) => {\n\tconst chunk = new Uint8Array(firstChunk.length + secondChunk.length);\n\tchunk.set(firstChunk, 0);\n\tchunk.set(secondChunk, firstChunk.length);\n\treturn chunk;\n};\n\nconst linesUint8ArrayInfo = {\n\twindowsNewline: new Uint8Array([0x0D, 0x0A]),\n\tunixNewline: new Uint8Array([0x0A]),\n\tLF: 0x0A,\n\tconcatBytes: concatUint8Array,\n};\n", "import {Buffer} from 'node:buffer';\nimport {isUint8Array} from '../utils/uint-array.js';\n\n// Validate the type of chunk argument passed to transform generators\nexport const getValidateTransformInput = (writableObjectMode, optionName) => writableObjectMode\n\t? undefined\n\t: validateStringTransformInput.bind(undefined, optionName);\n\nconst validateStringTransformInput = function * (optionName, chunk) {\n\tif (typeof chunk !== 'string' && !isUint8Array(chunk) && !Buffer.isBuffer(chunk)) {\n\t\tthrow new TypeError(`The \\`${optionName}\\` option's transform must use \"objectMode: true\" to receive as input: ${typeof chunk}.`);\n\t}\n\n\tyield chunk;\n};\n\n// Validate the type of the value returned by transform generators\nexport const getValidateTransformReturn = (readableObjectMode, optionName) => readableObjectMode\n\t? validateObjectTransformReturn.bind(undefined, optionName)\n\t: validateStringTransformReturn.bind(undefined, optionName);\n\nconst validateObjectTransformReturn = function * (optionName, chunk) {\n\tvalidateEmptyReturn(optionName, chunk);\n\tyield chunk;\n};\n\nconst validateStringTransformReturn = function * (optionName, chunk) {\n\tvalidateEmptyReturn(optionName, chunk);\n\n\tif (typeof chunk !== 'string' && !isUint8Array(chunk)) {\n\t\tthrow new TypeError(`The \\`${optionName}\\` option's function must yield a string or an Uint8Array, not ${typeof chunk}.`);\n\t}\n\n\tyield chunk;\n};\n\nconst validateEmptyReturn = (optionName, chunk) => {\n\tif (chunk === null || chunk === undefined) {\n\t\tthrow new TypeError(`The \\`${optionName}\\` option's function must not call \\`yield ${chunk}\\`.\nInstead, \\`yield\\` should either be called with a value, or not be called at all. For example:\n  if (condition) { yield value; }`);\n\t}\n};\n", "import {Buffer} from 'node:buffer';\nimport {StringDecoder} from 'node:string_decoder';\nimport {isUint8Array, bufferToUint8Array} from '../utils/uint-array.js';\n\n/*\nWhen using binary encodings, add an internal generator that converts chunks from `Buffer` to `string` or `Uint8Array`.\nChunks might be Buffer, Uint8Array or strings since:\n- `subprocess.stdout|stderr` emits Buffers\n- `subprocess.stdin.write()` accepts Buffer, Uint8Array or string\n- Previous generators might return Uint8Array or string\n\nHowever, those are converted to Buffer:\n- on writes: `Duplex.writable` `decodeStrings: true` default option\n- on reads: `Duplex.readable` `readableEncoding: null` default option\n*/\nexport const getEncodingTransformGenerator = (binary, encoding, skipped) => {\n\tif (skipped) {\n\t\treturn;\n\t}\n\n\tif (binary) {\n\t\treturn {transform: encodingUint8ArrayGenerator.bind(undefined, new TextEncoder())};\n\t}\n\n\tconst stringDecoder = new StringDecoder(encoding);\n\treturn {\n\t\ttransform: encodingStringGenerator.bind(undefined, stringDecoder),\n\t\tfinal: encodingStringFinal.bind(undefined, stringDecoder),\n\t};\n};\n\nconst encodingUint8ArrayGenerator = function * (textEncoder, chunk) {\n\tif (Buffer.isBuffer(chunk)) {\n\t\tyield bufferToUint8Array(chunk);\n\t} else if (typeof chunk === 'string') {\n\t\tyield textEncoder.encode(chunk);\n\t} else {\n\t\tyield chunk;\n\t}\n};\n\nconst encodingStringGenerator = function * (stringDecoder, chunk) {\n\tyield isUint8Array(chunk) ? stringDecoder.write(chunk) : chunk;\n};\n\nconst encodingStringFinal = function * (stringDecoder) {\n\tconst lastChunk = stringDecoder.end();\n\tif (lastChunk !== '') {\n\t\tyield lastChunk;\n\t}\n};\n", "import {callbackify} from 'node:util';\n\n// Applies a series of generator functions asynchronously\nexport const pushChunks = callbackify(async (getChunks, state, getChunksArguments, transformStream) => {\n\tstate.currentIterable = getChunks(...getChunksArguments);\n\n\ttry {\n\t\tfor await (const chunk of state.currentIterable) {\n\t\t\ttransformStream.push(chunk);\n\t\t}\n\t} finally {\n\t\tdelete state.currentIterable;\n\t}\n});\n\n// For each new chunk, apply each `transform()` method\nexport const transformChunk = async function * (chunk, generators, index) {\n\tif (index === generators.length) {\n\t\tyield chunk;\n\t\treturn;\n\t}\n\n\tconst {transform = identityGenerator} = generators[index];\n\tfor await (const transformedChunk of transform(chunk)) {\n\t\tyield * transformChunk(transformedChunk, generators, index + 1);\n\t}\n};\n\n// At the end, apply each `final()` method, followed by the `transform()` method of the next transforms\nexport const finalChunks = async function * (generators) {\n\tfor (const [index, {final}] of Object.entries(generators)) {\n\t\tyield * generatorFinalChunks(final, Number(index), generators);\n\t}\n};\n\nconst generatorFinalChunks = async function * (final, index, generators) {\n\tif (final === undefined) {\n\t\treturn;\n\t}\n\n\tfor await (const finalChunk of final()) {\n\t\tyield * transformChunk(finalChunk, generators, index + 1);\n\t}\n};\n\n// Cancel any ongoing async generator when the Transform is destroyed, e.g. when the subprocess errors\nexport const destroyTransform = callbackify(async ({currentIterable}, error) => {\n\tif (currentIterable !== undefined) {\n\t\tawait (error ? currentIterable.throw(error) : currentIterable.return());\n\t\treturn;\n\t}\n\n\tif (error) {\n\t\tthrow error;\n\t}\n});\n\nconst identityGenerator = function * (chunk) {\n\tyield chunk;\n};\n", "// Duplicate the code from `run-async.js` but as synchronous functions\nexport const pushChunksSync = (getChunksSync, getChunksArguments, transformStream, done) => {\n\ttry {\n\t\tfor (const chunk of getChunksSync(...getChunksArguments)) {\n\t\t\ttransformStream.push(chunk);\n\t\t}\n\n\t\tdone();\n\t} catch (error) {\n\t\tdone(error);\n\t}\n};\n\n// Run synchronous generators with `execaSync()`\nexport const runTransformSync = (generators, chunks) => [\n\t...chunks.flatMap(chunk => [...transformChunkSync(chunk, generators, 0)]),\n\t...finalChunksSync(generators),\n];\n\nexport const transformChunkSync = function * (chunk, generators, index) {\n\tif (index === generators.length) {\n\t\tyield chunk;\n\t\treturn;\n\t}\n\n\tconst {transform = identityGenerator} = generators[index];\n\tfor (const transformedChunk of transform(chunk)) {\n\t\tyield * transformChunkSync(transformedChunk, generators, index + 1);\n\t}\n};\n\nexport const finalChunksSync = function * (generators) {\n\tfor (const [index, {final}] of Object.entries(generators)) {\n\t\tyield * generatorFinalChunksSync(final, Number(index), generators);\n\t}\n};\n\nconst generatorFinalChunksSync = function * (final, index, generators) {\n\tif (final === undefined) {\n\t\treturn;\n\t}\n\n\tfor (const finalChunk of final()) {\n\t\tyield * transformChunkSync(finalChunk, generators, index + 1);\n\t}\n};\n\nconst identityGenerator = function * (chunk) {\n\tyield chunk;\n};\n", "import {Transform, getDefaultHighWaterMark} from 'node:stream';\nimport {isAsyncGenerator} from '../stdio/type.js';\nimport {getSplitLinesGenerator, getAppendNewlineGenerator} from './split.js';\nimport {getValidateTransformInput, getValidateTransformReturn} from './validate.js';\nimport {getEncodingTransformGenerator} from './encoding-transform.js';\nimport {\n\tpushChunks,\n\ttransformChunk,\n\tfinalChunks,\n\tdestroyTransform,\n} from './run-async.js';\nimport {\n\tpushChunksSync,\n\ttransformChunkSync,\n\tfinalChunksSync,\n\trunTransformSync,\n} from './run-sync.js';\n\n/*\nGenerators can be used to transform/filter standard streams.\n\nGenerators have a simple syntax, yet allows all of the following:\n- Sharing `state` between chunks\n- Flushing logic, by using a `final` function\n- Asynchronous logic\n- Emitting multiple chunks from a single source chunk, even if spaced in time, by using multiple `yield`\n- Filtering, by using no `yield`\n\nTherefore, there is no need to allow Node.js or web transform streams.\n\nThe `highWaterMark` is kept as the default value, since this is what `subprocess.std*` uses.\n\nChunks are currently processed serially. We could add a `concurrency` option to parallelize in the future.\n\nTransform an array of generator functions into a `Transform` stream.\n`Duplex.from(generator)` cannot be used because it does not allow setting the `objectMode` and `highWaterMark`.\n*/\nexport const generatorToStream = ({\n\tvalue,\n\tvalue: {transform, final, writableObjectMode, readableObjectMode},\n\toptionName,\n}, {encoding}) => {\n\tconst state = {};\n\tconst generators = addInternalGenerators(value, encoding, optionName);\n\n\tconst transformAsync = isAsyncGenerator(transform);\n\tconst finalAsync = isAsyncGenerator(final);\n\tconst transformMethod = transformAsync\n\t\t? pushChunks.bind(undefined, transformChunk, state)\n\t\t: pushChunksSync.bind(undefined, transformChunkSync);\n\tconst finalMethod = transformAsync || finalAsync\n\t\t? pushChunks.bind(undefined, finalChunks, state)\n\t\t: pushChunksSync.bind(undefined, finalChunksSync);\n\tconst destroyMethod = transformAsync || finalAsync\n\t\t? destroyTransform.bind(undefined, state)\n\t\t: undefined;\n\n\tconst stream = new Transform({\n\t\twritableObjectMode,\n\t\twritableHighWaterMark: getDefaultHighWaterMark(writableObjectMode),\n\t\treadableObjectMode,\n\t\treadableHighWaterMark: getDefaultHighWaterMark(readableObjectMode),\n\t\ttransform(chunk, encoding, done) {\n\t\t\ttransformMethod([chunk, generators, 0], this, done);\n\t\t},\n\t\tflush(done) {\n\t\t\tfinalMethod([generators], this, done);\n\t\t},\n\t\tdestroy: destroyMethod,\n\t});\n\treturn {stream};\n};\n\n// Applies transform generators in sync mode\nexport const runGeneratorsSync = (chunks, stdioItems, encoding, isInput) => {\n\tconst generators = stdioItems.filter(({type}) => type === 'generator');\n\tconst reversedGenerators = isInput ? generators.reverse() : generators;\n\n\tfor (const {value, optionName} of reversedGenerators) {\n\t\tconst generators = addInternalGenerators(value, encoding, optionName);\n\t\tchunks = runTransformSync(generators, chunks);\n\t}\n\n\treturn chunks;\n};\n\n// Generators used internally to convert the chunk type, validate it, and split into lines\nconst addInternalGenerators = (\n\t{transform, final, binary, writableObjectMode, readableObjectMode, preserveNewlines},\n\tencoding,\n\toptionName,\n) => {\n\tconst state = {};\n\treturn [\n\t\t{transform: getValidateTransformInput(writableObjectMode, optionName)},\n\t\tgetEncodingTransformGenerator(binary, encoding, writableObjectMode),\n\t\tgetSplitLinesGenerator(binary, preserveNewlines, writableObjectMode, state),\n\t\t{transform, final},\n\t\t{transform: getValidateTransformReturn(readableObjectMode, optionName)},\n\t\tgetAppendNewlineGenerator({\n\t\t\tbinary,\n\t\t\tpreserveNewlines,\n\t\t\treadableObjectMode,\n\t\t\tstate,\n\t\t}),\n\t].filter(Boolean);\n};\n", "import {runGeneratorsSync} from '../transform/generator.js';\nimport {joinToUint8Array, isUint8Array} from '../utils/uint-array.js';\nimport {TYPE_TO_MESSAGE} from '../stdio/type.js';\n\n// Apply `stdin`/`input`/`inputFile` options, before spawning, in sync mode, by converting it to the `input` option\nexport const addInputOptionsSync = (fileDescriptors, options) => {\n\tfor (const fdNumber of getInputFdNumbers(fileDescriptors)) {\n\t\taddInputOptionSync(fileDescriptors, fdNumber, options);\n\t}\n};\n\nconst getInputFdNumbers = fileDescriptors => new Set(Object.entries(fileDescriptors)\n\t.filter(([, {direction}]) => direction === 'input')\n\t.map(([fdNumber]) => Number(fdNumber)));\n\nconst addInputOptionSync = (fileDescriptors, fdNumber, options) => {\n\tconst {stdioItems} = fileDescriptors[fdNumber];\n\tconst allStdioItems = stdioItems.filter(({contents}) => contents !== undefined);\n\tif (allStdioItems.length === 0) {\n\t\treturn;\n\t}\n\n\tif (fdNumber !== 0) {\n\t\tconst [{type, optionName}] = allStdioItems;\n\t\tthrow new TypeError(`Only the \\`stdin\\` option, not \\`${optionName}\\`, can be ${TYPE_TO_MESSAGE[type]} with synchronous methods.`);\n\t}\n\n\tconst allContents = allStdioItems.map(({contents}) => contents);\n\tconst transformedContents = allContents.map(contents => applySingleInputGeneratorsSync(contents, stdioItems));\n\toptions.input = joinToUint8Array(transformedContents);\n};\n\nconst applySingleInputGeneratorsSync = (contents, stdioItems) => {\n\tconst newContents = runGeneratorsSync(contents, stdioItems, 'utf8', true);\n\tvalidateSerializable(newContents);\n\treturn joinToUint8Array(newContents);\n};\n\nconst validateSerializable = newContents => {\n\tconst invalidItem = newContents.find(item => typeof item !== 'string' && !isUint8Array(item));\n\tif (invalidItem !== undefined) {\n\t\tthrow new TypeError(`The \\`stdin\\` option is invalid: when passing objects as input, a transform must be used to serialize them to strings or Uint8Arrays: ${invalidItem}.`);\n\t}\n};\n", "import {BINARY_ENCODINGS} from '../arguments/encoding-option.js';\nimport {TRANSFORM_TYPES} from '../stdio/type.js';\nimport {verboseLog, serializeVerboseMessage} from './log.js';\nimport {isFullVerbose} from './values.js';\n\n// `ignore` opts-out of `verbose` for a specific stream.\n// `ipc` cannot use piping.\n// `inherit` would result in double printing.\n// They can also lead to double printing when passing file descriptor integers or `process.std*`.\n// This only leaves with `pipe` and `overlapped`.\nexport const shouldLogOutput = ({stdioItems, encoding, verboseInfo, fdNumber}) => fdNumber !== 'all'\n\t&& isFullVerbose(verboseInfo, fdNumber)\n\t&& !BINARY_ENCODINGS.has(encoding)\n\t&& fdUsesVerbose(fdNumber)\n\t&& (stdioItems.some(({type, value}) => type === 'native' && PIPED_STDIO_VALUES.has(value))\n\t|| stdioItems.every(({type}) => TRANSFORM_TYPES.has(type)));\n\n// Printing input streams would be confusing.\n// Files and streams can produce big outputs, which we don't want to print.\n// We could print `stdio[3+]` but it often is redirected to files and streams, with the same issue.\n// So we only print stdout and stderr.\nconst fdUsesVerbose = fdNumber => fdNumber === 1 || fdNumber === 2;\n\nconst PIPED_STDIO_VALUES = new Set(['pipe', 'overlapped']);\n\n// `verbose: 'full'` printing logic with async methods\nexport const logLines = async (linesIterable, stream, fdNumber, verboseInfo) => {\n\tfor await (const line of linesIterable) {\n\t\tif (!isPipingStream(stream)) {\n\t\t\tlogLine(line, fdNumber, verboseInfo);\n\t\t}\n\t}\n};\n\n// `verbose: 'full'` printing logic with sync methods\nexport const logLinesSync = (linesArray, fdNumber, verboseInfo) => {\n\tfor (const line of linesArray) {\n\t\tlogLine(line, fdNumber, verboseInfo);\n\t}\n};\n\n// When `subprocess.stdout|stderr.pipe()` is called, `verbose` becomes a noop.\n// This prevents the following problems:\n//  - `.pipe()` achieves the same result as using `stdout: 'inherit'`, `stdout: stream`, etc. which also make `verbose` a noop.\n//    For example, `subprocess.stdout.pipe(process.stdin)` would print each line twice.\n//  - When chaining subprocesses with `subprocess.pipe(otherSubprocess)`, only the last one should print its output.\n// Detecting whether `.pipe()` is impossible without monkey-patching it, so we use the following undocumented property.\n// This is not a critical behavior since changes of the following property would only make `verbose` more verbose.\nconst isPipingStream = stream => stream._readableState.pipes.length > 0;\n\n// When `verbose` is `full`, print stdout|stderr\nconst logLine = (line, fdNumber, verboseInfo) => {\n\tconst verboseMessage = serializeVerboseMessage(line);\n\tverboseLog({\n\t\ttype: 'output',\n\t\tverboseMessage,\n\t\tfdNumber,\n\t\tverboseInfo,\n\t});\n};\n", "import {writeFileSync, appendFileSync} from 'node:fs';\nimport {shouldLogOutput, logLinesSync} from '../verbose/output.js';\nimport {runGeneratorsSync} from '../transform/generator.js';\nimport {splitLinesSync} from '../transform/split.js';\nimport {joinToString, joinToUint8Array, bufferToUint8Array} from '../utils/uint-array.js';\nimport {FILE_TYPES} from '../stdio/type.js';\nimport {truncateMaxBufferSync} from './max-buffer.js';\n\n// Apply `stdout`/`stderr` options, after spawning, in sync mode\nexport const transformOutputSync = ({fileDescriptors, syncResult: {output}, options, isMaxBuffer, verboseInfo}) => {\n\tif (output === null) {\n\t\treturn {output: Array.from({length: 3})};\n\t}\n\n\tconst state = {};\n\tconst outputFiles = new Set([]);\n\tconst transformedOutput = output.map((result, fdNumber) =>\n\t\ttransformOutputResultSync({\n\t\t\tresult,\n\t\t\tfileDescriptors,\n\t\t\tfdNumber,\n\t\t\tstate,\n\t\t\toutputFiles,\n\t\t\tisMaxBuffer,\n\t\t\tverboseInfo,\n\t\t}, options));\n\treturn {output: transformedOutput, ...state};\n};\n\nconst transformOutputResultSync = (\n\t{result, fileDescriptors, fdNumber, state, outputFiles, isMaxBuffer, verboseInfo},\n\t{buffer, encoding, lines, stripFinalNewline, maxBuffer},\n) => {\n\tif (result === null) {\n\t\treturn;\n\t}\n\n\tconst truncatedResult = truncateMaxBufferSync(result, isMaxBuffer, maxBuffer);\n\tconst uint8ArrayResult = bufferToUint8Array(truncatedResult);\n\tconst {stdioItems, objectMode} = fileDescriptors[fdNumber];\n\tconst chunks = runOutputGeneratorsSync([uint8ArrayResult], stdioItems, encoding, state);\n\tconst {serializedResult, finalResult = serializedResult} = serializeChunks({\n\t\tchunks,\n\t\tobjectMode,\n\t\tencoding,\n\t\tlines,\n\t\tstripFinalNewline,\n\t\tfdNumber,\n\t});\n\n\tlogOutputSync({\n\t\tserializedResult,\n\t\tfdNumber,\n\t\tstate,\n\t\tverboseInfo,\n\t\tencoding,\n\t\tstdioItems,\n\t\tobjectMode,\n\t});\n\n\tconst returnedResult = buffer[fdNumber] ? finalResult : undefined;\n\n\ttry {\n\t\tif (state.error === undefined) {\n\t\t\twriteToFiles(serializedResult, stdioItems, outputFiles);\n\t\t}\n\n\t\treturn returnedResult;\n\t} catch (error) {\n\t\tstate.error = error;\n\t\treturn returnedResult;\n\t}\n};\n\n// Applies transform generators to `stdout`/`stderr`\nconst runOutputGeneratorsSync = (chunks, stdioItems, encoding, state) => {\n\ttry {\n\t\treturn runGeneratorsSync(chunks, stdioItems, encoding, false);\n\t} catch (error) {\n\t\tstate.error = error;\n\t\treturn chunks;\n\t}\n};\n\n// The contents is converted to three stages:\n//  - serializedResult: used when the target is a file path/URL or a file descriptor (including 'inherit')\n//  - finalResult/returnedResult: returned as `result.std*`\nconst serializeChunks = ({chunks, objectMode, encoding, lines, stripFinalNewline, fdNumber}) => {\n\tif (objectMode) {\n\t\treturn {serializedResult: chunks};\n\t}\n\n\tif (encoding === 'buffer') {\n\t\treturn {serializedResult: joinToUint8Array(chunks)};\n\t}\n\n\tconst serializedResult = joinToString(chunks, encoding);\n\tif (lines[fdNumber]) {\n\t\treturn {serializedResult, finalResult: splitLinesSync(serializedResult, !stripFinalNewline[fdNumber], objectMode)};\n\t}\n\n\treturn {serializedResult};\n};\n\nconst logOutputSync = ({serializedResult, fdNumber, state, verboseInfo, encoding, stdioItems, objectMode}) => {\n\tif (!shouldLogOutput({\n\t\tstdioItems,\n\t\tencoding,\n\t\tverboseInfo,\n\t\tfdNumber,\n\t})) {\n\t\treturn;\n\t}\n\n\tconst linesArray = splitLinesSync(serializedResult, false, objectMode);\n\n\ttry {\n\t\tlogLinesSync(linesArray, fdNumber, verboseInfo);\n\t} catch (error) {\n\t\tstate.error ??= error;\n\t}\n};\n\n// When the `std*` target is a file path/URL or a file descriptor\nconst writeToFiles = (serializedResult, stdioItems, outputFiles) => {\n\tfor (const {path, append} of stdioItems.filter(({type}) => FILE_TYPES.has(type))) {\n\t\tconst pathString = typeof path === 'string' ? path : path.toString();\n\t\tif (append || outputFiles.has(pathString)) {\n\t\t\tappendFileSync(path, serializedResult);\n\t\t} else {\n\t\t\toutputFiles.add(pathString);\n\t\t\twriteFileSync(path, serializedResult);\n\t\t}\n\t}\n};\n", "import {isUint8Array, concatUint8Arrays} from '../utils/uint-array.js';\nimport {stripNewline} from '../io/strip-newline.js';\n\n// Retrieve `result.all` with synchronous methods\nexport const getAllSync = ([, stdout, stderr], options) => {\n\tif (!options.all) {\n\t\treturn;\n\t}\n\n\tif (stdout === undefined) {\n\t\treturn stderr;\n\t}\n\n\tif (stderr === undefined) {\n\t\treturn stdout;\n\t}\n\n\tif (Array.isArray(stdout)) {\n\t\treturn Array.isArray(stderr)\n\t\t\t? [...stdout, ...stderr]\n\t\t\t: [...stdout, stripNewline(stderr, options, 'all')];\n\t}\n\n\tif (Array.isArray(stderr)) {\n\t\treturn [stripNewline(stdout, options, 'all'), ...stderr];\n\t}\n\n\tif (isUint8Array(stdout) && isUint8Array(stderr)) {\n\t\treturn concatUint8Arrays([stdout, stderr]);\n\t}\n\n\treturn `${stdout}${stderr}`;\n};\n", "import {once} from 'node:events';\nimport {DiscardedError} from '../return/final-error.js';\n\n// If `error` is emitted before `spawn`, `exit` will never be emitted.\n// However, `error` might be emitted after `spawn`.\n// In that case, `exit` will still be emitted.\n// Since the `exit` event contains the signal name, we want to make sure we are listening for it.\n// This function also takes into account the following unlikely cases:\n//  - `exit` being emitted in the same microtask as `spawn`\n//  - `error` being emitted multiple times\nexport const waitForExit = async (subprocess, context) => {\n\tconst [exitCode, signal] = await waitForExitOrError(subprocess);\n\tcontext.isForcefullyTerminated ??= false;\n\treturn [exitCode, signal];\n};\n\nconst waitForExitOrError = async subprocess => {\n\tconst [spawnPayload, exitPayload] = await Promise.allSettled([\n\t\tonce(subprocess, 'spawn'),\n\t\tonce(subprocess, 'exit'),\n\t]);\n\n\tif (spawnPayload.status === 'rejected') {\n\t\treturn [];\n\t}\n\n\treturn exitPayload.status === 'rejected'\n\t\t? waitForSubprocessExit(subprocess)\n\t\t: exitPayload.value;\n};\n\nconst waitForSubprocessExit = async subprocess => {\n\ttry {\n\t\treturn await once(subprocess, 'exit');\n\t} catch {\n\t\treturn waitForSubprocessExit(subprocess);\n\t}\n};\n\n// Retrieve the final exit code and|or signal name\nexport const waitForSuccessfulExit = async exitPromise => {\n\tconst [exitCode, signal] = await exitPromise;\n\n\tif (!isSubprocessErrorExit(exitCode, signal) && isFailedExit(exitCode, signal)) {\n\t\tthrow new DiscardedError();\n\t}\n\n\treturn [exitCode, signal];\n};\n\n// When the subprocess fails due to an `error` event\nconst isSubprocessErrorExit = (exitCode, signal) => exitCode === undefined && signal === undefined;\n// When the subprocess fails due to a non-0 exit code or to a signal termination\nexport const isFailedExit = (exitCode, signal) => exitCode !== 0 || signal !== null;\n", "import {DiscardedError} from '../return/final-error.js';\nimport {isMaxBufferSync} from '../io/max-buffer.js';\nimport {isFailedExit} from './exit-async.js';\n\n// Retrieve exit code, signal name and error information, with synchronous methods\nexport const getExitResultSync = ({error, status: exitCode, signal, output}, {maxBuffer}) => {\n\tconst resultError = getResultError(error, exitCode, signal);\n\tconst timedOut = resultError?.code === 'ETIMEDOUT';\n\tconst isMaxBuffer = isMaxBufferSync(resultError, output, maxBuffer);\n\treturn {\n\t\tresultError,\n\t\texitCode,\n\t\tsignal,\n\t\ttimedOut,\n\t\tisMaxBuffer,\n\t};\n};\n\nconst getResultError = (error, exitCode, signal) => {\n\tif (error !== undefined) {\n\t\treturn error;\n\t}\n\n\treturn isFailedExit(exitCode, signal) ? new DiscardedError() : undefined;\n};\n", "import {spawnSync} from 'node:child_process';\nimport {handleCommand} from '../arguments/command.js';\nimport {normalizeOptions} from '../arguments/options.js';\nimport {concatenateShell} from '../arguments/shell.js';\nimport {makeError, makeEarlyError, makeSuccessResult} from '../return/result.js';\nimport {handleResult} from '../return/reject.js';\nimport {handleStdioSync} from '../stdio/handle-sync.js';\nimport {stripNewline} from '../io/strip-newline.js';\nimport {addInputOptionsSync} from '../io/input-sync.js';\nimport {transformOutputSync} from '../io/output-sync.js';\nimport {getMaxBufferSync} from '../io/max-buffer.js';\nimport {getAllSync} from '../resolve/all-sync.js';\nimport {getExitResultSync} from '../resolve/exit-sync.js';\n\n// Main shared logic for all sync methods: `execaSync()`, `$.sync()`\nexport const execaCoreSync = (rawFile, rawArguments, rawOptions) => {\n\tconst {file, commandArguments, command, escapedCommand, startTime, verboseInfo, options, fileDescriptors} = handleSyncArguments(rawFile, rawArguments, rawOptions);\n\tconst result = spawnSubprocessSync({\n\t\tfile,\n\t\tcommandArguments,\n\t\toptions,\n\t\tcommand,\n\t\tescapedCommand,\n\t\tverboseInfo,\n\t\tfileDescriptors,\n\t\tstartTime,\n\t});\n\treturn handleResult(result, verboseInfo, options);\n};\n\n// Compute arguments to pass to `child_process.spawnSync()`\nconst handleSyncArguments = (rawFile, rawArguments, rawOptions) => {\n\tconst {command, escapedCommand, startTime, verboseInfo} = handleCommand(rawFile, rawArguments, rawOptions);\n\tconst syncOptions = normalizeSyncOptions(rawOptions);\n\tconst {file, commandArguments, options} = normalizeOptions(rawFile, rawArguments, syncOptions);\n\tvalidateSyncOptions(options);\n\tconst fileDescriptors = handleStdioSync(options, verboseInfo);\n\treturn {\n\t\tfile,\n\t\tcommandArguments,\n\t\tcommand,\n\t\tescapedCommand,\n\t\tstartTime,\n\t\tverboseInfo,\n\t\toptions,\n\t\tfileDescriptors,\n\t};\n};\n\n// Options normalization logic specific to sync methods\nconst normalizeSyncOptions = options => options.node && !options.ipc ? {...options, ipc: false} : options;\n\n// Options validation logic specific to sync methods\nconst validateSyncOptions = ({ipc, ipcInput, detached, cancelSignal}) => {\n\tif (ipcInput) {\n\t\tthrowInvalidSyncOption('ipcInput');\n\t}\n\n\tif (ipc) {\n\t\tthrowInvalidSyncOption('ipc: true');\n\t}\n\n\tif (detached) {\n\t\tthrowInvalidSyncOption('detached: true');\n\t}\n\n\tif (cancelSignal) {\n\t\tthrowInvalidSyncOption('cancelSignal');\n\t}\n};\n\nconst throwInvalidSyncOption = value => {\n\tthrow new TypeError(`The \"${value}\" option cannot be used with synchronous methods.`);\n};\n\nconst spawnSubprocessSync = ({file, commandArguments, options, command, escapedCommand, verboseInfo, fileDescriptors, startTime}) => {\n\tconst syncResult = runSubprocessSync({\n\t\tfile,\n\t\tcommandArguments,\n\t\toptions,\n\t\tcommand,\n\t\tescapedCommand,\n\t\tfileDescriptors,\n\t\tstartTime,\n\t});\n\tif (syncResult.failed) {\n\t\treturn syncResult;\n\t}\n\n\tconst {resultError, exitCode, signal, timedOut, isMaxBuffer} = getExitResultSync(syncResult, options);\n\tconst {output, error = resultError} = transformOutputSync({\n\t\tfileDescriptors,\n\t\tsyncResult,\n\t\toptions,\n\t\tisMaxBuffer,\n\t\tverboseInfo,\n\t});\n\tconst stdio = output.map((stdioOutput, fdNumber) => stripNewline(stdioOutput, options, fdNumber));\n\tconst all = stripNewline(getAllSync(output, options), options, 'all');\n\treturn getSyncResult({\n\t\terror,\n\t\texitCode,\n\t\tsignal,\n\t\ttimedOut,\n\t\tisMaxBuffer,\n\t\tstdio,\n\t\tall,\n\t\toptions,\n\t\tcommand,\n\t\tescapedCommand,\n\t\tstartTime,\n\t});\n};\n\nconst runSubprocessSync = ({file, commandArguments, options, command, escapedCommand, fileDescriptors, startTime}) => {\n\ttry {\n\t\taddInputOptionsSync(fileDescriptors, options);\n\t\tconst normalizedOptions = normalizeSpawnSyncOptions(options);\n\t\treturn spawnSync(...concatenateShell(file, commandArguments, normalizedOptions));\n\t} catch (error) {\n\t\treturn makeEarlyError({\n\t\t\terror,\n\t\t\tcommand,\n\t\t\tescapedCommand,\n\t\t\tfileDescriptors,\n\t\t\toptions,\n\t\t\tstartTime,\n\t\t\tisSync: true,\n\t\t});\n\t}\n};\n\n// The `encoding` option is handled by Execa, not by `child_process.spawnSync()`\nconst normalizeSpawnSyncOptions = ({encoding, maxBuffer, ...options}) => ({...options, encoding: 'buffer', maxBuffer: getMaxBufferSync(maxBuffer)});\n\nconst getSyncResult = ({error, exitCode, signal, timedOut, isMaxBuffer, stdio, all, options, command, escapedCommand, startTime}) => error === undefined\n\t? makeSuccessResult({\n\t\tcommand,\n\t\tescapedCommand,\n\t\tstdio,\n\t\tall,\n\t\tipcOutput: [],\n\t\toptions,\n\t\tstartTime,\n\t})\n\t: makeError({\n\t\terror,\n\t\tcommand,\n\t\tescapedCommand,\n\t\ttimedOut,\n\t\tisCanceled: false,\n\t\tisGracefullyCanceled: false,\n\t\tisMaxBuffer,\n\t\tisForcefullyTerminated: false,\n\t\texitCode,\n\t\tsignal,\n\t\tstdio,\n\t\tall,\n\t\tipcOutput: [],\n\t\toptions,\n\t\tstartTime,\n\t\tisSync: true,\n\t});\n", "import {once, on} from 'node:events';\nimport {\n\tvalidateIpcMethod,\n\tthrowOnEarlyDisconnect,\n\tdisconnect,\n\tgetStrictResponseError,\n} from './validation.js';\nimport {getIpcEmitter, isConnected} from './forward.js';\nimport {addReference, removeReference} from './reference.js';\n\n// Like `[sub]process.once('message')` but promise-based\nexport const getOneMessage = ({anyProcess, channel, isSubprocess, ipc}, {reference = true, filter} = {}) => {\n\tvalidateIpcMethod({\n\t\tmethodName: 'getOneMessage',\n\t\tisSubprocess,\n\t\tipc,\n\t\tisConnected: isConnected(anyProcess),\n\t});\n\n\treturn getOneMessageAsync({\n\t\tanyProcess,\n\t\tchannel,\n\t\tisSubprocess,\n\t\tfilter,\n\t\treference,\n\t});\n};\n\nconst getOneMessageAsync = async ({anyProcess, channel, isSubprocess, filter, reference}) => {\n\taddReference(channel, reference);\n\tconst ipcEmitter = getIpcEmitter(anyProcess, channel, isSubprocess);\n\tconst controller = new AbortController();\n\ttry {\n\t\treturn await Promise.race([\n\t\t\tgetMessage(ipcEmitter, filter, controller),\n\t\t\tthrowOnDisconnect(ipcEmitter, isSubprocess, controller),\n\t\t\tthrowOnStrictError(ipcEmitter, isSubprocess, controller),\n\t\t]);\n\t} catch (error) {\n\t\tdisconnect(anyProcess);\n\t\tthrow error;\n\t} finally {\n\t\tcontroller.abort();\n\t\tremoveReference(channel, reference);\n\t}\n};\n\nconst getMessage = async (ipcEmitter, filter, {signal}) => {\n\tif (filter === undefined) {\n\t\tconst [message] = await once(ipcEmitter, 'message', {signal});\n\t\treturn message;\n\t}\n\n\tfor await (const [message] of on(ipcEmitter, 'message', {signal})) {\n\t\tif (filter(message)) {\n\t\t\treturn message;\n\t\t}\n\t}\n};\n\nconst throwOnDisconnect = async (ipcEmitter, isSubprocess, {signal}) => {\n\tawait once(ipcEmitter, 'disconnect', {signal});\n\tthrowOnEarlyDisconnect(isSubprocess);\n};\n\nconst throwOnStrictError = async (ipcEmitter, isSubprocess, {signal}) => {\n\tconst [error] = await once(ipcEmitter, 'strict:error', {signal});\n\tthrow getStrictResponseError(error, isSubprocess);\n};\n", "import {once, on} from 'node:events';\nimport {validateIpcMethod, disconnect, getStrictResponseError} from './validation.js';\nimport {getIpcEmitter, isConnected} from './forward.js';\nimport {addReference, removeReference} from './reference.js';\n\n// Like `[sub]process.on('message')` but promise-based\nexport const getEachMessage = ({anyProcess, channel, isSubprocess, ipc}, {reference = true} = {}) => loopOnMessages({\n\tanyProcess,\n\tchannel,\n\tisSubprocess,\n\tipc,\n\tshouldAwait: !isSubprocess,\n\treference,\n});\n\n// Same but used internally\nexport const loopOnMessages = ({anyProcess, channel, isSubprocess, ipc, shouldAwait, reference}) => {\n\tvalidateIpcMethod({\n\t\tmethodName: 'getEachMessage',\n\t\tisSubprocess,\n\t\tipc,\n\t\tisConnected: isConnected(anyProcess),\n\t});\n\n\taddReference(channel, reference);\n\tconst ipcEmitter = getIpcEmitter(anyProcess, channel, isSubprocess);\n\tconst controller = new AbortController();\n\tconst state = {};\n\tstopOnDisconnect(anyProcess, ipcEmitter, controller);\n\tabortOnStrictError({\n\t\tipcEmitter,\n\t\tisSubprocess,\n\t\tcontroller,\n\t\tstate,\n\t});\n\treturn iterateOnMessages({\n\t\tanyProcess,\n\t\tchannel,\n\t\tipcEmitter,\n\t\tisSubprocess,\n\t\tshouldAwait,\n\t\tcontroller,\n\t\tstate,\n\t\treference,\n\t});\n};\n\nconst stopOnDisconnect = async (anyProcess, ipcEmitter, controller) => {\n\ttry {\n\t\tawait once(ipcEmitter, 'disconnect', {signal: controller.signal});\n\t\tcontroller.abort();\n\t} catch {}\n};\n\nconst abortOnStrictError = async ({ipcEmitter, isSubprocess, controller, state}) => {\n\ttry {\n\t\tconst [error] = await once(ipcEmitter, 'strict:error', {signal: controller.signal});\n\t\tstate.error = getStrictResponseError(error, isSubprocess);\n\t\tcontroller.abort();\n\t} catch {}\n};\n\nconst iterateOnMessages = async function * ({anyProcess, channel, ipcEmitter, isSubprocess, shouldAwait, controller, state, reference}) {\n\ttry {\n\t\tfor await (const [message] of on(ipcEmitter, 'message', {signal: controller.signal})) {\n\t\t\tthrowIfStrictError(state);\n\t\t\tyield message;\n\t\t}\n\t} catch {\n\t\tthrowIfStrictError(state);\n\t} finally {\n\t\tcontroller.abort();\n\t\tremoveReference(channel, reference);\n\n\t\tif (!isSubprocess) {\n\t\t\tdisconnect(anyProcess);\n\t\t}\n\n\t\tif (shouldAwait) {\n\t\t\tawait anyProcess;\n\t\t}\n\t}\n};\n\nconst throwIfStrictError = ({error}) => {\n\tif (error) {\n\t\tthrow error;\n\t}\n};\n", "import process from 'node:process';\nimport {sendMessage} from './send.js';\nimport {getOneMessage} from './get-one.js';\nimport {getEachMessage} from './get-each.js';\nimport {getCancelSignal} from './graceful.js';\n\n// Add promise-based IPC methods in current process\nexport const addIpcMethods = (subprocess, {ipc}) => {\n\tObject.assign(subprocess, getIpcMethods(subprocess, false, ipc));\n};\n\n// Get promise-based IPC in the subprocess\nexport const getIpcExport = () => {\n\tconst anyProcess = process;\n\tconst isSubprocess = true;\n\tconst ipc = process.channel !== undefined;\n\n\treturn {\n\t\t...getIpcMethods(anyProcess, isSubprocess, ipc),\n\t\tgetCancelSignal: getCancelSignal.bind(undefined, {\n\t\t\tanyProcess,\n\t\t\tchannel: anyProcess.channel,\n\t\t\tisSubprocess,\n\t\t\tipc,\n\t\t}),\n\t};\n};\n\n// Retrieve the `ipc` shared by both the current process and the subprocess\nconst getIpcMethods = (anyProcess, isSubprocess, ipc) => ({\n\tsendMessage: sendMessage.bind(undefined, {\n\t\tanyProcess,\n\t\tchannel: anyProcess.channel,\n\t\tisSubprocess,\n\t\tipc,\n\t}),\n\tgetOneMessage: getOneMessage.bind(undefined, {\n\t\tanyProcess,\n\t\tchannel: anyProcess.channel,\n\t\tisSubprocess,\n\t\tipc,\n\t}),\n\tgetEachMessage: getEachMessage.bind(undefined, {\n\t\tanyProcess,\n\t\tchannel: anyProcess.channel,\n\t\tisSubprocess,\n\t\tipc,\n\t}),\n});\n", "import {ChildProcess} from 'node:child_process';\nimport {\n\tPassThrough,\n\tReadable,\n\tWritable,\n\tDuplex,\n} from 'node:stream';\nimport {cleanupCustomStreams} from '../stdio/handle.js';\nimport {makeEarlyError} from './result.js';\nimport {handleResult} from './reject.js';\n\n// When the subprocess fails to spawn.\n// We ensure the returned error is always both a promise and a subprocess.\nexport const handleEarlyError = ({error, command, escapedCommand, fileDescriptors, options, startTime, verboseInfo}) => {\n\tcleanupCustomStreams(fileDescriptors);\n\n\tconst subprocess = new ChildProcess();\n\tcreateDummyStreams(subprocess, fileDescriptors);\n\tObject.assign(subprocess, {readable, writable, duplex});\n\n\tconst earlyError = makeEarlyError({\n\t\terror,\n\t\tcommand,\n\t\tescapedCommand,\n\t\tfileDescriptors,\n\t\toptions,\n\t\tstartTime,\n\t\tisSync: false,\n\t});\n\tconst promise = handleDummyPromise(earlyError, verboseInfo, options);\n\treturn {subprocess, promise};\n};\n\nconst createDummyStreams = (subprocess, fileDescriptors) => {\n\tconst stdin = createDummyStream();\n\tconst stdout = createDummyStream();\n\tconst stderr = createDummyStream();\n\tconst extraStdio = Array.from({length: fileDescriptors.length - 3}, createDummyStream);\n\tconst all = createDummyStream();\n\tconst stdio = [stdin, stdout, stderr, ...extraStdio];\n\tObject.assign(subprocess, {\n\t\tstdin,\n\t\tstdout,\n\t\tstderr,\n\t\tall,\n\t\tstdio,\n\t});\n};\n\nconst createDummyStream = () => {\n\tconst stream = new PassThrough();\n\tstream.end();\n\treturn stream;\n};\n\nconst readable = () => new Readable({read() {}});\nconst writable = () => new Writable({write() {}});\nconst duplex = () => new Duplex({read() {}, write() {}});\n\nconst handleDummyPromise = async (error, verboseInfo, options) => handleResult(error, verboseInfo, options);\n", "import {createReadStream, createWriteStream} from 'node:fs';\nimport {Buffer} from 'node:buffer';\nimport {Readable, Writable, Duplex} from 'node:stream';\nimport {generatorToStream} from '../transform/generator.js';\nimport {handleStdio} from './handle.js';\nimport {TYPE_TO_MESSAGE} from './type.js';\n\n// Handle `input`, `inputFile`, `stdin`, `stdout` and `stderr` options, before spawning, in async mode\nexport const handleStdioAsync = (options, verboseInfo) => handleStdio(addPropertiesAsync, options, verboseInfo, false);\n\nconst forbiddenIfAsync = ({type, optionName}) => {\n\tthrow new TypeError(`The \\`${optionName}\\` option cannot be ${TYPE_TO_MESSAGE[type]}.`);\n};\n\n// Create streams used internally for piping when using specific values for the `std*` options, in async mode.\n// For example, `stdout: {file}` creates a file stream, which is piped from/to.\nconst addProperties = {\n\tfileNumber: forbiddenIfAsync,\n\tgenerator: generatorToStream,\n\tasyncGenerator: generatorToStream,\n\tnodeStream: ({value}) => ({stream: value}),\n\twebTransform({value: {transform, writableObjectMode, readableObjectMode}}) {\n\t\tconst objectMode = writableObjectMode || readableObjectMode;\n\t\tconst stream = Duplex.fromWeb(transform, {objectMode});\n\t\treturn {stream};\n\t},\n\tduplex: ({value: {transform}}) => ({stream: transform}),\n\tnative() {},\n};\n\nconst addPropertiesAsync = {\n\tinput: {\n\t\t...addProperties,\n\t\tfileUrl: ({value}) => ({stream: createReadStream(value)}),\n\t\tfilePath: ({value: {file}}) => ({stream: createReadStream(file)}),\n\t\twebStream: ({value}) => ({stream: Readable.fromWeb(value)}),\n\t\titerable: ({value}) => ({stream: Readable.from(value)}),\n\t\tasyncIterable: ({value}) => ({stream: Readable.from(value)}),\n\t\tstring: ({value}) => ({stream: Readable.from(value)}),\n\t\tuint8Array: ({value}) => ({stream: Readable.from(Buffer.from(value))}),\n\t},\n\toutput: {\n\t\t...addProperties,\n\t\tfileUrl: ({value}) => ({stream: createWriteStream(value)}),\n\t\tfilePath: ({value: {file, append}}) => ({stream: createWriteStream(file, append ? {flags: 'a'} : {})}),\n\t\twebStream: ({value}) => ({stream: Writable.fromWeb(value)}),\n\t\titerable: forbiddenIfAsync,\n\t\tasyncIterable: forbiddenIfAsync,\n\t\tstring: forbiddenIfAsync,\n\t\tuint8Array: forbiddenIfAsync,\n\t},\n};\n", "import {on, once} from 'node:events';\nimport {PassThrough as PassThroughStream, getDefaultHighWaterMark} from 'node:stream';\nimport {finished} from 'node:stream/promises';\n\nexport default function mergeStreams(streams) {\n\tif (!Array.isArray(streams)) {\n\t\tthrow new TypeError(`Expected an array, got \\`${typeof streams}\\`.`);\n\t}\n\n\tfor (const stream of streams) {\n\t\tvalidateStream(stream);\n\t}\n\n\tconst objectMode = streams.some(({readableObjectMode}) => readableObjectMode);\n\tconst highWaterMark = getHighWaterMark(streams, objectMode);\n\tconst passThroughStream = new MergedStream({\n\t\tobjectMode,\n\t\twritableHighWaterMark: highWaterMark,\n\t\treadableHighWaterMark: highWaterMark,\n\t});\n\n\tfor (const stream of streams) {\n\t\tpassThroughStream.add(stream);\n\t}\n\n\treturn passThroughStream;\n}\n\nconst getHighWaterMark = (streams, objectMode) => {\n\tif (streams.length === 0) {\n\t\treturn getDefaultHighWaterMark(objectMode);\n\t}\n\n\tconst highWaterMarks = streams\n\t\t.filter(({readableObjectMode}) => readableObjectMode === objectMode)\n\t\t.map(({readableHighWaterMark}) => readableHighWaterMark);\n\treturn Math.max(...highWaterMarks);\n};\n\nclass MergedStream extends PassThroughStream {\n\t#streams = new Set([]);\n\t#ended = new Set([]);\n\t#aborted = new Set([]);\n\t#onFinished;\n\t#unpipeEvent = Symbol('unpipe');\n\t#streamPromises = new WeakMap();\n\n\tadd(stream) {\n\t\tvalidateStream(stream);\n\n\t\tif (this.#streams.has(stream)) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.#streams.add(stream);\n\n\t\tthis.#onFinished ??= onMergedStreamFinished(this, this.#streams, this.#unpipeEvent);\n\t\tconst streamPromise = endWhenStreamsDone({\n\t\t\tpassThroughStream: this,\n\t\t\tstream,\n\t\t\tstreams: this.#streams,\n\t\t\tended: this.#ended,\n\t\t\taborted: this.#aborted,\n\t\t\tonFinished: this.#onFinished,\n\t\t\tunpipeEvent: this.#unpipeEvent,\n\t\t});\n\t\tthis.#streamPromises.set(stream, streamPromise);\n\n\t\tstream.pipe(this, {end: false});\n\t}\n\n\tasync remove(stream) {\n\t\tvalidateStream(stream);\n\n\t\tif (!this.#streams.has(stream)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst streamPromise = this.#streamPromises.get(stream);\n\t\tif (streamPromise === undefined) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.#streamPromises.delete(stream);\n\n\t\tstream.unpipe(this);\n\t\tawait streamPromise;\n\t\treturn true;\n\t}\n}\n\nconst onMergedStreamFinished = async (passThroughStream, streams, unpipeEvent) => {\n\tupdateMaxListeners(passThroughStream, PASSTHROUGH_LISTENERS_COUNT);\n\tconst controller = new AbortController();\n\n\ttry {\n\t\tawait Promise.race([\n\t\t\tonMergedStreamEnd(passThroughStream, controller),\n\t\t\tonInputStreamsUnpipe(passThroughStream, streams, unpipeEvent, controller),\n\t\t]);\n\t} finally {\n\t\tcontroller.abort();\n\t\tupdateMaxListeners(passThroughStream, -PASSTHROUGH_LISTENERS_COUNT);\n\t}\n};\n\nconst onMergedStreamEnd = async (passThroughStream, {signal}) => {\n\ttry {\n\t\tawait finished(passThroughStream, {signal, cleanup: true});\n\t} catch (error) {\n\t\terrorOrAbortStream(passThroughStream, error);\n\t\tthrow error;\n\t}\n};\n\nconst onInputStreamsUnpipe = async (passThroughStream, streams, unpipeEvent, {signal}) => {\n\tfor await (const [unpipedStream] of on(passThroughStream, 'unpipe', {signal})) {\n\t\tif (streams.has(unpipedStream)) {\n\t\t\tunpipedStream.emit(unpipeEvent);\n\t\t}\n\t}\n};\n\nconst validateStream = stream => {\n\tif (typeof stream?.pipe !== 'function') {\n\t\tthrow new TypeError(`Expected a readable stream, got: \\`${typeof stream}\\`.`);\n\t}\n};\n\nconst endWhenStreamsDone = async ({passThroughStream, stream, streams, ended, aborted, onFinished, unpipeEvent}) => {\n\tupdateMaxListeners(passThroughStream, PASSTHROUGH_LISTENERS_PER_STREAM);\n\tconst controller = new AbortController();\n\n\ttry {\n\t\tawait Promise.race([\n\t\t\tafterMergedStreamFinished(onFinished, stream, controller),\n\t\t\tonInputStreamEnd({\n\t\t\t\tpassThroughStream,\n\t\t\t\tstream,\n\t\t\t\tstreams,\n\t\t\t\tended,\n\t\t\t\taborted,\n\t\t\t\tcontroller,\n\t\t\t}),\n\t\t\tonInputStreamUnpipe({\n\t\t\t\tstream,\n\t\t\t\tstreams,\n\t\t\t\tended,\n\t\t\t\taborted,\n\t\t\t\tunpipeEvent,\n\t\t\t\tcontroller,\n\t\t\t}),\n\t\t]);\n\t} finally {\n\t\tcontroller.abort();\n\t\tupdateMaxListeners(passThroughStream, -PASSTHROUGH_LISTENERS_PER_STREAM);\n\t}\n\n\tif (streams.size > 0 && streams.size === ended.size + aborted.size) {\n\t\tif (ended.size === 0 && aborted.size > 0) {\n\t\t\tabortStream(passThroughStream);\n\t\t} else {\n\t\t\tendStream(passThroughStream);\n\t\t}\n\t}\n};\n\nconst afterMergedStreamFinished = async (onFinished, stream, {signal}) => {\n\ttry {\n\t\tawait onFinished;\n\t\tif (!signal.aborted) {\n\t\t\tabortStream(stream);\n\t\t}\n\t} catch (error) {\n\t\tif (!signal.aborted) {\n\t\t\terrorOrAbortStream(stream, error);\n\t\t}\n\t}\n};\n\nconst onInputStreamEnd = async ({passThroughStream, stream, streams, ended, aborted, controller: {signal}}) => {\n\ttry {\n\t\tawait finished(stream, {\n\t\t\tsignal,\n\t\t\tcleanup: true,\n\t\t\treadable: true,\n\t\t\twritable: false,\n\t\t});\n\t\tif (streams.has(stream)) {\n\t\t\tended.add(stream);\n\t\t}\n\t} catch (error) {\n\t\tif (signal.aborted || !streams.has(stream)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (isAbortError(error)) {\n\t\t\taborted.add(stream);\n\t\t} else {\n\t\t\terrorStream(passThroughStream, error);\n\t\t}\n\t}\n};\n\nconst onInputStreamUnpipe = async ({stream, streams, ended, aborted, unpipeEvent, controller: {signal}}) => {\n\tawait once(stream, unpipeEvent, {signal});\n\n\tif (!stream.readable) {\n\t\treturn once(signal, 'abort', {signal});\n\t}\n\n\tstreams.delete(stream);\n\tended.delete(stream);\n\taborted.delete(stream);\n};\n\nconst endStream = stream => {\n\tif (stream.writable) {\n\t\tstream.end();\n\t}\n};\n\nconst errorOrAbortStream = (stream, error) => {\n\tif (isAbortError(error)) {\n\t\tabortStream(stream);\n\t} else {\n\t\terrorStream(stream, error);\n\t}\n};\n\n// This is the error thrown by `finished()` on `stream.destroy()`\nconst isAbortError = error => error?.code === 'ERR_STREAM_PREMATURE_CLOSE';\n\nconst abortStream = stream => {\n\tif (stream.readable || stream.writable) {\n\t\tstream.destroy();\n\t}\n};\n\n// `stream.destroy(error)` crashes the process with `uncaughtException` if no `error` event listener exists on `stream`.\n// We take care of error handling on user behalf, so we do not want this to happen.\nconst errorStream = (stream, error) => {\n\tif (!stream.destroyed) {\n\t\tstream.once('error', noop);\n\t\tstream.destroy(error);\n\t}\n};\n\nconst noop = () => {};\n\nconst updateMaxListeners = (passThroughStream, increment) => {\n\tconst maxListeners = passThroughStream.getMaxListeners();\n\tif (maxListeners !== 0 && maxListeners !== Number.POSITIVE_INFINITY) {\n\t\tpassThroughStream.setMaxListeners(maxListeners + increment);\n\t}\n};\n\n// Number of times `passThroughStream.on()` is called regardless of streams:\n//  - once due to `finished(passThroughStream)`\n//  - once due to `on(passThroughStream)`\nconst PASSTHROUGH_LISTENERS_COUNT = 2;\n\n// Number of times `passThroughStream.on()` is called per stream:\n//  - once due to `stream.pipe(passThroughStream)`\nconst PASSTHROUGH_LISTENERS_PER_STREAM = 1;\n", "import {finished} from 'node:stream/promises';\nimport {isStandardStream} from '../utils/standard-stream.js';\n\n// Similar to `Stream.pipeline(source, destination)`, but does not destroy standard streams\nexport const pipeStreams = (source, destination) => {\n\tsource.pipe(destination);\n\tonSourceFinish(source, destination);\n\tonDestinationFinish(source, destination);\n};\n\n// `source.pipe(destination)` makes `destination` end when `source` ends.\n// But it does not propagate aborts or errors. This function does it.\nconst onSourceFinish = async (source, destination) => {\n\tif (isStandardStream(source) || isStandardStream(destination)) {\n\t\treturn;\n\t}\n\n\ttry {\n\t\tawait finished(source, {cleanup: true, readable: true, writable: false});\n\t} catch {}\n\n\tendDestinationStream(destination);\n};\n\nexport const endDestinationStream = destination => {\n\tif (destination.writable) {\n\t\tdestination.end();\n\t}\n};\n\n// We do the same thing in the other direction as well.\nconst onDestinationFinish = async (source, destination) => {\n\tif (isStandardStream(source) || isStandardStream(destination)) {\n\t\treturn;\n\t}\n\n\ttry {\n\t\tawait finished(destination, {cleanup: true, readable: false, writable: true});\n\t} catch {}\n\n\tabortSourceStream(source);\n};\n\nexport const abortSourceStream = source => {\n\tif (source.readable) {\n\t\tsource.destroy();\n\t}\n};\n", "import mergeStreams from '@sindresorhus/merge-streams';\nimport {isStandardStream} from '../utils/standard-stream.js';\nimport {incrementMaxListeners} from '../utils/max-listeners.js';\nimport {TRANSFORM_TYPES} from '../stdio/type.js';\nimport {pipeStreams} from './pipeline.js';\n\n// Handle `input`, `inputFile`, `stdin`, `stdout` and `stderr` options, after spawning, in async mode\n// When multiple input streams are used, we merge them to ensure the output stream ends only once each input stream has ended\nexport const pipeOutputAsync = (subprocess, fileDescriptors, controller) => {\n\tconst pipeGroups = new Map();\n\n\tfor (const [fdNumber, {stdioItems, direction}] of Object.entries(fileDescriptors)) {\n\t\tfor (const {stream} of stdioItems.filter(({type}) => TRANSFORM_TYPES.has(type))) {\n\t\t\tpipeTransform(subprocess, stream, direction, fdNumber);\n\t\t}\n\n\t\tfor (const {stream} of stdioItems.filter(({type}) => !TRANSFORM_TYPES.has(type))) {\n\t\t\tpipeStdioItem({\n\t\t\t\tsubprocess,\n\t\t\t\tstream,\n\t\t\t\tdirection,\n\t\t\t\tfdNumber,\n\t\t\t\tpipeGroups,\n\t\t\t\tcontroller,\n\t\t\t});\n\t\t}\n\t}\n\n\tfor (const [outputStream, inputStreams] of pipeGroups.entries()) {\n\t\tconst inputStream = inputStreams.length === 1 ? inputStreams[0] : mergeStreams(inputStreams);\n\t\tpipeStreams(inputStream, outputStream);\n\t}\n};\n\n// When using transforms, `subprocess.stdin|stdout|stderr|stdio` is directly mutated\nconst pipeTransform = (subprocess, stream, direction, fdNumber) => {\n\tif (direction === 'output') {\n\t\tpipeStreams(subprocess.stdio[fdNumber], stream);\n\t} else {\n\t\tpipeStreams(stream, subprocess.stdio[fdNumber]);\n\t}\n\n\tconst streamProperty = SUBPROCESS_STREAM_PROPERTIES[fdNumber];\n\tif (streamProperty !== undefined) {\n\t\tsubprocess[streamProperty] = stream;\n\t}\n\n\tsubprocess.stdio[fdNumber] = stream;\n};\n\nconst SUBPROCESS_STREAM_PROPERTIES = ['stdin', 'stdout', 'stderr'];\n\n// Most `std*` option values involve piping `subprocess.std*` to a stream.\n// The stream is either passed by the user or created internally.\nconst pipeStdioItem = ({subprocess, stream, direction, fdNumber, pipeGroups, controller}) => {\n\tif (stream === undefined) {\n\t\treturn;\n\t}\n\n\tsetStandardStreamMaxListeners(stream, controller);\n\n\tconst [inputStream, outputStream] = direction === 'output'\n\t\t? [stream, subprocess.stdio[fdNumber]]\n\t\t: [subprocess.stdio[fdNumber], stream];\n\tconst outputStreams = pipeGroups.get(inputStream) ?? [];\n\tpipeGroups.set(inputStream, [...outputStreams, outputStream]);\n};\n\n// Multiple subprocesses might be piping from/to `process.std*` at the same time.\n// This is not necessarily an error and should not print a `maxListeners` warning.\nconst setStandardStreamMaxListeners = (stream, {signal}) => {\n\tif (isStandardStream(stream)) {\n\t\tincrementMaxListeners(stream, MAX_LISTENERS_INCREMENT, signal);\n\t}\n};\n\n// `source.pipe(destination)` adds at most 1 listener for each event.\n// If `stdin` option is an array, the values might be combined with `merge-streams`.\n// That library also listens for `source` end, which adds 1 more listener.\nconst MAX_LISTENERS_INCREMENT = 2;\n", "/**\n * This is not the set of all possible signals.\n *\n * It IS, however, the set of all signals that trigger\n * an exit on either Linux or BSD systems.  Linux is a\n * superset of the signal names supported on BSD, and\n * the unknown signals just fail to register, so we can\n * catch that easily enough.\n *\n * Windows signals are a different set, since there are\n * signals that terminate Windows processes, but don't\n * terminate (or don't even exist) on Posix systems.\n *\n * Don't bother with SIGKILL.  It's uncatchable, which\n * means that we can't fire any callbacks anyway.\n *\n * If a user does happen to register a handler on a non-\n * fatal signal like SIGWINCH or something, and then\n * exit, it'll end up firing `process.emit('exit')`, so\n * the handler will be fired anyway.\n *\n * SIGBUS, SIGFPE, SIGSEGV and SIGILL, when not raised\n * artificially, inherently leave the process in a\n * state from which it is not safe to try and enter JS\n * listeners.\n */\nexport const signals: NodeJS.Signals[] = []\nsignals.push('SIGHUP', 'SIGINT', 'SIGTERM')\n\nif (process.platform !== 'win32') {\n  signals.push(\n    'SIGALRM',\n    'SIGABRT',\n    'SIGVTALRM',\n    'SIGXCPU',\n    'SIGXFSZ',\n    'SIGUSR2',\n    'SIGTRAP',\n    'SIGSYS',\n    'SIGQUIT',\n    'SIGIOT'\n    // should detect profiler and enable/disable accordingly.\n    // see #21\n    // 'SIGPROF'\n  )\n}\n\nif (process.platform === 'linux') {\n  signals.push('SIGIO', 'SIGPOLL', 'SIGPWR', 'SIGSTKFLT')\n}\n", "// Note: since nyc uses this module to output coverage, any lines\n// that are in the direct sync flow of nyc's outputCoverage are\n// ignored, since we can never get coverage for them.\n// grab a reference to node's real process object right away\nimport { signals } from './signals.js'\nexport { signals }\n\n// just a loosened process type so we can do some evil things\ntype ProcessRE = NodeJS.Process & {\n  reallyExit: (code?: number | undefined | null) => any\n  emit: (ev: string, ...a: any[]) => any\n}\n\nconst processOk = (process: any): process is ProcessRE =>\n  !!process &&\n  typeof process === 'object' &&\n  typeof process.removeListener === 'function' &&\n  typeof process.emit === 'function' &&\n  typeof process.reallyExit === 'function' &&\n  typeof process.listeners === 'function' &&\n  typeof process.kill === 'function' &&\n  typeof process.pid === 'number' &&\n  typeof process.on === 'function'\n\nconst kExitEmitter = Symbol.for('signal-exit emitter')\nconst global: typeof globalThis & { [kExitEmitter]?: Emitter } = globalThis\nconst ObjectDefineProperty = Object.defineProperty.bind(Object)\n\n/**\n * A function that takes an exit code and signal as arguments\n *\n * In the case of signal exits *only*, a return value of true\n * will indicate that the signal is being handled, and we should\n * not synthetically exit with the signal we received. Regardless\n * of the handler return value, the handler is unloaded when an\n * otherwise fatal signal is received, so you get exactly 1 shot\n * at it, unless you add another onExit handler at that point.\n *\n * In the case of numeric code exits, we may already have committed\n * to exiting the process, for example via a fatal exception or\n * unhandled promise rejection, so it is impossible to stop safely.\n */\nexport type Handler = (\n  code: number | null | undefined,\n  signal: NodeJS.Signals | null\n) => true | void\ntype ExitEvent = 'afterExit' | 'exit'\ntype Emitted = { [k in ExitEvent]: boolean }\ntype Listeners = { [k in ExitEvent]: Handler[] }\n\n// teeny special purpose ee\nclass Emitter {\n  emitted: Emitted = {\n    afterExit: false,\n    exit: false,\n  }\n\n  listeners: Listeners = {\n    afterExit: [],\n    exit: [],\n  }\n\n  count: number = 0\n  id: number = Math.random()\n\n  constructor() {\n    if (global[kExitEmitter]) {\n      return global[kExitEmitter]\n    }\n    ObjectDefineProperty(global, kExitEmitter, {\n      value: this,\n      writable: false,\n      enumerable: false,\n      configurable: false,\n    })\n  }\n\n  on(ev: ExitEvent, fn: Handler) {\n    this.listeners[ev].push(fn)\n  }\n\n  removeListener(ev: ExitEvent, fn: Handler) {\n    const list = this.listeners[ev]\n    const i = list.indexOf(fn)\n    /* c8 ignore start */\n    if (i === -1) {\n      return\n    }\n    /* c8 ignore stop */\n    if (i === 0 && list.length === 1) {\n      list.length = 0\n    } else {\n      list.splice(i, 1)\n    }\n  }\n\n  emit(\n    ev: ExitEvent,\n    code: number | null | undefined,\n    signal: NodeJS.Signals | null\n  ): boolean {\n    if (this.emitted[ev]) {\n      return false\n    }\n    this.emitted[ev] = true\n    let ret: boolean = false\n    for (const fn of this.listeners[ev]) {\n      ret = fn(code, signal) === true || ret\n    }\n    if (ev === 'exit') {\n      ret = this.emit('afterExit', code, signal) || ret\n    }\n    return ret\n  }\n}\n\nabstract class SignalExitBase {\n  abstract onExit(cb: Handler, opts?: { alwaysLast?: boolean }): () => void\n  abstract load(): void\n  abstract unload(): void\n}\n\nconst signalExitWrap = <T extends SignalExitBase>(handler: T) => {\n  return {\n    onExit(cb: Handler, opts?: { alwaysLast?: boolean }) {\n      return handler.onExit(cb, opts)\n    },\n    load() {\n      return handler.load()\n    },\n    unload() {\n      return handler.unload()\n    },\n  }\n}\n\nclass SignalExitFallback extends SignalExitBase {\n  onExit() {\n    return () => {}\n  }\n  load() {}\n  unload() {}\n}\n\nclass SignalExit extends SignalExitBase {\n  // \"SIGHUP\" throws an `ENOSYS` error on Windows,\n  // so use a supported signal instead\n  /* c8 ignore start */\n  #hupSig = process.platform === 'win32' ? 'SIGINT' : 'SIGHUP'\n  /* c8 ignore stop */\n  #emitter = new Emitter()\n  #process: ProcessRE\n  #originalProcessEmit: ProcessRE['emit']\n  #originalProcessReallyExit: ProcessRE['reallyExit']\n\n  #sigListeners: { [k in NodeJS.Signals]?: () => void } = {}\n  #loaded: boolean = false\n\n  constructor(process: ProcessRE) {\n    super()\n    this.#process = process\n    // { <signal>: <listener fn>, ... }\n    this.#sigListeners = {}\n    for (const sig of signals) {\n      this.#sigListeners[sig] = () => {\n        // If there are no other listeners, an exit is coming!\n        // Simplest way: remove us and then re-send the signal.\n        // We know that this will kill the process, so we can\n        // safely emit now.\n        const listeners = this.#process.listeners(sig)\n        let { count } = this.#emitter\n        // This is a workaround for the fact that signal-exit v3 and signal\n        // exit v4 are not aware of each other, and each will attempt to let\n        // the other handle it, so neither of them do. To correct this, we\n        // detect if we're the only handler *except* for previous versions\n        // of signal-exit, and increment by the count of listeners it has\n        // created.\n        /* c8 ignore start */\n        const p = process as unknown as {\n          __signal_exit_emitter__?: { count: number }\n        }\n        if (\n          typeof p.__signal_exit_emitter__ === 'object' &&\n          typeof p.__signal_exit_emitter__.count === 'number'\n        ) {\n          count += p.__signal_exit_emitter__.count\n        }\n        /* c8 ignore stop */\n        if (listeners.length === count) {\n          this.unload()\n          const ret = this.#emitter.emit('exit', null, sig)\n          /* c8 ignore start */\n          const s = sig === 'SIGHUP' ? this.#hupSig : sig\n          if (!ret) process.kill(process.pid, s)\n          /* c8 ignore stop */\n        }\n      }\n    }\n\n    this.#originalProcessReallyExit = process.reallyExit\n    this.#originalProcessEmit = process.emit\n  }\n\n  onExit(cb: Handler, opts?: { alwaysLast?: boolean }) {\n    /* c8 ignore start */\n    if (!processOk(this.#process)) {\n      return () => {}\n    }\n    /* c8 ignore stop */\n\n    if (this.#loaded === false) {\n      this.load()\n    }\n\n    const ev = opts?.alwaysLast ? 'afterExit' : 'exit'\n    this.#emitter.on(ev, cb)\n    return () => {\n      this.#emitter.removeListener(ev, cb)\n      if (\n        this.#emitter.listeners['exit'].length === 0 &&\n        this.#emitter.listeners['afterExit'].length === 0\n      ) {\n        this.unload()\n      }\n    }\n  }\n\n  load() {\n    if (this.#loaded) {\n      return\n    }\n    this.#loaded = true\n\n    // This is the number of onSignalExit's that are in play.\n    // It's important so that we can count the correct number of\n    // listeners on signals, and don't wait for the other one to\n    // handle it instead of us.\n    this.#emitter.count += 1\n\n    for (const sig of signals) {\n      try {\n        const fn = this.#sigListeners[sig]\n        if (fn) this.#process.on(sig, fn)\n      } catch (_) {}\n    }\n\n    this.#process.emit = (ev: string, ...a: any[]) => {\n      return this.#processEmit(ev, ...a)\n    }\n    this.#process.reallyExit = (code?: number | null | undefined) => {\n      return this.#processReallyExit(code)\n    }\n  }\n\n  unload() {\n    if (!this.#loaded) {\n      return\n    }\n    this.#loaded = false\n\n    signals.forEach(sig => {\n      const listener = this.#sigListeners[sig]\n      /* c8 ignore start */\n      if (!listener) {\n        throw new Error('Listener not defined for signal: ' + sig)\n      }\n      /* c8 ignore stop */\n      try {\n        this.#process.removeListener(sig, listener)\n        /* c8 ignore start */\n      } catch (_) {}\n      /* c8 ignore stop */\n    })\n    this.#process.emit = this.#originalProcessEmit\n    this.#process.reallyExit = this.#originalProcessReallyExit\n    this.#emitter.count -= 1\n  }\n\n  #processReallyExit(code?: number | null | undefined) {\n    /* c8 ignore start */\n    if (!processOk(this.#process)) {\n      return 0\n    }\n    this.#process.exitCode = code || 0\n    /* c8 ignore stop */\n\n    this.#emitter.emit('exit', this.#process.exitCode, null)\n    return this.#originalProcessReallyExit.call(\n      this.#process,\n      this.#process.exitCode\n    )\n  }\n\n  #processEmit(ev: string, ...args: any[]): any {\n    const og = this.#originalProcessEmit\n    if (ev === 'exit' && processOk(this.#process)) {\n      if (typeof args[0] === 'number') {\n        this.#process.exitCode = args[0]\n        /* c8 ignore start */\n      }\n      /* c8 ignore start */\n      const ret = og.call(this.#process, ev, ...args)\n      /* c8 ignore start */\n      this.#emitter.emit('exit', this.#process.exitCode, null)\n      /* c8 ignore stop */\n      return ret\n    } else {\n      return og.call(this.#process, ev, ...args)\n    }\n  }\n}\n\nconst process = globalThis.process\n// wrap so that we call the method on the actual handler, without\n// exporting it directly.\nexport const {\n  /**\n   * Called when the process is exiting, whether via signal, explicit\n   * exit, or running out of stuff to do.\n   *\n   * If the global process object is not suitable for instrumentation,\n   * then this will be a no-op.\n   *\n   * Returns a function that may be used to unload signal-exit.\n   */\n  onExit,\n\n  /**\n   * Load the listeners.  Likely you never need to call this, unless\n   * doing a rather deep integration with signal-exit functionality.\n   * Mostly exposed for the benefit of testing.\n   *\n   * @internal\n   */\n  load,\n\n  /**\n   * Unload the listeners.  Likely you never need to call this, unless\n   * doing a rather deep integration with signal-exit functionality.\n   * Mostly exposed for the benefit of testing.\n   *\n   * @internal\n   */\n  unload,\n} = signalExitWrap(\n  processOk(process) ? new SignalExit(process) : new SignalExitFallback()\n)\n", "import {addAbortListener} from 'node:events';\nimport {onExit} from 'signal-exit';\n\n// If the `cleanup` option is used, call `subprocess.kill()` when the parent process exits\nexport const cleanupOnExit = (subprocess, {cleanup, detached}, {signal}) => {\n\tif (!cleanup || detached) {\n\t\treturn;\n\t}\n\n\tconst removeExitHandler = onExit(() => {\n\t\tsubprocess.kill();\n\t});\n\taddAbortListener(signal, () => {\n\t\tremoveExitHandler();\n\t});\n};\n", "import {normalizeParameters} from '../methods/parameters.js';\nimport {getStartTime} from '../return/duration.js';\nimport {SUBPROCESS_OPTIONS, getToStream, getFromStream} from '../arguments/fd-options.js';\nimport {isDenoExecPath} from '../arguments/file-url.js';\n\n// Normalize and validate arguments passed to `source.pipe(destination)`\nexport const normalizePipeArguments = ({source, sourcePromise, boundOptions, createNested}, ...pipeArguments) => {\n\tconst startTime = getStartTime();\n\tconst {\n\t\tdestination,\n\t\tdestinationStream,\n\t\tdestinationError,\n\t\tfrom,\n\t\tunpipeSignal,\n\t} = getDestinationStream(boundOptions, createNested, pipeArguments);\n\tconst {sourceStream, sourceError} = getSourceStream(source, from);\n\tconst {options: sourceOptions, fileDescriptors} = SUBPROCESS_OPTIONS.get(source);\n\treturn {\n\t\tsourcePromise,\n\t\tsourceStream,\n\t\tsourceOptions,\n\t\tsourceError,\n\t\tdestination,\n\t\tdestinationStream,\n\t\tdestinationError,\n\t\tunpipeSignal,\n\t\tfileDescriptors,\n\t\tstartTime,\n\t};\n};\n\nconst getDestinationStream = (boundOptions, createNested, pipeArguments) => {\n\ttry {\n\t\tconst {\n\t\t\tdestination,\n\t\t\tpipeOptions: {from, to, unpipeSignal} = {},\n\t\t} = getDestination(boundOptions, createNested, ...pipeArguments);\n\t\tconst destinationStream = getToStream(destination, to);\n\t\treturn {\n\t\t\tdestination,\n\t\t\tdestinationStream,\n\t\t\tfrom,\n\t\t\tunpipeSignal,\n\t\t};\n\t} catch (error) {\n\t\treturn {destinationError: error};\n\t}\n};\n\n// Piping subprocesses can use three syntaxes:\n//  - source.pipe('command', commandArguments, pipeOptionsOrDestinationOptions)\n//  - source.pipe`command commandArgument` or source.pipe(pipeOptionsOrDestinationOptions)`command commandArgument`\n//  - source.pipe(execa(...), pipeOptions)\nconst getDestination = (boundOptions, createNested, firstArgument, ...pipeArguments) => {\n\tif (Array.isArray(firstArgument)) {\n\t\tconst destination = createNested(mapDestinationArguments, boundOptions)(firstArgument, ...pipeArguments);\n\t\treturn {destination, pipeOptions: boundOptions};\n\t}\n\n\tif (typeof firstArgument === 'string' || firstArgument instanceof URL || isDenoExecPath(firstArgument)) {\n\t\tif (Object.keys(boundOptions).length > 0) {\n\t\t\tthrow new TypeError('Please use .pipe(\"file\", ..., options) or .pipe(execa(\"file\", ..., options)) instead of .pipe(options)(\"file\", ...).');\n\t\t}\n\n\t\tconst [rawFile, rawArguments, rawOptions] = normalizeParameters(firstArgument, ...pipeArguments);\n\t\tconst destination = createNested(mapDestinationArguments)(rawFile, rawArguments, rawOptions);\n\t\treturn {destination, pipeOptions: rawOptions};\n\t}\n\n\tif (SUBPROCESS_OPTIONS.has(firstArgument)) {\n\t\tif (Object.keys(boundOptions).length > 0) {\n\t\t\tthrow new TypeError('Please use .pipe(options)`command` or .pipe($(options)`command`) instead of .pipe(options)($`command`).');\n\t\t}\n\n\t\treturn {destination: firstArgument, pipeOptions: pipeArguments[0]};\n\t}\n\n\tthrow new TypeError(`The first argument must be a template string, an options object, or an Execa subprocess: ${firstArgument}`);\n};\n\n// Force `stdin: 'pipe'` with the destination subprocess\nconst mapDestinationArguments = ({options}) => ({options: {...options, stdin: 'pipe', piped: true}});\n\nconst getSourceStream = (source, from) => {\n\ttry {\n\t\tconst sourceStream = getFromStream(source, from);\n\t\treturn {sourceStream};\n\t} catch (error) {\n\t\treturn {sourceError: error};\n\t}\n};\n", "import {makeEarlyError} from '../return/result.js';\nimport {abortSourceStream, endDestinationStream} from '../io/pipeline.js';\n\n// When passing invalid arguments to `source.pipe()`, throw asynchronously.\n// We also abort both subprocesses.\nexport const handlePipeArgumentsError = ({\n\tsourceStream,\n\tsourceError,\n\tdestinationStream,\n\tdestinationError,\n\tfileDescriptors,\n\tsourceOptions,\n\tstartTime,\n}) => {\n\tconst error = getPipeArgumentsError({\n\t\tsourceStream,\n\t\tsourceError,\n\t\tdestinationStream,\n\t\tdestinationError,\n\t});\n\tif (error !== undefined) {\n\t\tthrow createNonCommandError({\n\t\t\terror,\n\t\t\tfileDescriptors,\n\t\t\tsourceOptions,\n\t\t\tstartTime,\n\t\t});\n\t}\n};\n\nconst getPipeArgumentsError = ({sourceStream, sourceError, destinationStream, destinationError}) => {\n\tif (sourceError !== undefined && destinationError !== undefined) {\n\t\treturn destinationError;\n\t}\n\n\tif (destinationError !== undefined) {\n\t\tabortSourceStream(sourceStream);\n\t\treturn destinationError;\n\t}\n\n\tif (sourceError !== undefined) {\n\t\tendDestinationStream(destinationStream);\n\t\treturn sourceError;\n\t}\n};\n\n// Specific error return value when passing invalid arguments to `subprocess.pipe()` or when using `unpipeSignal`\nexport const createNonCommandError = ({error, fileDescriptors, sourceOptions, startTime}) => makeEarlyError({\n\terror,\n\tcommand: PIPE_COMMAND_MESSAGE,\n\tescapedCommand: PIPE_COMMAND_MESSAGE,\n\tfileDescriptors,\n\toptions: sourceOptions,\n\tstartTime,\n\tisSync: false,\n});\n\nconst PIPE_COMMAND_MESSAGE = 'source.pipe(destination)';\n", "// Like Bash, we await both subprocesses. This is unlike some other shells which only await the destination subprocess.\n// Like Bash with the `pipefail` option, if either subprocess fails, the whole pipe fails.\n// Like Bash, if both subprocesses fail, we return the failure of the destination.\n// This ensures both subprocesses' errors are present, using `error.pipedFrom`.\nexport const waitForBothSubprocesses = async subprocessPromises => {\n\tconst [\n\t\t{status: sourceStatus, reason: sourceReason, value: sourceResult = sourceReason},\n\t\t{status: destinationStatus, reason: destinationReason, value: destinationResult = destinationReason},\n\t] = await subprocessPromises;\n\n\tif (!destinationResult.pipedFrom.includes(sourceResult)) {\n\t\tdestinationResult.pipedFrom.push(sourceResult);\n\t}\n\n\tif (destinationStatus === 'rejected') {\n\t\tthrow destinationResult;\n\t}\n\n\tif (sourceStatus === 'rejected') {\n\t\tthrow sourceResult;\n\t}\n\n\treturn destinationResult;\n};\n", "import {finished} from 'node:stream/promises';\nimport mergeStreams from '@sindresorhus/merge-streams';\nimport {incrementMaxListeners} from '../utils/max-listeners.js';\nimport {pipeStreams} from '../io/pipeline.js';\n\n// The piping behavior is like Bash.\n// In particular, when one subprocess exits, the other is not terminated by a signal.\n// Instead, its stdout (for the source) or stdin (for the destination) closes.\n// If the subprocess uses it, it will make it error with SIGPIPE or EPIPE (for the source) or end (for the destination).\n// If it does not use it, it will continue running.\n// This allows for subprocesses to gracefully exit and lower the coupling between subprocesses.\nexport const pipeSubprocessStream = (sourceStream, destinationStream, maxListenersController) => {\n\tconst mergedStream = MERGED_STREAMS.has(destinationStream)\n\t\t? pipeMoreSubprocessStream(sourceStream, destinationStream)\n\t\t: pipeFirstSubprocessStream(sourceStream, destinationStream);\n\tincrementMaxListeners(sourceStream, SOURCE_LISTENERS_PER_PIPE, maxListenersController.signal);\n\tincrementMaxListeners(destinationStream, DESTINATION_LISTENERS_PER_PIPE, maxListenersController.signal);\n\tcleanupMergedStreamsMap(destinationStream);\n\treturn mergedStream;\n};\n\n// We use `merge-streams` to allow for multiple sources to pipe to the same destination.\nconst pipeFirstSubprocessStream = (sourceStream, destinationStream) => {\n\tconst mergedStream = mergeStreams([sourceStream]);\n\tpipeStreams(mergedStream, destinationStream);\n\tMERGED_STREAMS.set(destinationStream, mergedStream);\n\treturn mergedStream;\n};\n\nconst pipeMoreSubprocessStream = (sourceStream, destinationStream) => {\n\tconst mergedStream = MERGED_STREAMS.get(destinationStream);\n\tmergedStream.add(sourceStream);\n\treturn mergedStream;\n};\n\nconst cleanupMergedStreamsMap = async destinationStream => {\n\ttry {\n\t\tawait finished(destinationStream, {cleanup: true, readable: false, writable: true});\n\t} catch {}\n\n\tMERGED_STREAMS.delete(destinationStream);\n};\n\nconst MERGED_STREAMS = new WeakMap();\n\n// Number of listeners set up on `sourceStream` by each `sourceStream.pipe(destinationStream)`\n// Those are added by `merge-streams`\nconst SOURCE_LISTENERS_PER_PIPE = 2;\n// Number of listeners set up on `destinationStream` by each `sourceStream.pipe(destinationStream)`\n// Those are added by `finished()` in `cleanupMergedStreamsMap()`\nconst DESTINATION_LISTENERS_PER_PIPE = 1;\n", "import {aborted} from 'node:util';\nimport {createNonCommandError} from './throw.js';\n\n// When passing an `unpipeSignal` option, abort piping when the signal is aborted.\n// However, do not terminate the subprocesses.\nexport const unpipeOnAbort = (unpipeSignal, unpipeContext) => unpipeSignal === undefined\n\t? []\n\t: [unpipeOnSignalAbort(unpipeSignal, unpipeContext)];\n\nconst unpipeOnSignalAbort = async (unpipeSignal, {sourceStream, mergedStream, fileDescriptors, sourceOptions, startTime}) => {\n\tawait aborted(unpipeSignal, sourceStream);\n\tawait mergedStream.remove(sourceStream);\n\tconst error = new Error('Pipe canceled by `unpipeSignal` option.');\n\tthrow createNonCommandError({\n\t\terror,\n\t\tfileDescriptors,\n\t\tsourceOptions,\n\t\tstartTime,\n\t});\n};\n", "import isPlainObject from 'is-plain-obj';\nimport {normalizePipeArguments} from './pipe-arguments.js';\nimport {handlePipeArgumentsError} from './throw.js';\nimport {waitForBothSubprocesses} from './sequence.js';\nimport {pipeSubprocessStream} from './streaming.js';\nimport {unpipeOnAbort} from './abort.js';\n\n// Pipe a subprocess' `stdout`/`stderr`/`stdio` into another subprocess' `stdin`\nexport const pipeToSubprocess = (sourceInfo, ...pipeArguments) => {\n\tif (isPlainObject(pipeArguments[0])) {\n\t\treturn pipeToSubprocess.bind(undefined, {\n\t\t\t...sourceInfo,\n\t\t\tboundOptions: {...sourceInfo.boundOptions, ...pipeArguments[0]},\n\t\t});\n\t}\n\n\tconst {destination, ...normalizedInfo} = normalizePipeArguments(sourceInfo, ...pipeArguments);\n\tconst promise = handlePipePromise({...normalizedInfo, destination});\n\tpromise.pipe = pipeToSubprocess.bind(undefined, {\n\t\t...sourceInfo,\n\t\tsource: destination,\n\t\tsourcePromise: promise,\n\t\tboundOptions: {},\n\t});\n\treturn promise;\n};\n\n// Asynchronous logic when piping subprocesses\nconst handlePipePromise = async ({\n\tsourcePromise,\n\tsourceStream,\n\tsourceOptions,\n\tsourceError,\n\tdestination,\n\tdestinationStream,\n\tdestinationError,\n\tunpipeSignal,\n\tfileDescriptors,\n\tstartTime,\n}) => {\n\tconst subprocessPromises = getSubprocessPromises(sourcePromise, destination);\n\thandlePipeArgumentsError({\n\t\tsourceStream,\n\t\tsourceError,\n\t\tdestinationStream,\n\t\tdestinationError,\n\t\tfileDescriptors,\n\t\tsourceOptions,\n\t\tstartTime,\n\t});\n\tconst maxListenersController = new AbortController();\n\ttry {\n\t\tconst mergedStream = pipeSubprocessStream(sourceStream, destinationStream, maxListenersController);\n\t\treturn await Promise.race([\n\t\t\twaitForBothSubprocesses(subprocessPromises),\n\t\t\t...unpipeOnAbort(unpipeSignal, {\n\t\t\t\tsourceStream,\n\t\t\t\tmergedStream,\n\t\t\t\tsourceOptions,\n\t\t\t\tfileDescriptors,\n\t\t\t\tstartTime,\n\t\t\t}),\n\t\t]);\n\t} finally {\n\t\tmaxListenersController.abort();\n\t}\n};\n\n// `.pipe()` awaits the subprocess promises.\n// When invalid arguments are passed to `.pipe()`, we throw an error, which prevents awaiting them.\n// We need to ensure this does not create unhandled rejections.\nconst getSubprocessPromises = (sourcePromise, destination) => Promise.allSettled([sourcePromise, destination]);\n", "import {on} from 'node:events';\nimport {getDefaultHighWaterMark} from 'node:stream';\nimport {getEncodingTransformGenerator} from '../transform/encoding-transform.js';\nimport {getSplitLinesGenerator} from '../transform/split.js';\nimport {transformChunkSync, finalChunksSync} from '../transform/run-sync.js';\n\n// Iterate over lines of `subprocess.stdout`, used by `subprocess.readable|duplex|iterable()`\nexport const iterateOnSubprocessStream = ({subprocessStdout, subprocess, binary, shouldEncode, encoding, preserveNewlines}) => {\n\tconst controller = new AbortController();\n\tstopReadingOnExit(subprocess, controller);\n\treturn iterateOnStream({\n\t\tstream: subprocessStdout,\n\t\tcontroller,\n\t\tbinary,\n\t\tshouldEncode: !subprocessStdout.readableObjectMode && shouldEncode,\n\t\tencoding,\n\t\tshouldSplit: !subprocessStdout.readableObjectMode,\n\t\tpreserveNewlines,\n\t});\n};\n\nconst stopReadingOnExit = async (subprocess, controller) => {\n\ttry {\n\t\tawait subprocess;\n\t} catch {} finally {\n\t\tcontroller.abort();\n\t}\n};\n\n// Iterate over lines of `subprocess.stdout`, used by `result.stdout` and the `verbose: 'full'` option.\n// Applies the `lines` and `encoding` options.\nexport const iterateForResult = ({stream, onStreamEnd, lines, encoding, stripFinalNewline, allMixed}) => {\n\tconst controller = new AbortController();\n\tstopReadingOnStreamEnd(onStreamEnd, controller, stream);\n\tconst objectMode = stream.readableObjectMode && !allMixed;\n\treturn iterateOnStream({\n\t\tstream,\n\t\tcontroller,\n\t\tbinary: encoding === 'buffer',\n\t\tshouldEncode: !objectMode,\n\t\tencoding,\n\t\tshouldSplit: !objectMode && lines,\n\t\tpreserveNewlines: !stripFinalNewline,\n\t});\n};\n\nconst stopReadingOnStreamEnd = async (onStreamEnd, controller, stream) => {\n\ttry {\n\t\tawait onStreamEnd;\n\t} catch {\n\t\tstream.destroy();\n\t} finally {\n\t\tcontroller.abort();\n\t}\n};\n\nconst iterateOnStream = ({stream, controller, binary, shouldEncode, encoding, shouldSplit, preserveNewlines}) => {\n\tconst onStdoutChunk = on(stream, 'data', {\n\t\tsignal: controller.signal,\n\t\thighWaterMark: HIGH_WATER_MARK,\n\t\t// Backward compatibility with older name for this option\n\t\t// See https://github.com/nodejs/node/pull/52080#discussion_r1525227861\n\t\t// @todo Remove after removing support for Node 21\n\t\thighWatermark: HIGH_WATER_MARK,\n\t});\n\treturn iterateOnData({\n\t\tonStdoutChunk,\n\t\tcontroller,\n\t\tbinary,\n\t\tshouldEncode,\n\t\tencoding,\n\t\tshouldSplit,\n\t\tpreserveNewlines,\n\t});\n};\n\nexport const DEFAULT_OBJECT_HIGH_WATER_MARK = getDefaultHighWaterMark(true);\n\n// The `highWaterMark` of `events.on()` is measured in number of events, not in bytes.\n// Not knowing the average amount of bytes per `data` event, we use the same heuristic as streams in objectMode, since they have the same issue.\n// Therefore, we use the value of `getDefaultHighWaterMark(true)`.\n// Note: this option does not exist on Node 18, but this is ok since the logic works without it. It just consumes more memory.\nconst HIGH_WATER_MARK = DEFAULT_OBJECT_HIGH_WATER_MARK;\n\nconst iterateOnData = async function * ({onStdoutChunk, controller, binary, shouldEncode, encoding, shouldSplit, preserveNewlines}) {\n\tconst generators = getGenerators({\n\t\tbinary,\n\t\tshouldEncode,\n\t\tencoding,\n\t\tshouldSplit,\n\t\tpreserveNewlines,\n\t});\n\n\ttry {\n\t\tfor await (const [chunk] of onStdoutChunk) {\n\t\t\tyield * transformChunkSync(chunk, generators, 0);\n\t\t}\n\t} catch (error) {\n\t\tif (!controller.signal.aborted) {\n\t\t\tthrow error;\n\t\t}\n\t} finally {\n\t\tyield * finalChunksSync(generators);\n\t}\n};\n\nconst getGenerators = ({binary, shouldEncode, encoding, shouldSplit, preserveNewlines}) => [\n\tgetEncodingTransformGenerator(binary, encoding, !shouldEncode),\n\tgetSplitLinesGenerator(binary, preserveNewlines, !shouldSplit, {}),\n].filter(Boolean);\n", "import {setImmediate} from 'node:timers/promises';\nimport getStream, {getStreamAsArrayBuffer, getStreamAsArray} from 'get-stream';\nimport {isArrayBuffer} from '../utils/uint-array.js';\nimport {shouldLogOutput, logLines} from '../verbose/output.js';\nimport {iterateForResult} from './iterate.js';\nimport {handleMaxBuffer} from './max-buffer.js';\nimport {getStripFinalNewline} from './strip-newline.js';\n\n// Retrieve `result.stdout|stderr|all|stdio[*]`\nexport const getStreamOutput = async ({stream, onStreamEnd, fdNumber, encoding, buffer, maxBuffer, lines, allMixed, stripFinalNewline, verboseInfo, streamInfo}) => {\n\tconst logPromise = logOutputAsync({\n\t\tstream,\n\t\tonStreamEnd,\n\t\tfdNumber,\n\t\tencoding,\n\t\tallMixed,\n\t\tverboseInfo,\n\t\tstreamInfo,\n\t});\n\n\tif (!buffer) {\n\t\tawait Promise.all([resumeStream(stream), logPromise]);\n\t\treturn;\n\t}\n\n\tconst stripFinalNewlineValue = getStripFinalNewline(stripFinalNewline, fdNumber);\n\tconst iterable = iterateForResult({\n\t\tstream,\n\t\tonStreamEnd,\n\t\tlines,\n\t\tencoding,\n\t\tstripFinalNewline: stripFinalNewlineValue,\n\t\tallMixed,\n\t});\n\tconst [output] = await Promise.all([\n\t\tgetStreamContents({\n\t\t\tstream,\n\t\t\titerable,\n\t\t\tfdNumber,\n\t\t\tencoding,\n\t\t\tmaxBuffer,\n\t\t\tlines,\n\t\t}),\n\t\tlogPromise,\n\t]);\n\treturn output;\n};\n\nconst logOutputAsync = async ({stream, onStreamEnd, fdNumber, encoding, allMixed, verboseInfo, streamInfo: {fileDescriptors}}) => {\n\tif (!shouldLogOutput({\n\t\tstdioItems: fileDescriptors[fdNumber]?.stdioItems,\n\t\tencoding,\n\t\tverboseInfo,\n\t\tfdNumber,\n\t})) {\n\t\treturn;\n\t}\n\n\tconst linesIterable = iterateForResult({\n\t\tstream,\n\t\tonStreamEnd,\n\t\tlines: true,\n\t\tencoding,\n\t\tstripFinalNewline: true,\n\t\tallMixed,\n\t});\n\tawait logLines(linesIterable, stream, fdNumber, verboseInfo);\n};\n\n// When using `buffer: false`, users need to read `subprocess.stdout|stderr|all` right away\n// See https://github.com/sindresorhus/execa/issues/730 and https://github.com/sindresorhus/execa/pull/729#discussion_r1465496310\nconst resumeStream = async stream => {\n\tawait setImmediate();\n\tif (stream.readableFlowing === null) {\n\t\tstream.resume();\n\t}\n};\n\nconst getStreamContents = async ({stream, stream: {readableObjectMode}, iterable, fdNumber, encoding, maxBuffer, lines}) => {\n\ttry {\n\t\tif (readableObjectMode || lines) {\n\t\t\treturn await getStreamAsArray(iterable, {maxBuffer});\n\t\t}\n\n\t\tif (encoding === 'buffer') {\n\t\t\treturn new Uint8Array(await getStreamAsArrayBuffer(iterable, {maxBuffer}));\n\t\t}\n\n\t\treturn await getStream(iterable, {maxBuffer});\n\t} catch (error) {\n\t\treturn handleBufferedData(handleMaxBuffer({\n\t\t\terror,\n\t\t\tstream,\n\t\t\treadableObjectMode,\n\t\t\tlines,\n\t\t\tencoding,\n\t\t\tfdNumber,\n\t\t}));\n\t}\n};\n\n// On failure, `result.stdout|stderr|all` should contain the currently buffered stream\n// They are automatically closed and flushed by Node.js when the subprocess exits\n// When `buffer` is `false`, `streamPromise` is `undefined` and there is no buffered data to retrieve\nexport const getBufferedData = async streamPromise => {\n\ttry {\n\t\treturn await streamPromise;\n\t} catch (error) {\n\t\treturn handleBufferedData(error);\n\t}\n};\n\n// Ensure we are returning Uint8Arrays when using `encoding: 'buffer'`\nconst handleBufferedData = ({bufferedData}) => isArrayBuffer(bufferedData)\n\t? new Uint8Array(bufferedData)\n\t: bufferedData;\n", "import {finished} from 'node:stream/promises';\n\n// Wraps `finished(stream)` to handle the following case:\n//  - When the subprocess exits, Node.js automatically calls `subprocess.stdin.destroy()`, which we need to ignore.\n//  - However, we still need to throw if `subprocess.stdin.destroy()` is called before subprocess exit.\nexport const waitForStream = async (stream, fdNumber, streamInfo, {isSameDirection, stopOnExit = false} = {}) => {\n\tconst state = handleStdinDestroy(stream, streamInfo);\n\tconst abortController = new AbortController();\n\ttry {\n\t\tawait Promise.race([\n\t\t\t...(stopOnExit ? [streamInfo.exitPromise] : []),\n\t\t\tfinished(stream, {cleanup: true, signal: abortController.signal}),\n\t\t]);\n\t} catch (error) {\n\t\tif (!state.stdinCleanedUp) {\n\t\t\thandleStreamError(error, fdNumber, streamInfo, isSameDirection);\n\t\t}\n\t} finally {\n\t\tabortController.abort();\n\t}\n};\n\n// If `subprocess.stdin` is destroyed before being fully written to, it is considered aborted and should throw an error.\n// This can happen for example when user called `subprocess.stdin.destroy()` before `subprocess.stdin.end()`.\n// However, Node.js calls `subprocess.stdin.destroy()` on exit for cleanup purposes.\n// https://github.com/nodejs/node/blob/0b4cdb4b42956cbd7019058e409e06700a199e11/lib/internal/child_process.js#L278\n// This is normal and should not throw an error.\n// Therefore, we need to differentiate between both situations to know whether to throw an error.\n// Unfortunately, events (`close`, `error`, `end`, `exit`) cannot be used because `.destroy()` can take an arbitrary amount of time.\n// For example, `stdin: 'pipe'` is implemented as a TCP socket, and its `.destroy()` method waits for TCP disconnection.\n// Therefore `.destroy()` might end before or after subprocess exit, based on OS speed and load.\n// The only way to detect this is to spy on `subprocess.stdin._destroy()` by wrapping it.\n// If `subprocess.exitCode` or `subprocess.signalCode` is set, it means `.destroy()` is being called by Node.js itself.\nconst handleStdinDestroy = (stream, {originalStreams: [originalStdin], subprocess}) => {\n\tconst state = {stdinCleanedUp: false};\n\tif (stream === originalStdin) {\n\t\tspyOnStdinDestroy(stream, subprocess, state);\n\t}\n\n\treturn state;\n};\n\nconst spyOnStdinDestroy = (subprocessStdin, subprocess, state) => {\n\tconst {_destroy} = subprocessStdin;\n\tsubprocessStdin._destroy = (...destroyArguments) => {\n\t\tsetStdinCleanedUp(subprocess, state);\n\t\t_destroy.call(subprocessStdin, ...destroyArguments);\n\t};\n};\n\nconst setStdinCleanedUp = ({exitCode, signalCode}, state) => {\n\tif (exitCode !== null || signalCode !== null) {\n\t\tstate.stdinCleanedUp = true;\n\t}\n};\n\n// We ignore EPIPEs on writable streams and aborts on readable streams since those can happen normally.\n// When one stream errors, the error is propagated to the other streams on the same file descriptor.\n// Those other streams might have a different direction due to the above.\n// When this happens, the direction of both the initial stream and the others should then be taken into account.\n// Therefore, we keep track of whether a stream error is currently propagating.\nconst handleStreamError = (error, fdNumber, streamInfo, isSameDirection) => {\n\tif (!shouldIgnoreStreamError(error, fdNumber, streamInfo, isSameDirection)) {\n\t\tthrow error;\n\t}\n};\n\nconst shouldIgnoreStreamError = (error, fdNumber, streamInfo, isSameDirection = true) => {\n\tif (streamInfo.propagating) {\n\t\treturn isStreamEpipe(error) || isStreamAbort(error);\n\t}\n\n\tstreamInfo.propagating = true;\n\treturn isInputFileDescriptor(streamInfo, fdNumber) === isSameDirection\n\t\t? isStreamEpipe(error)\n\t\t: isStreamAbort(error);\n};\n\n// Unfortunately, we cannot use the stream's class or properties to know whether it is readable or writable.\n// For example, `subprocess.stdin` is technically a Duplex, but can only be used as a writable.\n// Therefore, we need to use the file descriptor's direction (`stdin` is input, `stdout` is output, etc.).\n// However, while `subprocess.std*` and transforms follow that direction, any stream passed the `std*` option has the opposite direction.\n// For example, `subprocess.stdin` is a writable, but the `stdin` option is a readable.\nexport const isInputFileDescriptor = ({fileDescriptors}, fdNumber) => fdNumber !== 'all' && fileDescriptors[fdNumber].direction === 'input';\n\n// When `stream.destroy()` is called without an `error` argument, stream is aborted.\n// This is the only way to abort a readable stream, which can be useful in some instances.\n// Therefore, we ignore this error on readable streams.\nexport const isStreamAbort = error => error?.code === 'ERR_STREAM_PREMATURE_CLOSE';\n\n// When `stream.write()` is called but the underlying source has been closed, `EPIPE` is emitted.\n// When piping subprocesses, the source subprocess usually decides when to stop piping.\n// However, there are some instances when the destination does instead, such as `... | head -n1`.\n// It notifies the source by using `EPIPE`.\n// Therefore, we ignore this error on writable streams.\nconst isStreamEpipe = error => error?.code === 'EPIPE';\n", "import {getStreamOutput} from '../io/contents.js';\nimport {waitForStream, isInputFileDescriptor} from './wait-stream.js';\n\n// Read the contents of `subprocess.std*` and|or wait for its completion\nexport const waitForStdioStreams = ({subprocess, encoding, buffer, maxBuffer, lines, stripFinalNewline, verboseInfo, streamInfo}) => subprocess.stdio.map((stream, fdNumber) => waitForSubprocessStream({\n\tstream,\n\tfdNumber,\n\tencoding,\n\tbuffer: buffer[fdNumber],\n\tmaxBuffer: maxBuffer[fdNumber],\n\tlines: lines[fdNumber],\n\tallMixed: false,\n\tstripFinalNewline,\n\tverboseInfo,\n\tstreamInfo,\n}));\n\n// Read the contents of `subprocess.std*` or `subprocess.all` and|or wait for its completion\nexport const waitForSubprocessStream = async ({stream, fdNumber, encoding, buffer, maxBuffer, lines, allMixed, stripFinalNewline, verboseInfo, streamInfo}) => {\n\tif (!stream) {\n\t\treturn;\n\t}\n\n\tconst onStreamEnd = waitForStream(stream, fdNumber, streamInfo);\n\tif (isInputFileDescriptor(streamInfo, fdNumber)) {\n\t\tawait onStreamEnd;\n\t\treturn;\n\t}\n\n\tconst [output] = await Promise.all([\n\t\tgetStreamOutput({\n\t\t\tstream,\n\t\t\tonStreamEnd,\n\t\t\tfdNumber,\n\t\t\tencoding,\n\t\t\tbuffer,\n\t\t\tmaxBuffer,\n\t\t\tlines,\n\t\t\tallMixed,\n\t\t\tstripFinalNewline,\n\t\t\tverboseInfo,\n\t\t\tstreamInfo,\n\t\t}),\n\t\tonStreamEnd,\n\t]);\n\treturn output;\n};\n", "import mergeStreams from '@sindresorhus/merge-streams';\nimport {waitForSubprocessStream} from './stdio.js';\n\n// `all` interleaves `stdout` and `stderr`\nexport const makeAllStream = ({stdout, stderr}, {all}) => all && (stdout || stderr)\n\t? mergeStreams([stdout, stderr].filter(Boolean))\n\t: undefined;\n\n// Read the contents of `subprocess.all` and|or wait for its completion\nexport const waitForAllStream = ({subprocess, encoding, buffer, maxBuffer, lines, stripFinalNewline, verboseInfo, streamInfo}) => waitForSubprocessStream({\n\t...getAllStream(subprocess, buffer),\n\tfdNumber: 'all',\n\tencoding,\n\tmaxBuffer: maxBuffer[1] + maxBuffer[2],\n\tlines: lines[1] || lines[2],\n\tallMixed: getAllMixed(subprocess),\n\tstripFinalNewline,\n\tverboseInfo,\n\tstreamInfo,\n});\n\nconst getAllStream = ({stdout, stderr, all}, [, bufferStdout, bufferStderr]) => {\n\tconst buffer = bufferStdout || bufferStderr;\n\tif (!buffer) {\n\t\treturn {stream: all, buffer};\n\t}\n\n\tif (!bufferStdout) {\n\t\treturn {stream: stderr, buffer};\n\t}\n\n\tif (!bufferStderr) {\n\t\treturn {stream: stdout, buffer};\n\t}\n\n\treturn {stream: all, buffer};\n};\n\n// When `subprocess.stdout` is in objectMode but not `subprocess.stderr` (or the opposite), we need to use both:\n//  - `getStreamAsArray()` for the chunks in objectMode, to return as an array without changing each chunk\n//  - `getStreamAsArrayBuffer()` or `getStream()` for the chunks not in objectMode, to convert them from Buffers to string or Uint8Array\n// We do this by emulating the Buffer -> string|Uint8Array conversion performed by `get-stream` with our own, which is identical.\nconst getAllMixed = ({all, stdout, stderr}) => all\n\t&& stdout\n\t&& stderr\n\t&& stdout.readableObjectMode !== stderr.readableObjectMode;\n", "import {verboseLog, serializeVerboseMessage} from './log.js';\nimport {isFullVerbose} from './values.js';\n\n// When `verbose` is `'full'`, print IPC messages from the subprocess\nexport const shouldLogIpc = verboseInfo => isFullVerbose(verboseInfo, 'ipc');\n\nexport const logIpcOutput = (message, verboseInfo) => {\n\tconst verboseMessage = serializeVerboseMessage(message);\n\tverboseLog({\n\t\ttype: 'ipc',\n\t\tverboseMessage,\n\t\tfdNumber: 'ipc',\n\t\tverboseInfo,\n\t});\n};\n", "import {checkIpcMaxBuffer} from '../io/max-buffer.js';\nimport {shouldLogIpc, logIpcOutput} from '../verbose/ipc.js';\nimport {getFdSpecificValue} from '../arguments/specific.js';\nimport {loopOnMessages} from './get-each.js';\n\n// Iterate through IPC messages sent by the subprocess\nexport const waitForIpcOutput = async ({\n\tsubprocess,\n\tbuffer: bufferArray,\n\tmaxBuffer: maxBufferArray,\n\tipc,\n\tipcOutput,\n\tverboseInfo,\n}) => {\n\tif (!ipc) {\n\t\treturn ipcOutput;\n\t}\n\n\tconst isVerbose = shouldLogIpc(verboseInfo);\n\tconst buffer = getFdSpecificValue(bufferArray, 'ipc');\n\tconst maxBuffer = getFdSpecificValue(maxBufferArray, 'ipc');\n\n\tfor await (const message of loopOnMessages({\n\t\tanyProcess: subprocess,\n\t\tchannel: subprocess.channel,\n\t\tisSubprocess: false,\n\t\tipc,\n\t\tshouldAwait: false,\n\t\treference: true,\n\t})) {\n\t\tif (buffer) {\n\t\t\tcheckIpcMaxBuffer(subprocess, ipcOutput, maxBuffer);\n\t\t\tipcOutput.push(message);\n\t\t}\n\n\t\tif (isVerbose) {\n\t\t\tlogIpcOutput(message, verboseInfo);\n\t\t}\n\t}\n\n\treturn ipcOutput;\n};\n\nexport const getBufferedIpcOutput = async (ipcOutputPromise, ipcOutput) => {\n\tawait Promise.allSettled([ipcOutputPromise]);\n\treturn ipcOutput;\n};\n", "import {once} from 'node:events';\nimport {isStream as isNodeStream} from 'is-stream';\nimport {throwOnTimeout} from '../terminate/timeout.js';\nimport {throwOnCancel} from '../terminate/cancel.js';\nimport {throwOnGracefulCancel} from '../terminate/graceful.js';\nimport {isStandardStream} from '../utils/standard-stream.js';\nimport {TRANSFORM_TYPES} from '../stdio/type.js';\nimport {getBufferedData} from '../io/contents.js';\nimport {waitForIpcOutput, getBufferedIpcOutput} from '../ipc/buffer-messages.js';\nimport {sendIpcInput} from '../ipc/ipc-input.js';\nimport {waitForAllStream} from './all-async.js';\nimport {waitForStdioStreams} from './stdio.js';\nimport {waitForExit, waitForSuccessfulExit} from './exit-async.js';\nimport {waitForStream} from './wait-stream.js';\n\n// Retrieve result of subprocess: exit code, signal, error, streams (stdout/stderr/all)\nexport const waitForSubprocessResult = async ({\n\tsubprocess,\n\toptions: {\n\t\tencoding,\n\t\tbuffer,\n\t\tmaxBuffer,\n\t\tlines,\n\t\ttimeoutDuration: timeout,\n\t\tcancelSignal,\n\t\tgracefulCancel,\n\t\tforceKillAfterDelay,\n\t\tstripFinalNewline,\n\t\tipc,\n\t\tipcInput,\n\t},\n\tcontext,\n\tverboseInfo,\n\tfileDescriptors,\n\toriginalStreams,\n\tonInternalError,\n\tcontroller,\n}) => {\n\tconst exitPromise = waitForExit(subprocess, context);\n\tconst streamInfo = {\n\t\toriginalStreams,\n\t\tfileDescriptors,\n\t\tsubprocess,\n\t\texitPromise,\n\t\tpropagating: false,\n\t};\n\n\tconst stdioPromises = waitForStdioStreams({\n\t\tsubprocess,\n\t\tencoding,\n\t\tbuffer,\n\t\tmaxBuffer,\n\t\tlines,\n\t\tstripFinalNewline,\n\t\tverboseInfo,\n\t\tstreamInfo,\n\t});\n\tconst allPromise = waitForAllStream({\n\t\tsubprocess,\n\t\tencoding,\n\t\tbuffer,\n\t\tmaxBuffer,\n\t\tlines,\n\t\tstripFinalNewline,\n\t\tverboseInfo,\n\t\tstreamInfo,\n\t});\n\tconst ipcOutput = [];\n\tconst ipcOutputPromise = waitForIpcOutput({\n\t\tsubprocess,\n\t\tbuffer,\n\t\tmaxBuffer,\n\t\tipc,\n\t\tipcOutput,\n\t\tverboseInfo,\n\t});\n\tconst originalPromises = waitForOriginalStreams(originalStreams, subprocess, streamInfo);\n\tconst customStreamsEndPromises = waitForCustomStreamsEnd(fileDescriptors, streamInfo);\n\n\ttry {\n\t\treturn await Promise.race([\n\t\t\tPromise.all([\n\t\t\t\t{},\n\t\t\t\twaitForSuccessfulExit(exitPromise),\n\t\t\t\tPromise.all(stdioPromises),\n\t\t\t\tallPromise,\n\t\t\t\tipcOutputPromise,\n\t\t\t\tsendIpcInput(subprocess, ipcInput),\n\t\t\t\t...originalPromises,\n\t\t\t\t...customStreamsEndPromises,\n\t\t\t]),\n\t\t\tonInternalError,\n\t\t\tthrowOnSubprocessError(subprocess, controller),\n\t\t\t...throwOnTimeout(subprocess, timeout, context, controller),\n\t\t\t...throwOnCancel({\n\t\t\t\tsubprocess,\n\t\t\t\tcancelSignal,\n\t\t\t\tgracefulCancel,\n\t\t\t\tcontext,\n\t\t\t\tcontroller,\n\t\t\t}),\n\t\t\t...throwOnGracefulCancel({\n\t\t\t\tsubprocess,\n\t\t\t\tcancelSignal,\n\t\t\t\tgracefulCancel,\n\t\t\t\tforceKillAfterDelay,\n\t\t\t\tcontext,\n\t\t\t\tcontroller,\n\t\t\t}),\n\t\t]);\n\t} catch (error) {\n\t\tcontext.terminationReason ??= 'other';\n\t\treturn Promise.all([\n\t\t\t{error},\n\t\t\texitPromise,\n\t\t\tPromise.all(stdioPromises.map(stdioPromise => getBufferedData(stdioPromise))),\n\t\t\tgetBufferedData(allPromise),\n\t\t\tgetBufferedIpcOutput(ipcOutputPromise, ipcOutput),\n\t\t\tPromise.allSettled(originalPromises),\n\t\t\tPromise.allSettled(customStreamsEndPromises),\n\t\t]);\n\t}\n};\n\n// Transforms replace `subprocess.std*`, which means they are not exposed to users.\n// However, we still want to wait for their completion.\nconst waitForOriginalStreams = (originalStreams, subprocess, streamInfo) =>\n\toriginalStreams.map((stream, fdNumber) => stream === subprocess.stdio[fdNumber]\n\t\t? undefined\n\t\t: waitForStream(stream, fdNumber, streamInfo));\n\n// Some `stdin`/`stdout`/`stderr` options create a stream, e.g. when passing a file path.\n// The `.pipe()` method automatically ends that stream when `subprocess` ends.\n// This makes sure we wait for the completion of those streams, in order to catch any error.\nconst waitForCustomStreamsEnd = (fileDescriptors, streamInfo) => fileDescriptors.flatMap(({stdioItems}, fdNumber) => stdioItems\n\t.filter(({value, stream = value}) => isNodeStream(stream, {checkOpen: false}) && !isStandardStream(stream))\n\t.map(({type, value, stream = value}) => waitForStream(stream, fdNumber, streamInfo, {\n\t\tisSameDirection: TRANSFORM_TYPES.has(type),\n\t\tstopOnExit: type === 'native',\n\t})));\n\n// Fails when the subprocess emits an `error` event\nconst throwOnSubprocessError = async (subprocess, {signal}) => {\n\tconst [error] = await once(subprocess, 'error', {signal});\n\tthrow error;\n};\n", "import {createDeferred} from '../utils/deferred.js';\n\n// When using multiple `.readable()`/`.writable()`/`.duplex()`, `final` and `destroy` should wait for other streams\nexport const initializeConcurrentStreams = () => ({\n\treadableDestroy: new WeakMap(),\n\twritableFinal: new WeakMap(),\n\twritableDestroy: new WeakMap(),\n});\n\n// Each file descriptor + `waitName` has its own array of promises.\n// Each promise is a single `.readable()`/`.writable()`/`.duplex()` call.\nexport const addConcurrentStream = (concurrentStreams, stream, waitName) => {\n\tconst weakMap = concurrentStreams[waitName];\n\tif (!weakMap.has(stream)) {\n\t\tweakMap.set(stream, []);\n\t}\n\n\tconst promises = weakMap.get(stream);\n\tconst promise = createDeferred();\n\tpromises.push(promise);\n\tconst resolve = promise.resolve.bind(promise);\n\treturn {resolve, promises};\n};\n\n// Wait for other streams, but stop waiting when subprocess ends\nexport const waitForConcurrentStreams = async ({resolve, promises}, subprocess) => {\n\tresolve();\n\tconst [isSubprocessExit] = await Promise.race([\n\t\tPromise.allSettled([true, subprocess]),\n\t\tPromise.all([false, ...promises]),\n\t]);\n\treturn !isSubprocessExit;\n};\n", "import {finished} from 'node:stream/promises';\nimport {isStreamAbort} from '../resolve/wait-stream.js';\n\nexport const safeWaitForSubprocessStdin = async subprocessStdin => {\n\tif (subprocessStdin === undefined) {\n\t\treturn;\n\t}\n\n\ttry {\n\t\tawait waitForSubprocessStdin(subprocessStdin);\n\t} catch {}\n};\n\nexport const safeWaitForSubprocessStdout = async subprocessStdout => {\n\tif (subprocessStdout === undefined) {\n\t\treturn;\n\t}\n\n\ttry {\n\t\tawait waitForSubprocessStdout(subprocessStdout);\n\t} catch {}\n};\n\nexport const waitForSubprocessStdin = async subprocessStdin => {\n\tawait finished(subprocessStdin, {cleanup: true, readable: false, writable: true});\n};\n\nexport const waitForSubprocessStdout = async subprocessStdout => {\n\tawait finished(subprocessStdout, {cleanup: true, readable: true, writable: false});\n};\n\n// When `readable` or `writable` aborts/errors, awaits the subprocess, for the reason mentioned above\nexport const waitForSubprocess = async (subprocess, error) => {\n\tawait subprocess;\n\tif (error) {\n\t\tthrow error;\n\t}\n};\n\nexport const destroyOtherStream = (stream, isOpen, error) => {\n\tif (error && !isStreamAbort(error)) {\n\t\tstream.destroy(error);\n\t} else if (isOpen) {\n\t\tstream.destroy();\n\t}\n};\n", "import {Readable} from 'node:stream';\nimport {callbackify} from 'node:util';\nimport {BINARY_ENCODINGS} from '../arguments/encoding-option.js';\nimport {getFromStream} from '../arguments/fd-options.js';\nimport {iterateOnSubprocessStream, DEFAULT_OBJECT_HIGH_WATER_MARK} from '../io/iterate.js';\nimport {createDeferred} from '../utils/deferred.js';\nimport {addConcurrentStream, waitForConcurrentStreams} from './concurrent.js';\nimport {\n\tsafeWaitForSubprocessStdin,\n\twaitForSubprocessStdout,\n\twaitForSubprocess,\n\tdestroyOtherStream,\n} from './shared.js';\n\n// Create a `Readable` stream that forwards from `stdout` and awaits the subprocess\nexport const createReadable = ({subprocess, concurrentStreams, encoding}, {from, binary: binaryOption = true, preserveNewlines = true} = {}) => {\n\tconst binary = binaryOption || BINARY_ENCODINGS.has(encoding);\n\tconst {subprocessStdout, waitReadableDestroy} = getSubprocessStdout(subprocess, from, concurrentStreams);\n\tconst {readableEncoding, readableObjectMode, readableHighWaterMark} = getReadableOptions(subprocessStdout, binary);\n\tconst {read, onStdoutDataDone} = getReadableMethods({\n\t\tsubprocessStdout,\n\t\tsubprocess,\n\t\tbinary,\n\t\tencoding,\n\t\tpreserveNewlines,\n\t});\n\tconst readable = new Readable({\n\t\tread,\n\t\tdestroy: callbackify(onReadableDestroy.bind(undefined, {subprocessStdout, subprocess, waitReadableDestroy})),\n\t\thighWaterMark: readableHighWaterMark,\n\t\tobjectMode: readableObjectMode,\n\t\tencoding: readableEncoding,\n\t});\n\tonStdoutFinished({\n\t\tsubprocessStdout,\n\t\tonStdoutDataDone,\n\t\treadable,\n\t\tsubprocess,\n\t});\n\treturn readable;\n};\n\n// Retrieve `stdout` (or other stream depending on `from`)\nexport const getSubprocessStdout = (subprocess, from, concurrentStreams) => {\n\tconst subprocessStdout = getFromStream(subprocess, from);\n\tconst waitReadableDestroy = addConcurrentStream(concurrentStreams, subprocessStdout, 'readableDestroy');\n\treturn {subprocessStdout, waitReadableDestroy};\n};\n\nexport const getReadableOptions = ({readableEncoding, readableObjectMode, readableHighWaterMark}, binary) => binary\n\t? {readableEncoding, readableObjectMode, readableHighWaterMark}\n\t: {readableEncoding, readableObjectMode: true, readableHighWaterMark: DEFAULT_OBJECT_HIGH_WATER_MARK};\n\nexport const getReadableMethods = ({subprocessStdout, subprocess, binary, encoding, preserveNewlines}) => {\n\tconst onStdoutDataDone = createDeferred();\n\tconst onStdoutData = iterateOnSubprocessStream({\n\t\tsubprocessStdout,\n\t\tsubprocess,\n\t\tbinary,\n\t\tshouldEncode: !binary,\n\t\tencoding,\n\t\tpreserveNewlines,\n\t});\n\n\treturn {\n\t\tread() {\n\t\t\tonRead(this, onStdoutData, onStdoutDataDone);\n\t\t},\n\t\tonStdoutDataDone,\n\t};\n};\n\n// Forwards data from `stdout` to `readable`\nconst onRead = async (readable, onStdoutData, onStdoutDataDone) => {\n\ttry {\n\t\tconst {value, done} = await onStdoutData.next();\n\t\tif (done) {\n\t\t\tonStdoutDataDone.resolve();\n\t\t} else {\n\t\t\treadable.push(value);\n\t\t}\n\t} catch {}\n};\n\n// When `subprocess.stdout` ends/aborts/errors, do the same on `readable`.\n// Await the subprocess, for the same reason as above.\nexport const onStdoutFinished = async ({subprocessStdout, onStdoutDataDone, readable, subprocess, subprocessStdin}) => {\n\ttry {\n\t\tawait waitForSubprocessStdout(subprocessStdout);\n\t\tawait subprocess;\n\t\tawait safeWaitForSubprocessStdin(subprocessStdin);\n\t\tawait onStdoutDataDone;\n\n\t\tif (readable.readable) {\n\t\t\treadable.push(null);\n\t\t}\n\t} catch (error) {\n\t\tawait safeWaitForSubprocessStdin(subprocessStdin);\n\t\tdestroyOtherReadable(readable, error);\n\t}\n};\n\n// When `readable` aborts/errors, do the same on `subprocess.stdout`\nexport const onReadableDestroy = async ({subprocessStdout, subprocess, waitReadableDestroy}, error) => {\n\tif (await waitForConcurrentStreams(waitReadableDestroy, subprocess)) {\n\t\tdestroyOtherReadable(subprocessStdout, error);\n\t\tawait waitForSubprocess(subprocess, error);\n\t}\n};\n\nconst destroyOtherReadable = (stream, error) => {\n\tdestroyOtherStream(stream, stream.readable, error);\n};\n", "import {Writable} from 'node:stream';\nimport {callbackify} from 'node:util';\nimport {getToStream} from '../arguments/fd-options.js';\nimport {addConcurrentStream, waitForConcurrentStreams} from './concurrent.js';\nimport {\n\tsafeWaitForSubprocessStdout,\n\twaitForSubprocessStdin,\n\twaitForSubprocess,\n\tdestroyOtherStream,\n} from './shared.js';\n\n// Create a `Writable` stream that forwards to `stdin` and awaits the subprocess\nexport const createWritable = ({subprocess, concurrentStreams}, {to} = {}) => {\n\tconst {subprocessStdin, waitWritableFinal, waitWritableDestroy} = getSubprocessStdin(subprocess, to, concurrentStreams);\n\tconst writable = new Writable({\n\t\t...getWritableMethods(subprocessStdin, subprocess, waitWritableFinal),\n\t\tdestroy: callbackify(onWritableDestroy.bind(undefined, {\n\t\t\tsubprocessStdin,\n\t\t\tsubprocess,\n\t\t\twaitWritableFinal,\n\t\t\twaitWritableDestroy,\n\t\t})),\n\t\thighWaterMark: subprocessStdin.writableHighWaterMark,\n\t\tobjectMode: subprocessStdin.writableObjectMode,\n\t});\n\tonStdinFinished(subprocessStdin, writable);\n\treturn writable;\n};\n\n// Retrieve `stdin` (or other stream depending on `to`)\nexport const getSubprocessStdin = (subprocess, to, concurrentStreams) => {\n\tconst subprocessStdin = getToStream(subprocess, to);\n\tconst waitWritableFinal = addConcurrentStream(concurrentStreams, subprocessStdin, 'writableFinal');\n\tconst waitWritableDestroy = addConcurrentStream(concurrentStreams, subprocessStdin, 'writableDestroy');\n\treturn {subprocessStdin, waitWritableFinal, waitWritableDestroy};\n};\n\nexport const getWritableMethods = (subprocessStdin, subprocess, waitWritableFinal) => ({\n\twrite: onWrite.bind(undefined, subprocessStdin),\n\tfinal: callbackify(onWritableFinal.bind(undefined, subprocessStdin, subprocess, waitWritableFinal)),\n});\n\n// Forwards data from `writable` to `stdin`\nconst onWrite = (subprocessStdin, chunk, encoding, done) => {\n\tif (subprocessStdin.write(chunk, encoding)) {\n\t\tdone();\n\t} else {\n\t\tsubprocessStdin.once('drain', done);\n\t}\n};\n\n// Ensures that the writable `final` and readable `end` events awaits the subprocess.\n// Like this, any subprocess failure is propagated as a stream `error` event, instead of being lost.\n// The user does not need to `await` the subprocess anymore, but now needs to await the stream completion or error.\n// When multiple writables are targeting the same stream, they wait for each other, unless the subprocess ends first.\nconst onWritableFinal = async (subprocessStdin, subprocess, waitWritableFinal) => {\n\tif (await waitForConcurrentStreams(waitWritableFinal, subprocess)) {\n\t\tif (subprocessStdin.writable) {\n\t\t\tsubprocessStdin.end();\n\t\t}\n\n\t\tawait subprocess;\n\t}\n};\n\n// When `subprocess.stdin` ends/aborts/errors, do the same on `writable`.\nexport const onStdinFinished = async (subprocessStdin, writable, subprocessStdout) => {\n\ttry {\n\t\tawait waitForSubprocessStdin(subprocessStdin);\n\t\tif (writable.writable) {\n\t\t\twritable.end();\n\t\t}\n\t} catch (error) {\n\t\tawait safeWaitForSubprocessStdout(subprocessStdout);\n\t\tdestroyOtherWritable(writable, error);\n\t}\n};\n\n// When `writable` aborts/errors, do the same on `subprocess.stdin`\nexport const onWritableDestroy = async ({subprocessStdin, subprocess, waitWritableFinal, waitWritableDestroy}, error) => {\n\tawait waitForConcurrentStreams(waitWritableFinal, subprocess);\n\tif (await waitForConcurrentStreams(waitWritableDestroy, subprocess)) {\n\t\tdestroyOtherWritable(subprocessStdin, error);\n\t\tawait waitForSubprocess(subprocess, error);\n\t}\n};\n\nconst destroyOtherWritable = (stream, error) => {\n\tdestroyOtherStream(stream, stream.writable, error);\n};\n", "import {Duplex} from 'node:stream';\nimport {callbackify} from 'node:util';\nimport {BINARY_ENCODINGS} from '../arguments/encoding-option.js';\nimport {\n\tgetSubprocessStdout,\n\tgetReadableOptions,\n\tgetReadableMethods,\n\tonStdoutFinished,\n\tonReadableDestroy,\n} from './readable.js';\nimport {\n\tgetSubprocessStdin,\n\tgetWritableMethods,\n\tonStdinFinished,\n\tonWritableDestroy,\n} from './writable.js';\n\n// Create a `Duplex` stream combining both `subprocess.readable()` and `subprocess.writable()`\nexport const createDuplex = ({subprocess, concurrentStreams, encoding}, {from, to, binary: binaryOption = true, preserveNewlines = true} = {}) => {\n\tconst binary = binaryOption || BINARY_ENCODINGS.has(encoding);\n\tconst {subprocessStdout, waitReadableDestroy} = getSubprocessStdout(subprocess, from, concurrentStreams);\n\tconst {subprocessStdin, waitWritableFinal, waitWritableDestroy} = getSubprocessStdin(subprocess, to, concurrentStreams);\n\tconst {readableEncoding, readableObjectMode, readableHighWaterMark} = getReadableOptions(subprocessStdout, binary);\n\tconst {read, onStdoutDataDone} = getReadableMethods({\n\t\tsubprocessStdout,\n\t\tsubprocess,\n\t\tbinary,\n\t\tencoding,\n\t\tpreserveNewlines,\n\t});\n\tconst duplex = new Duplex({\n\t\tread,\n\t\t...getWritableMethods(subprocessStdin, subprocess, waitWritableFinal),\n\t\tdestroy: callbackify(onDuplexDestroy.bind(undefined, {\n\t\t\tsubprocessStdout,\n\t\t\tsubprocessStdin,\n\t\t\tsubprocess,\n\t\t\twaitReadableDestroy,\n\t\t\twaitWritableFinal,\n\t\t\twaitWritableDestroy,\n\t\t})),\n\t\treadableHighWaterMark,\n\t\twritableHighWaterMark: subprocessStdin.writableHighWaterMark,\n\t\treadableObjectMode,\n\t\twritableObjectMode: subprocessStdin.writableObjectMode,\n\t\tencoding: readableEncoding,\n\t});\n\tonStdoutFinished({\n\t\tsubprocessStdout,\n\t\tonStdoutDataDone,\n\t\treadable: duplex,\n\t\tsubprocess,\n\t\tsubprocessStdin,\n\t});\n\tonStdinFinished(subprocessStdin, duplex, subprocessStdout);\n\treturn duplex;\n};\n\nconst onDuplexDestroy = async ({subprocessStdout, subprocessStdin, subprocess, waitReadableDestroy, waitWritableFinal, waitWritableDestroy}, error) => {\n\tawait Promise.all([\n\t\tonReadableDestroy({subprocessStdout, subprocess, waitReadableDestroy}, error),\n\t\tonWritableDestroy({\n\t\t\tsubprocessStdin,\n\t\t\tsubprocess,\n\t\t\twaitWritableFinal,\n\t\t\twaitWritableDestroy,\n\t\t}, error),\n\t]);\n};\n", "import {BINARY_ENCODINGS} from '../arguments/encoding-option.js';\nimport {getFromStream} from '../arguments/fd-options.js';\nimport {iterateOnSubprocessStream} from '../io/iterate.js';\n\n// Convert the subprocess to an async iterable\nexport const createIterable = (subprocess, encoding, {\n\tfrom,\n\tbinary: binaryOption = false,\n\tpreserveNewlines = false,\n} = {}) => {\n\tconst binary = binaryOption || BINARY_ENCODINGS.has(encoding);\n\tconst subprocessStdout = getFromStream(subprocess, from);\n\tconst onStdoutData = iterateOnSubprocessStream({\n\t\tsubprocessStdout,\n\t\tsubprocess,\n\t\tbinary,\n\t\tshouldEncode: true,\n\t\tencoding,\n\t\tpreserveNewlines,\n\t});\n\treturn iterateOnStdoutData(onStdoutData, subprocessStdout, subprocess);\n};\n\nconst iterateOnStdoutData = async function * (onStdoutData, subprocessStdout, subprocess) {\n\ttry {\n\t\tyield * onStdoutData;\n\t} finally {\n\t\tif (subprocessStdout.readable) {\n\t\t\tsubprocessStdout.destroy();\n\t\t}\n\n\t\tawait subprocess;\n\t}\n};\n", "import {initializeConcurrentStreams} from './concurrent.js';\nimport {createReadable} from './readable.js';\nimport {createWritable} from './writable.js';\nimport {createDuplex} from './duplex.js';\nimport {createIterable} from './iterable.js';\n\n// Add methods to convert the subprocess to a stream or iterable\nexport const addConvertedStreams = (subprocess, {encoding}) => {\n\tconst concurrentStreams = initializeConcurrentStreams();\n\tsubprocess.readable = createReadable.bind(undefined, {subprocess, concurrentStreams, encoding});\n\tsubprocess.writable = createWritable.bind(undefined, {subprocess, concurrentStreams});\n\tsubprocess.duplex = createDuplex.bind(undefined, {subprocess, concurrentStreams, encoding});\n\tsubprocess.iterable = createIterable.bind(undefined, subprocess, encoding);\n\tsubprocess[Symbol.asyncIterator] = createIterable.bind(undefined, subprocess, encoding, {});\n};\n", "// The return value is a mixin of `subprocess` and `Promise`\nexport const mergePromise = (subprocess, promise) => {\n\tfor (const [property, descriptor] of descriptors) {\n\t\tconst value = descriptor.value.bind(promise);\n\t\tReflect.defineProperty(subprocess, property, {...descriptor, value});\n\t}\n};\n\n// eslint-disable-next-line unicorn/prefer-top-level-await\nconst nativePromisePrototype = (async () => {})().constructor.prototype;\n\nconst descriptors = ['then', 'catch', 'finally'].map(property => [\n\tproperty,\n\tReflect.getOwnPropertyDescriptor(nativePromisePrototype, property),\n]);\n", "import {setMaxListeners} from 'node:events';\nimport {spawn} from 'node:child_process';\nimport {MaxBufferError} from 'get-stream';\nimport {handleCommand} from '../arguments/command.js';\nimport {normalizeOptions} from '../arguments/options.js';\nimport {SUBPROCESS_OPTIONS} from '../arguments/fd-options.js';\nimport {concatenateShell} from '../arguments/shell.js';\nimport {addIpcMethods} from '../ipc/methods.js';\nimport {makeError, makeSuccessResult} from '../return/result.js';\nimport {handleResult} from '../return/reject.js';\nimport {handleEarlyError} from '../return/early-error.js';\nimport {handleStdioAsync} from '../stdio/handle-async.js';\nimport {stripNewline} from '../io/strip-newline.js';\nimport {pipeOutputAsync} from '../io/output-async.js';\nimport {subprocessKill} from '../terminate/kill.js';\nimport {cleanupOnExit} from '../terminate/cleanup.js';\nimport {pipeToSubprocess} from '../pipe/setup.js';\nimport {makeAllStream} from '../resolve/all-async.js';\nimport {waitForSubprocessResult} from '../resolve/wait-subprocess.js';\nimport {addConvertedStreams} from '../convert/add.js';\nimport {createDeferred} from '../utils/deferred.js';\nimport {mergePromise} from './promise.js';\n\n// Main shared logic for all async methods: `execa()`, `$`, `execaNode()`\nexport const execaCoreAsync = (rawFile, rawArguments, rawOptions, createNested) => {\n\tconst {file, commandArguments, command, escapedCommand, startTime, verboseInfo, options, fileDescriptors} = handleAsyncArguments(rawFile, rawArguments, rawOptions);\n\tconst {subprocess, promise} = spawnSubprocessAsync({\n\t\tfile,\n\t\tcommandArguments,\n\t\toptions,\n\t\tstartTime,\n\t\tverboseInfo,\n\t\tcommand,\n\t\tescapedCommand,\n\t\tfileDescriptors,\n\t});\n\tsubprocess.pipe = pipeToSubprocess.bind(undefined, {\n\t\tsource: subprocess,\n\t\tsourcePromise: promise,\n\t\tboundOptions: {},\n\t\tcreateNested,\n\t});\n\tmergePromise(subprocess, promise);\n\tSUBPROCESS_OPTIONS.set(subprocess, {options, fileDescriptors});\n\treturn subprocess;\n};\n\n// Compute arguments to pass to `child_process.spawn()`\nconst handleAsyncArguments = (rawFile, rawArguments, rawOptions) => {\n\tconst {command, escapedCommand, startTime, verboseInfo} = handleCommand(rawFile, rawArguments, rawOptions);\n\tconst {file, commandArguments, options: normalizedOptions} = normalizeOptions(rawFile, rawArguments, rawOptions);\n\tconst options = handleAsyncOptions(normalizedOptions);\n\tconst fileDescriptors = handleStdioAsync(options, verboseInfo);\n\treturn {\n\t\tfile,\n\t\tcommandArguments,\n\t\tcommand,\n\t\tescapedCommand,\n\t\tstartTime,\n\t\tverboseInfo,\n\t\toptions,\n\t\tfileDescriptors,\n\t};\n};\n\n// Options normalization logic specific to async methods.\n// Prevent passing the `timeout` option directly to `child_process.spawn()`.\nconst handleAsyncOptions = ({timeout, signal, ...options}) => {\n\tif (signal !== undefined) {\n\t\tthrow new TypeError('The \"signal\" option has been renamed to \"cancelSignal\" instead.');\n\t}\n\n\treturn {...options, timeoutDuration: timeout};\n};\n\nconst spawnSubprocessAsync = ({file, commandArguments, options, startTime, verboseInfo, command, escapedCommand, fileDescriptors}) => {\n\tlet subprocess;\n\ttry {\n\t\tsubprocess = spawn(...concatenateShell(file, commandArguments, options));\n\t} catch (error) {\n\t\treturn handleEarlyError({\n\t\t\terror,\n\t\t\tcommand,\n\t\t\tescapedCommand,\n\t\t\tfileDescriptors,\n\t\t\toptions,\n\t\t\tstartTime,\n\t\t\tverboseInfo,\n\t\t});\n\t}\n\n\tconst controller = new AbortController();\n\tsetMaxListeners(Number.POSITIVE_INFINITY, controller.signal);\n\n\tconst originalStreams = [...subprocess.stdio];\n\tpipeOutputAsync(subprocess, fileDescriptors, controller);\n\tcleanupOnExit(subprocess, options, controller);\n\n\tconst context = {};\n\tconst onInternalError = createDeferred();\n\tsubprocess.kill = subprocessKill.bind(undefined, {\n\t\tkill: subprocess.kill.bind(subprocess),\n\t\toptions,\n\t\tonInternalError,\n\t\tcontext,\n\t\tcontroller,\n\t});\n\tsubprocess.all = makeAllStream(subprocess, options);\n\taddConvertedStreams(subprocess, options);\n\taddIpcMethods(subprocess, options);\n\n\tconst promise = handlePromise({\n\t\tsubprocess,\n\t\toptions,\n\t\tstartTime,\n\t\tverboseInfo,\n\t\tfileDescriptors,\n\t\toriginalStreams,\n\t\tcommand,\n\t\tescapedCommand,\n\t\tcontext,\n\t\tonInternalError,\n\t\tcontroller,\n\t});\n\treturn {subprocess, promise};\n};\n\n// Asynchronous logic, as opposed to the previous logic which can be run synchronously, i.e. can be returned to user right away\nconst handlePromise = async ({subprocess, options, startTime, verboseInfo, fileDescriptors, originalStreams, command, escapedCommand, context, onInternalError, controller}) => {\n\tconst [\n\t\terrorInfo,\n\t\t[exitCode, signal],\n\t\tstdioResults,\n\t\tallResult,\n\t\tipcOutput,\n\t] = await waitForSubprocessResult({\n\t\tsubprocess,\n\t\toptions,\n\t\tcontext,\n\t\tverboseInfo,\n\t\tfileDescriptors,\n\t\toriginalStreams,\n\t\tonInternalError,\n\t\tcontroller,\n\t});\n\tcontroller.abort();\n\tonInternalError.resolve();\n\n\tconst stdio = stdioResults.map((stdioResult, fdNumber) => stripNewline(stdioResult, options, fdNumber));\n\tconst all = stripNewline(allResult, options, 'all');\n\tconst result = getAsyncResult({\n\t\terrorInfo,\n\t\texitCode,\n\t\tsignal,\n\t\tstdio,\n\t\tall,\n\t\tipcOutput,\n\t\tcontext,\n\t\toptions,\n\t\tcommand,\n\t\tescapedCommand,\n\t\tstartTime,\n\t});\n\treturn handleResult(result, verboseInfo, options);\n};\n\nconst getAsyncResult = ({errorInfo, exitCode, signal, stdio, all, ipcOutput, context, options, command, escapedCommand, startTime}) => 'error' in errorInfo\n\t? makeError({\n\t\terror: errorInfo.error,\n\t\tcommand,\n\t\tescapedCommand,\n\t\ttimedOut: context.terminationReason === 'timeout',\n\t\tisCanceled: context.terminationReason === 'cancel' || context.terminationReason === 'gracefulCancel',\n\t\tisGracefullyCanceled: context.terminationReason === 'gracefulCancel',\n\t\tisMaxBuffer: errorInfo.error instanceof MaxBufferError,\n\t\tisForcefullyTerminated: context.isForcefullyTerminated,\n\t\texitCode,\n\t\tsignal,\n\t\tstdio,\n\t\tall,\n\t\tipcOutput,\n\t\toptions,\n\t\tstartTime,\n\t\tisSync: false,\n\t})\n\t: makeSuccessResult({\n\t\tcommand,\n\t\tescapedCommand,\n\t\tstdio,\n\t\tall,\n\t\tipcOutput,\n\t\toptions,\n\t\tstartTime,\n\t});\n", "import isPlainObject from 'is-plain-obj';\nimport {FD_SPECIFIC_OPTIONS} from '../arguments/specific.js';\n\n// Deep merge specific options like `env`. Shallow merge the other ones.\nexport const mergeOptions = (boundOptions, options) => {\n\tconst newOptions = Object.fromEntries(\n\t\tObject.entries(options).map(([optionName, optionValue]) => [\n\t\t\toptionName,\n\t\t\tmergeOption(optionName, boundOptions[optionName], optionValue),\n\t\t]),\n\t);\n\treturn {...boundOptions, ...newOptions};\n};\n\nconst mergeOption = (optionName, boundOptionValue, optionValue) => {\n\tif (DEEP_OPTIONS.has(optionName) && isPlainObject(boundOptionValue) && isPlainObject(optionValue)) {\n\t\treturn {...boundOptionValue, ...optionValue};\n\t}\n\n\treturn optionValue;\n};\n\nconst DEEP_OPTIONS = new Set(['env', ...FD_SPECIFIC_OPTIONS]);\n", "import isPlainObject from 'is-plain-obj';\nimport {normalizeParameters} from './parameters.js';\nimport {isTemplateString, parseTemplates} from './template.js';\nimport {execaCoreSync} from './main-sync.js';\nimport {execaCoreAsync} from './main-async.js';\nimport {mergeOptions} from './bind.js';\n\n// Wraps every exported methods to provide the following features:\n//  - template string syntax: execa`command argument`\n//  - options binding: boundExeca = execa(options)\n//  - optional argument/options: execa(file), execa(file, args), execa(file, options), execa(file, args, options)\n// `mapArguments()` and `setBoundExeca()` allows for method-specific logic.\nexport const createExeca = (mapArguments, boundOptions, deepOptions, setBoundExeca) => {\n\tconst createNested = (mapArguments, boundOptions, setBoundExeca) => createExeca(mapArguments, boundOptions, deepOptions, setBoundExeca);\n\tconst boundExeca = (...execaArguments) => callBoundExeca({\n\t\tmapArguments,\n\t\tdeepOptions,\n\t\tboundOptions,\n\t\tsetBoundExeca,\n\t\tcreateNested,\n\t}, ...execaArguments);\n\n\tif (setBoundExeca !== undefined) {\n\t\tsetBoundExeca(boundExeca, createNested, boundOptions);\n\t}\n\n\treturn boundExeca;\n};\n\nconst callBoundExeca = ({mapArguments, deepOptions = {}, boundOptions = {}, setBoundExeca, createNested}, firstArgument, ...nextArguments) => {\n\tif (isPlainObject(firstArgument)) {\n\t\treturn createNested(mapArguments, mergeOptions(boundOptions, firstArgument), setBoundExeca);\n\t}\n\n\tconst {file, commandArguments, options, isSync} = parseArguments({\n\t\tmapArguments,\n\t\tfirstArgument,\n\t\tnextArguments,\n\t\tdeepOptions,\n\t\tboundOptions,\n\t});\n\treturn isSync\n\t\t? execaCoreSync(file, commandArguments, options)\n\t\t: execaCoreAsync(file, commandArguments, options, createNested);\n};\n\nconst parseArguments = ({mapArguments, firstArgument, nextArguments, deepOptions, boundOptions}) => {\n\tconst callArguments = isTemplateString(firstArgument)\n\t\t? parseTemplates(firstArgument, nextArguments)\n\t\t: [firstArgument, ...nextArguments];\n\tconst [initialFile, initialArguments, initialOptions] = normalizeParameters(...callArguments);\n\tconst mergedOptions = mergeOptions(mergeOptions(deepOptions, boundOptions), initialOptions);\n\tconst {\n\t\tfile = initialFile,\n\t\tcommandArguments = initialArguments,\n\t\toptions = mergedOptions,\n\t\tisSync = false,\n\t} = mapArguments({file: initialFile, commandArguments: initialArguments, options: mergedOptions});\n\treturn {\n\t\tfile,\n\t\tcommandArguments,\n\t\toptions,\n\t\tisSync,\n\t};\n};\n", "// Main logic for `execaCommand()`\nexport const mapCommandAsync = ({file, commandArguments}) => parseCommand(file, commandArguments);\n\n// Main logic for `execaCommandSync()`\nexport const mapCommandSync = ({file, commandArguments}) => ({...parseCommand(file, commandArguments), isSync: true});\n\n// Convert `execaCommand(command)` into `execa(file, ...commandArguments)`\nconst parseCommand = (command, unusedArguments) => {\n\tif (unusedArguments.length > 0) {\n\t\tthrow new TypeError(`The command and its arguments must be passed as a single string: ${command} ${unusedArguments}.`);\n\t}\n\n\tconst [file, ...commandArguments] = parseCommandString(command);\n\treturn {file, commandArguments};\n};\n\n// Convert `command` string into an array of file or arguments to pass to $`${...fileOrCommandArguments}`\nexport const parseCommandString = command => {\n\tif (typeof command !== 'string') {\n\t\tthrow new TypeError(`The command must be a string: ${String(command)}.`);\n\t}\n\n\tconst trimmedCommand = command.trim();\n\tif (trimmedCommand === '') {\n\t\treturn [];\n\t}\n\n\tconst tokens = [];\n\tfor (const token of trimmedCommand.split(SPACES_REGEXP)) {\n\t\t// Allow spaces to be escaped by a backslash if not meant as a delimiter\n\t\tconst previousToken = tokens.at(-1);\n\t\tif (previousToken && previousToken.endsWith('\\\\')) {\n\t\t\t// Merge previous token with current one\n\t\t\ttokens[tokens.length - 1] = `${previousToken.slice(0, -1)} ${token}`;\n\t\t} else {\n\t\t\ttokens.push(token);\n\t\t}\n\t}\n\n\treturn tokens;\n};\n\nconst SPACES_REGEXP = / +/g;\n", "// Sets `$.sync` and `$.s`\nexport const setScriptSync = (boundExeca, createNested, boundOptions) => {\n\tboundExeca.sync = createNested(mapScriptSync, boundOptions);\n\tboundExeca.s = boundExeca.sync;\n};\n\n// Main logic for `$`\nexport const mapScriptAsync = ({options}) => getScriptOptions(options);\n\n// Main logic for `$.sync`\nconst mapScriptSync = ({options}) => ({...getScriptOptions(options), isSync: true});\n\n// `$` is like `execa` but with script-friendly options: `{stdin: 'inherit', preferLocal: true}`\nconst getScriptOptions = options => ({options: {...getScriptStdinOption(options), ...options}});\n\nconst getScriptStdinOption = ({input, inputFile, stdio}) => input === undefined && inputFile === undefined && stdio === undefined\n\t? {stdin: 'inherit'}\n\t: {};\n\n// When using $(...).pipe(...), most script-friendly options should apply to both commands.\n// However, some options (like `stdin: 'inherit'`) would create issues with piping, i.e. cannot be deep.\nexport const deepScriptOptions = {preferLocal: true};\n", "import {createExeca} from './lib/methods/create.js';\nimport {mapCommandAsync, mapCommandSync} from './lib/methods/command.js';\nimport {mapNode} from './lib/methods/node.js';\nimport {mapScriptAsync, setScriptSync, deepScriptOptions} from './lib/methods/script.js';\nimport {getIpcExport} from './lib/ipc/methods.js';\n\nexport {parseCommandString} from './lib/methods/command.js';\nexport {ExecaError, ExecaSyncError} from './lib/return/final-error.js';\n\nexport const execa = createExeca(() => ({}));\nexport const execaSync = createExeca(() => ({isSync: true}));\nexport const execaCommand = createExeca(mapCommandAsync);\nexport const execaCommandSync = createExeca(mapCommandSync);\nexport const execaNode = createExeca(mapNode);\nexport const $ = createExeca(mapScriptAsync, {}, deepScriptOptions, setScriptSync);\n\nconst {\n\tsendMessage,\n\tgetOneMessage,\n\tgetEachMessage,\n\tgetCancelSignal,\n} = getIpcExport();\nexport {\n\tsendMessage,\n\tgetOneMessage,\n\tgetEachMessage,\n\tgetCancelSignal,\n};\n", "import path from \"path\";\nimport { execa } from \"execa\";\nimport { environment } from \"@raycast/api\";\nimport fs from \"fs\";\nimport type { PlatformAudioAPI, AudioDevice } from \"./index\";\n\nconst binaryAsset = path.join(environment.assetsPath, \"audio-devices\");\nconst binary = path.join(environment.supportPath, \"audio-devices\");\n\nasync function ensureBinary() {\n  if (!fs.existsSync(binary)) {\n    fs.copyFileSync(binaryAsset, binary);\n    await execa(\"chmod\", [\"+x\", binary]);\n  }\n}\n\nfunction throwIfStderr({ stderr }: { stderr: string }) {\n  if (stderr) {\n    throw new Error(stderr);\n  }\n}\n\nfunction parseStdout({ stdout, stderr }: { stderr: string; stdout: string }) {\n  throwIfStderr({ stderr });\n  return JSON.parse(stdout);\n}\n\nexport const macosAudioAPI: PlatformAudioAPI = {\n  async getAllDevices(): Promise<AudioDevice[]> {\n    await ensureBinary();\n    return parseStdout(await execa(binary, [\"list\", \"--json\"]));\n  },\n\n  async getInputDevices(): Promise<AudioDevice[]> {\n    await ensureBinary();\n    return parseStdout(await execa(binary, [\"list\", \"--input\", \"--json\"]));\n  },\n\n  async getOutputDevices(): Promise<AudioDevice[]> {\n    await ensureBinary();\n    return parseStdout(await execa(binary, [\"list\", \"--output\", \"--json\"]));\n  },\n\n  async getDefaultOutputDevice(): Promise<AudioDevice> {\n    await ensureBinary();\n    return parseStdout(await execa(binary, [\"output\", \"get\", \"--json\"]));\n  },\n\n  async getDefaultInputDevice(): Promise<AudioDevice> {\n    await ensureBinary();\n    return parseStdout(await execa(binary, [\"input\", \"get\", \"--json\"]));\n  },\n\n  async getDefaultSystemDevice(): Promise<AudioDevice> {\n    await ensureBinary();\n    return parseStdout(await execa(binary, [\"system\", \"get\", \"--json\"]));\n  },\n\n  async setDefaultOutputDevice(deviceId: string) {\n    await ensureBinary();\n    return throwIfStderr(await execa(binary, [\"output\", \"set\", deviceId]));\n  },\n\n  async setDefaultInputDevice(deviceId: string) {\n    await ensureBinary();\n    return throwIfStderr(await execa(binary, [\"input\", \"set\", deviceId]));\n  },\n\n  async setDefaultSystemDevice(deviceId: string) {\n    await ensureBinary();\n    return throwIfStderr(await execa(binary, [\"system\", \"set\", deviceId]));\n  },\n\n  async getOutputDeviceVolume(deviceId: string) {\n    await ensureBinary();\n    const { stdout, stderr } = await execa(binary, [\"volume\", \"get\", deviceId]);\n    return stderr ? undefined : parseFloat(stdout);\n  },\n\n  async setOutputDeviceVolume(deviceId: string, volume: number) {\n    await ensureBinary();\n    return throwIfStderr(await execa(binary, [\"volume\", \"set\", deviceId, `${volume}`]));\n  },\n\n  async createAggregateDevice(\n    name: string,\n    mainDeviceId: string,\n    otherDeviceIds?: string[],\n    options?: { multiOutput?: boolean },\n  ): Promise<AudioDevice> {\n    await ensureBinary();\n    return parseStdout(\n      await execa(\n        binary,\n        [\n          \"aggregate\",\n          \"create\",\n          \"--json\",\n          options?.multiOutput ? \"--multi-output\" : \"\",\n          name,\n          mainDeviceId,\n          ...(otherDeviceIds || []),\n        ].filter(Boolean),\n      ),\n    );\n  },\n\n  async destroyAggregateDevice(deviceId: string) {\n    await ensureBinary();\n    return throwIfStderr(await execa(binary, [\"aggregate\", \"destroy\", deviceId]));\n  },\n};\n", "import path from \"path\";\nimport fs from \"fs\";\nimport https from \"https\";\nimport crypto from \"crypto\";\nimport { execa } from \"execa\";\nimport { environment } from \"@raycast/api\";\nimport type { PlatformAudioAPI, AudioDevice } from \"./index\";\n\ntype WindowsAudioDevice = {\n  id: string;\n  name: string;\n  isDefault?: boolean;\n  isDefaultCom?: boolean;\n};\n\ntype WindowsAudioList = {\n  inputs: WindowsAudioDevice[];\n  outputs: WindowsAudioDevice[];\n};\n\ntype WindowsAudioSwitchResult = {\n  type: \"input\" | \"output\";\n  device: WindowsAudioDevice;\n};\n\nconst WINDOWS_BINARY_URL = \"https://github.com/Inovvia/go-win-audio-cli/releases/download/1.1.0/win-audio-cli.exe\";\nconst WINDOWS_BINARY_CHECKSUM = \"569fe05624f410b565b92fa0c729e29f170bb78907dcff7ef2cf66a01465e365\";\n\nconst binary = path.join(environment.supportPath, \"win-audio-cli.exe\");\nlet hasLoggedBinaryInfo = false;\nlet isDownloading = false;\nlet downloadPromise: Promise<void> | null = null;\n\nfunction downloadBinary(url: string, dest: string, redirectCount = 0): Promise<void> {\n  if (redirectCount > 5) {\n    return Promise.reject(new Error(\"Too many redirects\"));\n  }\n\n  return new Promise((resolve, reject) => {\n    const file = fs.createWriteStream(dest);\n\n    file.on(\"error\", (error) => {\n      file.close();\n      fs.unlink(dest, () => {\n        reject(error);\n      });\n    });\n\n    const request = https.get(url, (response) => {\n      if (response.statusCode && response.statusCode >= 300 && response.statusCode < 400 && response.headers.location) {\n        file.close();\n        const location = response.headers.location;\n        fs.unlink(dest, (err) => {\n          if (err) {\n            reject(err);\n            return;\n          }\n          if (!location.startsWith(\"https://\")) {\n            reject(new Error(`Redirect to non-HTTPS URL is not allowed: ${location}`));\n            return;\n          }\n          resolve(downloadBinary(location, dest, redirectCount + 1));\n        });\n        return;\n      }\n\n      if (response.statusCode !== 200) {\n        file.close();\n        fs.unlink(dest, () => {\n          reject(new Error(`Download failed with status ${response.statusCode}`));\n        });\n        return;\n      }\n\n      response.pipe(file);\n      file.on(\"finish\", () => {\n        file.close(() => resolve());\n      });\n    });\n\n    request.on(\"error\", (error) => {\n      file.close();\n      fs.unlink(dest, () => {\n        reject(error);\n      });\n    });\n  });\n}\n\nfunction verifyChecksum(filePath: string, expectedChecksum: string): Promise<void> {\n  return new Promise((resolve, reject) => {\n    const hash = crypto.createHash(\"sha256\");\n    const stream = fs.createReadStream(filePath);\n\n    stream.on(\"error\", (error) => reject(error));\n    stream.on(\"data\", (chunk) => hash.update(chunk));\n    stream.on(\"end\", () => {\n      const actualChecksum = hash.digest(\"hex\");\n      if (actualChecksum.toLowerCase() === expectedChecksum.toLowerCase()) {\n        resolve();\n      } else {\n        reject(new Error(`Checksum mismatch. Expected: ${expectedChecksum}, Got: ${actualChecksum}`));\n      }\n    });\n  });\n}\n\nlet hasVerifiedBinaryThisSession = false;\n\nasync function ensureBinary() {\n  if (fs.existsSync(binary)) {\n    // Verify checksum at least once per session to catch corrupt binaries\n    if (!hasVerifiedBinaryThisSession) {\n      try {\n        await verifyChecksum(binary, WINDOWS_BINARY_CHECKSUM);\n        hasVerifiedBinaryThisSession = true;\n      } catch (error) {\n        console.warn(\"Binary checksum verification failed, re-downloading...\", error);\n        fs.unlinkSync(binary);\n        // Continue to download below\n      }\n    }\n\n    if (fs.existsSync(binary)) {\n      await logBinaryInfo();\n      return;\n    }\n  }\n\n  if (isDownloading && downloadPromise) {\n    return downloadPromise;\n  }\n\n  isDownloading = true;\n  downloadPromise = (async () => {\n    try {\n      if (!fs.existsSync(environment.supportPath)) {\n        fs.mkdirSync(environment.supportPath, { recursive: true });\n      }\n\n      console.log(\"Downloading Windows audio CLI binary...\");\n      await downloadBinary(WINDOWS_BINARY_URL, binary);\n      await verifyChecksum(binary, WINDOWS_BINARY_CHECKSUM);\n      hasVerifiedBinaryThisSession = true;\n      console.log(\"Windows audio CLI binary downloaded and verified successfully\");\n      await logBinaryInfo();\n    } catch (error) {\n      if (fs.existsSync(binary)) {\n        fs.unlinkSync(binary);\n      }\n      throw error;\n    } finally {\n      isDownloading = false;\n      downloadPromise = null;\n    }\n  })();\n\n  return downloadPromise;\n}\n\nasync function logBinaryInfo() {\n  if (hasLoggedBinaryInfo) {\n    return;\n  }\n  hasLoggedBinaryInfo = true;\n\n  try {\n    const { stdout } = await execa(binary, [\"version\"]);\n    const info = parseJson<{ version: string; commit: string; buildDate: string }>(stdout);\n    console.log(\"Windows audio binary\", {\n      path: binary,\n      version: info.version,\n      commit: info.commit,\n      buildDate: info.buildDate,\n    });\n  } catch (error) {\n    console.warn(\"Failed to read Windows audio binary version\", error);\n  }\n}\n\nfunction parseJson<T>(stdout: string): T {\n  return JSON.parse(stdout) as T;\n}\n\nfunction mapToDevice(device: WindowsAudioDevice, type: \"input\" | \"output\"): AudioDevice {\n  return {\n    id: device.id,\n    uid: device.id,\n    name: device.name,\n    isInput: type === \"input\",\n    isOutput: type === \"output\",\n    transportType: mapTransportType(device.name),\n    isDefault: device.isDefault,\n    isCommunication: device.isDefaultCom,\n  };\n}\n\nfunction mapTransportType(deviceName: string): string {\n  const typeMap: Record<string, string> = {\n    // More specific multi-word patterns first\n    \"realtek digital\": \"spdif\",\n    \"digital output\": \"spdif\",\n    \"steam streaming\": \"virtual\",\n    nvidia: \"hdmi\",\n    // Then device types\n    headphones: \"headphones\",\n    headset: \"headphones\",\n    earbuds: \"headphones\",\n    airpods: \"headphones\",\n    microphone: \"microphone\",\n    speakers: \"speakers\",\n    // Then shorter patterns\n    hdmi: \"hdmi\",\n    displayport: \"displayport\",\n    usb: \"usb\",\n    bluetooth: \"bluetooth\",\n    mic: \"microphone\",\n    speaker: \"speakers\",\n    spdif: \"spdif\",\n    optical: \"spdif\",\n    dp: \"displayport\",\n    virtual: \"virtual\",\n  };\n\n  const lowerName = deviceName.toLowerCase();\n  for (const [key, value] of Object.entries(typeMap)) {\n    if (lowerName.includes(key)) {\n      return value;\n    }\n  }\n\n  return \"speakers\";\n}\n\nasync function runBinary<T>(args: string[]): Promise<T> {\n  await ensureBinary();\n  const { stdout } = await execa(binary, args);\n  return parseJson<T>(stdout);\n}\n\nasync function getDevices(): Promise<WindowsAudioList> {\n  return runBinary<WindowsAudioList>([\"list\", \"--json\"]);\n}\n\nexport const windowsAudioAPI: PlatformAudioAPI = {\n  async getAllDevices(): Promise<AudioDevice[]> {\n    const devices = await getDevices();\n    return [\n      ...devices.outputs.map((device) => mapToDevice(device, \"output\")),\n      ...devices.inputs.map((device) => mapToDevice(device, \"input\")),\n    ];\n  },\n\n  async getInputDevices(): Promise<AudioDevice[]> {\n    const devices = await getDevices();\n    return devices.inputs.map((device) => mapToDevice(device, \"input\"));\n  },\n\n  async getOutputDevices(): Promise<AudioDevice[]> {\n    const devices = await getDevices();\n    return devices.outputs.map((device) => mapToDevice(device, \"output\"));\n  },\n\n  async getDefaultOutputDevice(): Promise<AudioDevice> {\n    const devices = await getDevices();\n    const device = devices.outputs.find((output) => output.isDefault);\n    if (!device) {\n      throw new Error(\"No default output device found\");\n    }\n\n    return mapToDevice(device, \"output\");\n  },\n\n  async getDefaultInputDevice(): Promise<AudioDevice> {\n    const devices = await getDevices();\n    const device = devices.inputs.find((input) => input.isDefault);\n    if (!device) {\n      throw new Error(\"No default input device found\");\n    }\n\n    return mapToDevice(device, \"input\");\n  },\n\n  async setDefaultOutputDevice(deviceId: string) {\n    await runBinary<WindowsAudioSwitchResult>([\"switch-output\", \"--id\", deviceId]);\n  },\n\n  async setDefaultInputDevice(deviceId: string) {\n    await runBinary<WindowsAudioSwitchResult>([\"switch-input\", \"--id\", deviceId]);\n  },\n\n  async setDefaultCommunicationOutputDevice(deviceId: string) {\n    await runBinary<WindowsAudioSwitchResult>([\"switch-output-communication\", \"--id\", deviceId]);\n  },\n\n  async setDefaultCommunicationInputDevice(deviceId: string) {\n    await runBinary<WindowsAudioSwitchResult>([\"switch-input-communication\", \"--id\", deviceId]);\n  },\n};\n", "import { runAutoSwitch } from \"./auto-switcher\";\n\nexport default async function Command() {\n  await runAutoSwitch(\"input\");\n}\n", "import { LaunchType, LocalStorage, environment, showHUD, showToast, Toast, updateCommandMetadata } from \"@raycast/api\";\nimport {\n  getDefaultInputDevice,\n  getDefaultOutputDevice,\n  getInputDevices,\n  getOutputDevices,\n  setDefaultInputDevice,\n} from \"./audio-device\";\nimport { setOutputAndSystemDevice } from \"./device-actions\";\nimport { AUTO_SWITCH_KEYS } from \"./auto-switch-keys\";\nimport { applyDeviceOrder, getDeviceOrder, getHiddenDevices } from \"./device-preferences\";\n\ntype IOType = \"input\" | \"output\";\n\nconst AUTO_SWITCH_INTERVAL_SECONDS = 20;\nconst MS_PER_SECOND = 1000;\n\nconst AUTO_SWITCH_LAST_RUN_KEYS = {\n  input: \"autoSwitchLastRunInput\",\n  output: \"autoSwitchLastRunOutput\",\n} as const;\n\nasync function shouldSkipForInterval(type: IOType) {\n  const lastRunRaw = await LocalStorage.getItem<string>(AUTO_SWITCH_LAST_RUN_KEYS[type]);\n  const lastRun = lastRunRaw ? Number(lastRunRaw) : undefined;\n  if (!lastRun || !Number.isFinite(lastRun)) return false;\n  const intervalMs = AUTO_SWITCH_INTERVAL_SECONDS * MS_PER_SECOND;\n  return Date.now() - lastRun < intervalMs;\n}\n\nasync function markLastRun(type: IOType) {\n  await LocalStorage.setItem(AUTO_SWITCH_LAST_RUN_KEYS[type], String(Date.now()));\n}\n\nasync function isAutoSwitchEnabled(type: IOType) {\n  return (await LocalStorage.getItem(AUTO_SWITCH_KEYS[type])) === \"true\";\n}\n\nasync function setAutoSwitchEnabled(type: IOType, enabled: boolean) {\n  await LocalStorage.setItem(AUTO_SWITCH_KEYS[type], enabled ? \"true\" : \"false\");\n}\n\nasync function maybeSwitchInput(hiddenDevices: string[]) {\n  const devices = await getInputDevices();\n  const order = await getDeviceOrder(\"input\");\n  const hiddenSet = new Set(hiddenDevices);\n  const ordered = applyDeviceOrder(order, devices).filter((device) => !hiddenSet.has(device.uid));\n  const target = ordered[0];\n  if (!target) return false;\n\n  const current = await getDefaultInputDevice();\n  if (current.uid === target.uid) return false;\n\n  await setDefaultInputDevice(target.id);\n  return true;\n}\n\nasync function maybeSwitchOutput(hiddenDevices: string[]) {\n  const devices = await getOutputDevices();\n  const order = await getDeviceOrder(\"output\");\n  const hiddenSet = new Set(hiddenDevices);\n  const ordered = applyDeviceOrder(order, devices).filter((device) => !hiddenSet.has(device.uid));\n  const target = ordered[0];\n  if (!target) return false;\n\n  const current = await getDefaultOutputDevice();\n  if (current.uid === target.uid) return false;\n\n  await setOutputAndSystemDevice(target.id);\n  return true;\n}\n\nasync function runSwitch(type: IOType) {\n  const hiddenDevices = await getHiddenDevices(type);\n  const changed = type === \"input\" ? await maybeSwitchInput(hiddenDevices) : await maybeSwitchOutput(hiddenDevices);\n\n  return changed;\n}\n\nexport async function applyAutoSwitchIfEnabled(type: IOType) {\n  const enabled = await isAutoSwitchEnabled(type);\n  if (!enabled) return false;\n\n  try {\n    return await runSwitch(type);\n  } catch {\n    return false;\n  }\n}\n\nexport async function runAutoSwitch(type: IOType) {\n  const isBackground = environment.launchType === LaunchType.Background;\n  const enabled = await isAutoSwitchEnabled(type);\n\n  if (!isBackground) {\n    const nextEnabled = !enabled;\n    await setAutoSwitchEnabled(type, nextEnabled);\n    await updateCommandMetadata({ subtitle: nextEnabled ? \"Enabled\" : \"Disabled\" });\n    await showHUD(nextEnabled ? \"Auto switch enabled\" : \"Auto switch disabled\");\n    if (!nextEnabled) return;\n  } else if (!enabled) {\n    await updateCommandMetadata({ subtitle: \"Disabled\" });\n    return;\n  } else {\n    await updateCommandMetadata({ subtitle: \"Enabled\" });\n  }\n\n  try {\n    if (isBackground && (await shouldSkipForInterval(type))) {\n      return;\n    }\n    await runSwitch(type);\n    if (isBackground) {\n      await markLastRun(type);\n    }\n  } catch (error) {\n    if (!isBackground) {\n      await showToast(\n        Toast.Style.Failure,\n        `Auto switch ${type === \"input\" ? \"input\" : \"output\"} failed`,\n        String(error),\n      );\n    }\n  }\n}\n", "export enum TransportType {\n  Avb = \"avb\",\n  Aggregate = \"aggregate\",\n  Airplay = \"airplay\",\n  Autoaggregate = \"autoaggregate\",\n  Bluetooth = \"bluetooth\",\n  BluetoothLowEnergy = \"bluetoothle\",\n  \"Built-In\" = \"builtin\",\n  DisplayPort = \"displayport\",\n  Firewire = \"firewire\",\n  HDMI = \"hdmi\",\n  PCI = \"pci\",\n  Thunderbolt = \"thunderbolt\",\n  Usb = \"usb\",\n  Virtual = \"virtual\",\n  Unknown = \"unknown\",\n  Headphones = \"headphones\",\n  Microphone = \"microphone\",\n  Speakers = \"speakers\",\n  SPDIF = \"spdif\",\n}\n\nexport type Platform = \"macOS\" | \"Windows\";\n\nexport const platform = (process.platform === \"win32\" ? \"Windows\" : \"macOS\") as Platform;\n\nexport const isMacOS = platform === \"macOS\";\nexport const isWindows = platform === \"Windows\";\n\nexport type AudioDevice = {\n  name: string;\n  isInput: boolean;\n  isOutput: boolean;\n  id: string;\n  uid: string;\n  transportType?: string;\n  index?: number;\n  isDefault?: boolean;\n  isCommunication?: boolean;\n};\n\nexport interface PlatformAudioAPI {\n  getAllDevices(): Promise<AudioDevice[]>;\n  getInputDevices(): Promise<AudioDevice[]>;\n  getOutputDevices(): Promise<AudioDevice[]>;\n  getDefaultOutputDevice(): Promise<AudioDevice>;\n  getDefaultInputDevice(): Promise<AudioDevice>;\n  getDefaultSystemDevice?: () => Promise<AudioDevice>;\n  setDefaultOutputDevice(deviceId: string): Promise<void>;\n  setDefaultInputDevice(deviceId: string): Promise<void>;\n  setDefaultSystemDevice?(deviceId: string): Promise<void>;\n  setDefaultCommunicationOutputDevice?(deviceId: string): Promise<void>;\n  setDefaultCommunicationInputDevice?(deviceId: string): Promise<void>;\n  setOutputDeviceVolume?(deviceId: string, volume: number): Promise<void>;\n  getOutputDeviceVolume?(deviceId: string): Promise<number | undefined>;\n  createAggregateDevice?: (\n    name: string,\n    mainDeviceId: string,\n    otherDeviceIds?: string[],\n    options?: { multiOutput?: boolean },\n  ) => Promise<AudioDevice>;\n  destroyAggregateDevice?(deviceId: string): Promise<void>;\n}\n\nlet apiInstance: PlatformAudioAPI | null = null;\n\nexport async function getAudioAPI(): Promise<PlatformAudioAPI> {\n  if (apiInstance) {\n    return apiInstance;\n  }\n\n  if (isMacOS) {\n    const { macosAudioAPI } = await import(\"./macos\");\n    apiInstance = macosAudioAPI;\n  } else if (isWindows) {\n    const { windowsAudioAPI } = await import(\"./windows\");\n    apiInstance = windowsAudioAPI;\n  } else {\n    throw new Error(`Unsupported platform: ${platform}`);\n  }\n\n  return apiInstance;\n}\n", "import { TransportType, type AudioDevice, isMacOS, isWindows, getAudioAPI } from \"./platform\";\n\n// Re-export from platform module\nexport { TransportType, type AudioDevice, isMacOS, isWindows, getAudioAPI };\n\nlet apiInstance: Awaited<ReturnType<typeof getAudioAPI>> | null = null;\n\nasync function getAPI() {\n  if (!apiInstance) {\n    apiInstance = await getAudioAPI();\n  }\n  return apiInstance;\n}\n\nexport async function getAllDevices(): Promise<AudioDevice[]> {\n  const api = await getAPI();\n  return api.getAllDevices();\n}\n\nexport async function getInputDevices(): Promise<AudioDevice[]> {\n  const api = await getAPI();\n  return api.getInputDevices();\n}\n\nexport async function getOutputDevices(): Promise<AudioDevice[]> {\n  const api = await getAPI();\n  return api.getOutputDevices();\n}\n\nexport async function getDefaultOutputDevice(): Promise<AudioDevice> {\n  const api = await getAPI();\n  return api.getDefaultOutputDevice();\n}\n\nexport async function getDefaultInputDevice(): Promise<AudioDevice> {\n  const api = await getAPI();\n  return api.getDefaultInputDevice();\n}\n\nexport async function getDefaultSystemDevice(): Promise<AudioDevice> {\n  const api = await getAPI();\n  if (api.getDefaultSystemDevice) {\n    return api.getDefaultSystemDevice();\n  }\n  throw new Error(\"System device is not supported on this platform\");\n}\n\nexport async function setDefaultOutputDevice(deviceId: string) {\n  const api = await getAPI();\n  return api.setDefaultOutputDevice(deviceId);\n}\n\nexport async function setDefaultInputDevice(deviceId: string) {\n  const api = await getAPI();\n  return api.setDefaultInputDevice(deviceId);\n}\n\nexport async function setDefaultSystemDevice(deviceId: string) {\n  const api = await getAPI();\n  if (api.setDefaultSystemDevice) {\n    return api.setDefaultSystemDevice(deviceId);\n  }\n  // Silently ignore on platforms that don't support system device\n  return Promise.resolve();\n}\n\nexport async function getOutputDeviceVolume(deviceId: string) {\n  const api = await getAPI();\n  if (api.getOutputDeviceVolume) {\n    return api.getOutputDeviceVolume(deviceId);\n  }\n  return undefined;\n}\n\nexport async function setOutputDeviceVolume(deviceId: string, volume: number) {\n  const api = await getAPI();\n  if (api.setOutputDeviceVolume) {\n    return api.setOutputDeviceVolume(deviceId, volume);\n  }\n}\n\nexport async function createAggregateDevice(\n  name: string,\n  mainDeviceId: string,\n  otherDeviceIds?: string[],\n  options?: { multiOutput?: boolean },\n): Promise<AudioDevice> {\n  const api = await getAPI();\n  if (api.createAggregateDevice) {\n    return api.createAggregateDevice(name, mainDeviceId, otherDeviceIds, options);\n  }\n  throw new Error(\"Aggregate devices are not supported on this platform\");\n}\n\nexport async function destroyAggregateDevice(deviceId: string) {\n  const api = await getAPI();\n  if (api.destroyAggregateDevice) {\n    return api.destroyAggregateDevice(deviceId);\n  }\n  throw new Error(\"Aggregate devices are not supported on this platform\");\n}\n", "import { getPreferenceValues } from \"@raycast/api\";\nimport { setDefaultOutputDevice, setDefaultSystemDevice } from \"./audio-device\";\n\nexport async function setOutputAndSystemDevice(deviceId: string) {\n  const { systemOutput } = getPreferenceValues();\n  await setDefaultOutputDevice(deviceId);\n  if (systemOutput) {\n    await setDefaultSystemDevice(deviceId);\n  }\n}\n", "export const AUTO_SWITCH_KEYS = {\n  input: \"autoSwitchInputEnabled\",\n  output: \"autoSwitchOutputEnabled\",\n} as const;\n", "import { LocalStorage } from \"@raycast/api\";\nimport type { AudioDevice } from \"./audio-device\";\n\ntype IOType = \"input\" | \"output\";\n\nconst LEGACY_DISABLED_DEVICES_KEY = \"disabledDevices\";\nconst LEGACY_HIDDEN_DEVICES_KEY = \"hiddenDevices\";\nconst LEGACY_SHOW_HIDDEN_KEY = \"showHiddenDevices\";\nconst HIDDEN_DEVICES_KEYS = {\n  input: \"hiddenDevicesInput\",\n  output: \"hiddenDevicesOutput\",\n} as const;\nconst SHOW_HIDDEN_KEYS = {\n  input: \"showHiddenDevicesInput\",\n  output: \"showHiddenDevicesOutput\",\n} as const;\nconst INPUT_ORDER_KEY = \"deviceOrderInput\";\nconst OUTPUT_ORDER_KEY = \"deviceOrderOutput\";\n\nfunction parseStoredList(value: string | null | undefined): string[] {\n  if (!value) return [];\n  try {\n    const parsed = JSON.parse(value);\n    return Array.isArray(parsed) ? parsed : [];\n  } catch {\n    return [];\n  }\n}\n\nasync function readList(key: string): Promise<string[]> {\n  return parseStoredList(await LocalStorage.getItem<string>(key));\n}\n\nasync function writeList(key: string, list: string[]) {\n  await LocalStorage.setItem(key, JSON.stringify(list));\n}\n\nfunction mergeUnique(...lists: string[][]): string[] {\n  return Array.from(new Set(lists.flat()));\n}\n\nasync function migrateHiddenDevices(type: IOType): Promise<string[]> {\n  const storedRaw = await LocalStorage.getItem<string>(HIDDEN_DEVICES_KEYS[type]);\n  if (storedRaw != null) return parseStoredList(storedRaw);\n\n  const legacyHidden = await readList(LEGACY_HIDDEN_DEVICES_KEY);\n  const legacyDisabled = await readList(LEGACY_DISABLED_DEVICES_KEY);\n  const merged = mergeUnique(legacyHidden, legacyDisabled);\n  if (merged.length > 0) {\n    await writeList(HIDDEN_DEVICES_KEYS[type], merged);\n  }\n  return merged;\n}\n\nexport async function getHiddenDevices(type: IOType): Promise<string[]> {\n  return migrateHiddenDevices(type);\n}\n\nexport async function setHiddenDevices(type: IOType, list: string[]) {\n  await writeList(HIDDEN_DEVICES_KEYS[type], list);\n}\n\nexport async function toggleDeviceVisibility(type: IOType, deviceId: string) {\n  const hidden = await getHiddenDevices(type);\n  const index = hidden.indexOf(deviceId);\n  if (index === -1) {\n    hidden.push(deviceId);\n  } else {\n    hidden.splice(index, 1);\n  }\n  await setHiddenDevices(type, hidden);\n}\n\nexport async function isShowingHiddenDevices(type: IOType) {\n  const stored = await LocalStorage.getItem<string>(SHOW_HIDDEN_KEYS[type]);\n  if (stored != null) return stored === \"true\";\n  const legacy = await LocalStorage.getItem<string>(LEGACY_SHOW_HIDDEN_KEY);\n  if (legacy != null) {\n    await LocalStorage.setItem(SHOW_HIDDEN_KEYS[type], legacy);\n  }\n  return legacy === \"true\";\n}\n\nexport async function setShowHiddenDevices(type: IOType, show: boolean) {\n  await LocalStorage.setItem(SHOW_HIDDEN_KEYS[type], show ? \"true\" : \"false\");\n}\n\nexport async function getDeviceOrder(type: \"input\" | \"output\"): Promise<string[]> {\n  return readList(type === \"input\" ? INPUT_ORDER_KEY : OUTPUT_ORDER_KEY);\n}\n\nexport async function setDeviceOrder(type: \"input\" | \"output\", order: string[]) {\n  await writeList(type === \"input\" ? INPUT_ORDER_KEY : OUTPUT_ORDER_KEY, order);\n}\n\nexport function normalizeDeviceOrder(order: string[], devices: AudioDevice[]): string[] {\n  const deviceIds = devices.map((device) => device.uid);\n  const filtered = order.filter((id) => deviceIds.includes(id));\n  const missing = deviceIds.filter((id) => !filtered.includes(id));\n  return [...filtered, ...missing];\n}\n\nexport function applyDeviceOrder(order: string[], devices: AudioDevice[]): AudioDevice[] {\n  const normalized = normalizeDeviceOrder(order, devices);\n  const deviceMap = new Map(devices.map((device) => [device.uid, device]));\n  return normalized.map((id) => deviceMap.get(id)).filter(Boolean) as AudioDevice[];\n}\n"],
  "mappings": "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,CACA,KAAK,UACL,OAAO,EACP,OAAO,OACP,YAAY,UACZ,SAAS,MACT,EACA,CACA,KAAK,SACL,OAAO,EACP,OAAO,OACP,YAAY,UACZ,SAAS,KACT,EACA,CACA,KAAK,SACL,OAAO,EACP,OAAO,OACP,YACA,oEACA,SAAS,KACT,EACA,CACA,KAAK,SACL,OAAO,EACP,OAAO,YACP,YAAY,oDACZ,SAAS,OACT,EACA,CACA,KAAK,SACL,OAAO,EACP,OAAO,OACP,YAAY,kCACZ,SAAS,MACT,EACA,CACA,KAAK,UACL,OAAO,EACP,OAAO,YACP,YAAY,qBACZ,SAAS,QACT,OAAO,EACP,EACA,CACA,KAAK,UACL,OAAO,GACP,OAAO,YACP,YAAY,8BACZ,SAAS,OACT,EACA,CACA,KAAK,UACL,OAAO,GACP,OAAO,OACP,YAAY,qBACZ,SAAS,MACT,EACA,CACA,KAAK,UACL,OAAO,GACP,OAAO,YACP,YAAY,8BACZ,SAAS,OACT,EACA,CACA,KAAK,UACL,OAAO,GACP,OAAO,YACP,YAAY,wBACZ,SAAS,OACT,EACA,CACA,KAAK,UACL,OAAO,GACP,OAAO,YACP,YAAY,mBACZ,SAAS,OACT,EACA,CACA,KAAK,UACL,OAAO,GACP,OAAO,YACP,YAAY,cACZ,SAAS,MACT,EACA,CACA,KAAK,YACL,OAAO,GACP,OAAO,YACP,YAAY,+BACZ,SAAS,OACT,EACA,CACA,KAAK,UACL,OAAO,GACP,OAAO,SACP,YAAY,+CACZ,SAAS,OACT,EACA,CACA,KAAK,SACL,OAAO,GACP,OAAO,SACP,YAAY,+CACZ,SAAS,OACT,EACA,CACA,KAAK,UACL,OAAO,GACP,OAAO,UACP,YAAY,WACZ,SAAS,QACT,OAAO,EACP,EACA,CACA,KAAK,UACL,OAAO,GACP,OAAO,QACP,YAAY,SACZ,SAAS,QACT,OAAO,EACP,EACA,CACA,KAAK,UACL,OAAO,GACP,OAAO,QACP,YAAY,mCACZ,SAAS,OACT,EACA,CACA,KAAK,UACL,OAAO,GACP,OAAO,QACP,YAAY,gDACZ,SAAS,OACT,EACA,CACA,KAAK,WACL,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",
  "names": ["isPlainObject", "value", "prototype", "init_is_plain_obj", "__esmMin", "import_node_url", "safeNormalizeFileUrl", "normalizeDenoExecPath", "isDenoExecPath", "normalizeFileUrl", "init_file_url", "__esmMin", "file", "name", "fileString", "normalizeParameters", "init_parameters", "__esmMin", "init_is_plain_obj", "init_file_url", "rawFile", "rawArguments", "rawOptions", "filePath", "safeNormalizeFileUrl", "commandArguments", "options", "isPlainObject", "commandArgument", "normalizedArguments", "nullByteArgument", "normalizedArgument", "import_node_string_decoder", "objectToString", "isArrayBuffer", "isUint8Array", "bufferToUint8Array", "textEncoder", "stringToUint8Array", "textDecoder", "uint8ArrayToString", "joinToString", "uint8ArraysToStrings", "joinToUint8Array", "stringsToUint8Arrays", "concatUint8Arrays", "getJoinLength", "init_uint_array", "__esmMin", "value", "buffer", "string", "uint8Array", "uint8ArraysOrStrings", "encoding", "uint8ArrayOrString", "decoder", "strings", "finalString", "uint8Arrays", "result", "index", "joinLength", "import_node_child_process", "isTemplateString", "parseTemplates", "parseTemplate", "splitByWhitespaces", "DELIMITERS", "ESCAPE_LENGTH", "concatTokens", "parseExpression", "getSubprocessResult", "init_template", "__esmMin", "init_is_plain_obj", "init_uint_array", "templates", "expressions", "tokens", "index", "template", "file", "commandArguments", "nextTokens", "leadingWhitespaces", "trailingWhitespaces", "newTokens", "expression", "expressionTokens", "rawTemplate", "templateStart", "templateIndex", "rawIndex", "rawCharacter", "nextRawCharacter", "isSeparated", "typeOfExpression", "isPlainObject", "stdout", "isUint8Array", "uint8ArrayToString", "import_node_process", "isStandardStream", "STANDARD_STREAMS", "STANDARD_STREAMS_ALIASES", "getStreamName", "init_standard_stream", "__esmMin", "stream", "process", "fdNumber", "import_node_util", "normalizeFdSpecificOptions", "normalizeFdSpecificOption", "getStdioLength", "normalizeFdSpecificValue", "normalizeOptionObject", "compareFdName", "getFdNameOrder", "parseFdName", "parseFd", "FD_REGEXP", "addDefaultValue", "verboseDefault", "DEFAULT_OPTIONS", "FD_SPECIFIC_OPTIONS", "getFdSpecificValue", "init_specific", "__esmMin", "init_is_plain_obj", "init_standard_stream", "options", "optionsCopy", "optionName", "optionBaseArray", "optionArray", "stdio", "STANDARD_STREAMS_ALIASES", "optionValue", "isPlainObject", "fdName", "fdNumber", "fdNameA", "fdNameB", "regexpResult", "isVerbose", "isFullVerbose", "getVerboseFunction", "getFdVerbose", "getFdGenericVerbose", "isVerboseFunction", "VERBOSE_VALUES", "init_values", "__esmMin", "init_specific", "verbose", "fdNumber", "fdVerbose", "getFdSpecificValue", "import_node_process", "import_node_util", "joinCommand", "escapeLines", "escapeControlCharacters", "escapeControlCharacter", "getSpecialCharRegExp", "SPECIAL_CHAR_REGEXP", "COMMON_ESCAPES", "ASTRAL_START", "quoteString", "NO_ESCAPE_REGEXP", "init_escape", "__esmMin", "filePath", "rawArguments", "fileAndArguments", "command", "escapedCommand", "fileAndArgument", "lines", "line", "character", "commonEscape", "codepoint", "codepointHex", "escapedArgument", "isUnicodeSupported", "env", "process", "TERM", "TERM_PROGRAM", "import_node_process", "init_is_unicode_supported", "__esmMin", "common", "specialMainSymbols", "specialFallbackSymbols", "mainSymbols", "fallbackSymbols", "shouldUseMain", "figures", "figures_default", "replacements", "init_figures", "__esmMin", "init_is_unicode_supported", "isUnicodeSupported", "import_node_tty", "hasColors", "format", "reset", "bold", "dim", "italic", "underline", "overline", "inverse", "hidden", "strikethrough", "black", "red", "green", "yellow", "blue", "magenta", "cyan", "white", "gray", "bgBlack", "bgRed", "bgGreen", "bgYellow", "bgBlue", "bgMagenta", "bgCyan", "bgWhite", "bgGray", "redBright", "greenBright", "yellowBright", "blueBright", "magentaBright", "cyanBright", "whiteBright", "bgRedBright", "bgGreenBright", "bgYellowBright", "bgBlueBright", "bgMagentaBright", "bgCyanBright", "bgWhiteBright", "init_base", "__esmMin", "tty", "open", "close", "input", "openCode", "closeCode", "string", "index", "result", "lastIndex", "replaceCode", "init_yoctocolors", "__esmMin", "init_base", "defaultVerboseFunction", "serializeTimestamp", "padField", "getFinalIcon", "ICONS", "identity", "COLORS", "init_default", "__esmMin", "init_figures", "init_yoctocolors", "type", "message", "timestamp", "piped", "commandId", "failed", "reject", "timestampString", "icon", "color", "gray", "field", "padding", "figures_default", "string", "bold", "redBright", "yellowBright", "applyVerboseOnLines", "applyVerboseFunction", "appendNewline", "init_custom", "__esmMin", "init_values", "printedLines", "verboseInfo", "fdNumber", "verboseFunction", "getVerboseFunction", "verboseLine", "verboseObject", "printedLine", "import_node_util", "verboseLog", "getVerboseObject", "getPrintedLines", "getPrintedLine", "serializeVerboseMessage", "TAB_SIZE", "init_log", "__esmMin", "init_escape", "init_default", "init_custom", "type", "verboseMessage", "fdNumber", "verboseInfo", "result", "verboseObject", "printedLines", "finalLines", "applyVerboseOnLines", "escapedCommand", "commandId", "piped", "options", "message", "defaultVerboseFunction", "messageString", "escapeLines", "logCommand", "init_start", "__esmMin", "init_values", "init_log", "escapedCommand", "verboseInfo", "isVerbose", "verboseLog", "getVerboseInfo", "getCommandId", "COMMAND_ID", "validateVerbose", "init_info", "__esmMin", "init_values", "verbose", "escapedCommand", "rawOptions", "commandId", "isVerbose", "fdVerbose", "VERBOSE_VALUES", "isVerboseFunction", "allowedValues", "allowedValue", "import_node_process", "getStartTime", "getDurationMs", "init_duration", "__esmMin", "startTime", "handleCommand", "init_command", "__esmMin", "init_start", "init_info", "init_duration", "init_escape", "init_specific", "filePath", "rawArguments", "rawOptions", "startTime", "getStartTime", "command", "escapedCommand", "joinCommand", "verbose", "normalizeFdSpecificOption", "verboseInfo", "getVerboseInfo", "logCommand", "require_windows", "__commonJSMin", "exports", "module", "isexe", "sync", "fs", "checkPathExt", "path", "options", "pathext", "i", "p", "checkStat", "stat", "cb", "er", "require_mode", "__commonJSMin", "exports", "module", "isexe", "sync", "fs", "path", "options", "cb", "er", "stat", "checkStat", "checkMode", "mod", "uid", "gid", "myUid", "myGid", "u", "g", "o", "ug", "ret", "require_isexe", "__commonJSMin", "exports", "module", "fs", "core", "isexe", "sync", "path", "options", "cb", "resolve", "reject", "er", "is", "require_which", "__commonJSMin", "exports", "module", "isWindows", "path", "COLON", "isexe", "getNotFoundError", "cmd", "getPathInfo", "opt", "colon", "pathEnv", "pathExtExe", "pathExt", "which", "cb", "found", "step", "i", "resolve", "reject", "ppRaw", "pathPart", "pCmd", "p", "subStep", "ii", "ext", "er", "is", "res", "whichSync", "j", "cur", "require_path_key", "__commonJSMin", "exports", "module", "pathKey", "options", "environment", "key", "require_resolveCommand", "__commonJSMin", "exports", "module", "path", "which", "getPathKey", "resolveCommandAttempt", "parsed", "withoutPathExt", "env", "cwd", "hasCustomCwd", "shouldSwitchCwd", "resolved", "resolveCommand", "require_escape", "__commonJSMin", "exports", "module", "metaCharsRegExp", "escapeCommand", "arg", "escapeArgument", "doubleEscapeMetaChars", "require_shebang_regex", "__commonJSMin", "exports", "module", "require_shebang_command", "__commonJSMin", "exports", "module", "shebangRegex", "string", "match", "path", "argument", "binary", "require_readShebang", "__commonJSMin", "exports", "module", "fs", "shebangCommand", "readShebang", "command", "buffer", "fd", "require_parse", "__commonJSMin", "exports", "module", "path", "resolveCommand", "escape", "readShebang", "isWin", "isExecutableRegExp", "isCmdShimRegExp", "detectShebang", "parsed", "shebang", "parseNonShell", "commandFile", "needsShell", "needsDoubleEscapeMetaChars", "arg", "shellCommand", "parse", "command", "args", "options", "require_enoent", "__commonJSMin", "exports", "module", "isWin", "notFoundError", "original", "syscall", "hookChildProcess", "cp", "parsed", "originalEmit", "name", "arg1", "err", "verifyENOENT", "status", "verifyENOENTSync", "require_cross_spawn", "__commonJSMin", "exports", "module", "cp", "parse", "enoent", "spawn", "command", "args", "options", "parsed", "spawned", "spawnSync", "result", "pathKey", "options", "env", "platform", "key", "init_path_key", "__esmMin", "init_default", "__esmMin", "toPath", "urlOrPath", "traversePathUp", "startPath", "currentPath", "path", "previousPath", "import_node_util", "import_node_child_process", "import_node_path", "import_node_url", "execFileOriginal", "TEN_MEGABYTES_IN_BYTES", "init_node", "__esmMin", "init_default", "execFileCallback", "import_node_process", "import_node_path", "npmRunPath", "applyPreferLocal", "applyExecPath", "npmRunPathEnv", "init_npm_run_path", "__esmMin", "init_path_key", "init_node", "cwd", "process", "pathOption", "pathKey", "preferLocal", "execPath", "addExecPath", "cwdPath", "path", "toPath", "result", "pathParts", "directory", "traversePathUp", "pathPart", "env", "options", "pathName", "getFinalError", "DiscardedError", "setErrorName", "isExecaError", "execaErrorSymbol", "isErrorInstance", "ExecaError", "ExecaSyncError", "init_final_error", "__esmMin", "originalError", "message", "isSync", "ErrorClass", "options", "value", "error", "getRealtimeSignals", "getRealtimeSignal", "SIGRTMIN", "SIGRTMAX", "init_realtime", "__esmMin", "length", "value", "index", "SIGNALS", "init_core", "__esmMin", "import_node_os", "getSignals", "normalizeSignal", "init_signals", "__esmMin", "init_core", "init_realtime", "realtimeSignals", "getRealtimeSignals", "SIGNALS", "name", "defaultNumber", "description", "action", "forced", "standard", "constantSignal", "supported", "import_node_os", "getSignalsByName", "getSignalByName", "signalsByName", "getSignalsByNumber", "getSignalByNumber", "findSignalByNumber", "signalsByNumber", "init_main", "__esmMin", "init_signals", "signals", "getSignals", "name", "number", "description", "supported", "action", "forced", "standard", "length", "signalsA", "value", "signal", "signalA", "import_node_os", "normalizeKillSignal", "normalizeSignalArgument", "normalizeSignal", "normalizeSignalInteger", "getSignalsIntegerToName", "signalsIntegerToName", "normalizeSignalName", "getAvailableSignals", "getAvailableSignalNames", "getAvailableSignalIntegers", "getSignalDescription", "init_signal", "__esmMin", "init_main", "killSignal", "optionName", "signal", "signalNameOrInteger", "signalInteger", "signalName", "signalIntegerTwo", "signalsByName", "import_promises", "normalizeForceKillAfterDelay", "DEFAULT_FORCE_KILL_TIMEOUT", "subprocessKill", "parseKillArguments", "emitKillError", "setKillTimeout", "killOnTimeout", "init_kill", "__esmMin", "init_final_error", "init_signal", "forceKillAfterDelay", "kill", "killSignal", "onInternalError", "context", "controller", "signalOrError", "errorArgument", "signal", "error", "killResult", "isErrorInstance", "normalizeSignalArgument", "controllerSignal", "import_node_events", "onAbortedSignal", "init_abort_signal", "__esmMin", "mainSignal", "stopSignal", "validateCancelSignal", "throwOnCancel", "terminateOnCancel", "init_cancel", "__esmMin", "init_abort_signal", "cancelSignal", "subprocess", "gracefulCancel", "context", "controller", "signal", "onAbortedSignal", "validateIpcMethod", "validateIpcOption", "validateConnection", "throwOnEarlyDisconnect", "throwOnStrictDeadlockError", "getStrictResponseError", "throwOnMissingStrict", "throwOnStrictDisconnect", "getAbortDisconnectError", "throwOnMissingParent", "handleEpipeError", "handleSerializationError", "isSerializationError", "SERIALIZATION_ERROR_CODES", "SERIALIZATION_ERROR_MESSAGES", "getMethodName", "getNamespaceName", "getOtherProcessName", "disconnect", "init_validation", "__esmMin", "methodName", "isSubprocess", "ipc", "isConnected", "error", "message", "code", "serializationErrorMessage", "parameters", "anyProcess", "createDeferred", "init_deferred", "__esmMin", "methods", "promise", "resolve", "reject", "getToStream", "getFromStream", "SUBPROCESS_OPTIONS", "getFdNumber", "parseFdNumber", "validateFdNumber", "getInvalidStdioOptionMessage", "getInvalidStdioOption", "getUsedDescriptor", "getOptionName", "serializeOptionValue", "init_fd_options", "__esmMin", "init_specific", "destination", "to", "options", "fileDescriptors", "fdNumber", "destinationStream", "source", "from", "sourceStream", "fdName", "isWritable", "parseFd", "validOptions", "defaultValue", "fileDescriptor", "optionName", "optionValue", "stdin", "stdout", "stderr", "stdio", "usedDescriptor", "value", "import_node_events", "incrementMaxListeners", "init_max_listeners", "__esmMin", "eventEmitter", "maxListenersIncrement", "signal", "maxListeners", "addReference", "addReferenceCount", "removeReference", "removeReferenceCount", "undoAddedReferences", "redoAddedReferences", "init_reference", "__esmMin", "channel", "reference", "isSubprocess", "import_node_events", "import_promises", "onMessage", "onDisconnect", "INCOMING_MESSAGES", "init_incoming", "__esmMin", "init_outgoing", "init_reference", "init_strict", "init_graceful", "anyProcess", "channel", "isSubprocess", "ipcEmitter", "wrappedMessage", "handleStrictResponse", "handleAbort", "incomingMessages", "waitForOutgoingMessages", "message", "handleStrictRequest", "boundOnMessage", "abortOnDisconnect", "redoAddedReferences", "import_node_events", "getIpcEmitter", "IPC_EMITTERS", "forwardEvents", "isConnected", "init_forward", "__esmMin", "init_incoming", "init_reference", "anyProcess", "channel", "isSubprocess", "ipcEmitter", "boundOnMessage", "onMessage", "onDisconnect", "undoAddedReferences", "import_node_events", "handleSendStrict", "count", "validateStrictDeadlock", "handleStrictRequest", "handleStrictResponse", "waitForStrictResponse", "STRICT_RESPONSES", "throwOnDisconnect", "REQUEST_TYPE", "RESPONSE_TYPE", "init_strict", "__esmMin", "init_deferred", "init_max_listeners", "init_send", "init_validation", "init_forward", "init_outgoing", "anyProcess", "channel", "isSubprocess", "message", "strict", "ipcEmitter", "getIpcEmitter", "hasListeners", "hasMessageListeners", "outgoingMessages", "wrappedMessage", "id", "response", "sendMessage", "error", "deferred", "createDeferred", "controller", "isDeadlock", "throwOnStrictDeadlockError", "throwOnMissingStrict", "signal", "incrementMaxListeners", "throwOnStrictDisconnect", "startSendMessage", "endSendMessage", "waitForOutgoingMessages", "OUTGOING_MESSAGES", "hasMessageListeners", "getMinListenerCount", "init_outgoing", "__esmMin", "init_deferred", "init_specific", "init_fd_options", "init_strict", "anyProcess", "wrappedMessage", "strict", "outgoingMessages", "onMessageSent", "createDeferred", "id", "outgoingMessage", "ipcEmitter", "validateStrictDeadlock", "SUBPROCESS_OPTIONS", "getFdSpecificValue", "import_node_util", "sendMessage", "sendMessageAsync", "sendOneMessage", "getSendMethod", "PROCESS_SEND_METHODS", "init_send", "__esmMin", "init_validation", "init_outgoing", "init_strict", "anyProcess", "channel", "isSubprocess", "ipc", "message", "strict", "methodName", "validateIpcMethod", "wrappedMessage", "handleSendStrict", "outgoingMessagesState", "startSendMessage", "error", "disconnect", "endSendMessage", "sendMethod", "waitForStrictResponse", "handleEpipeError", "handleSerializationError", "import_promises", "sendAbort", "getCancelSignal", "startIpc", "cancelListening", "handleAbort", "GRACEFUL_CANCEL_TYPE", "abortOnDisconnect", "cancelController", "init_graceful", "__esmMin", "init_send", "init_forward", "init_validation", "subprocess", "message", "methodName", "validateConnection", "sendOneMessage", "anyProcess", "channel", "isSubprocess", "ipc", "throwOnMissingParent", "getIpcEmitter", "wrappedMessage", "getAbortDisconnectError", "validateGracefulCancel", "throwOnGracefulCancel", "sendOnAbort", "getReason", "init_graceful", "__esmMin", "init_abort_signal", "init_kill", "gracefulCancel", "cancelSignal", "ipc", "serialization", "subprocess", "forceKillAfterDelay", "context", "controller", "signal", "onAbortedSignal", "reason", "sendAbort", "killOnTimeout", "error", "import_promises", "validateTimeout", "throwOnTimeout", "killAfterTimeout", "init_timeout", "__esmMin", "init_final_error", "timeout", "subprocess", "context", "controller", "signal", "DiscardedError", "import_node_process", "import_node_path", "mapNode", "handleNodeOption", "init_node", "__esmMin", "init_file_url", "options", "file", "commandArguments", "shouldHandleNode", "nodePath", "nodeOptions", "nodeOption", "cwd", "formerNodePath", "normalizedNodePath", "safeNormalizeFileUrl", "resolvedNodePath", "path", "newOptions", "import_node_v8", "validateIpcInputOption", "validateAdvancedInput", "validateJsonInput", "validateIpcInput", "sendIpcInput", "init_ipc_input", "__esmMin", "ipcInput", "ipc", "serialization", "error", "subprocess", "validateEncoding", "TEXT_ENCODINGS", "BINARY_ENCODINGS", "ENCODINGS", "getCorrectEncoding", "ENCODING_ALIASES", "serializeEncoding", "init_encoding_option", "__esmMin", "encoding", "correctEncoding", "correctEncodings", "lowerEncoding", "import_node_fs", "import_node_path", "import_node_process", "normalizeCwd", "getDefaultCwd", "fixCwdError", "init_cwd", "__esmMin", "init_file_url", "cwd", "cwdString", "safeNormalizeFileUrl", "path", "process", "error", "originalMessage", "cwdStat", "import_node_path", "import_node_process", "import_cross_spawn", "normalizeOptions", "addDefaultOptions", "getEnv", "init_options", "__esmMin", "init_npm_run_path", "init_kill", "init_signal", "init_cancel", "init_graceful", "init_timeout", "init_node", "init_ipc_input", "init_encoding_option", "init_cwd", "init_file_url", "init_specific", "filePath", "rawArguments", "rawOptions", "normalizeCwd", "processedFile", "processedArguments", "processedOptions", "handleNodeOption", "file", "commandArguments", "initialOptions", "crossSpawn", "fdOptions", "normalizeFdSpecificOptions", "options", "validateTimeout", "validateEncoding", "validateIpcInputOption", "validateCancelSignal", "validateGracefulCancel", "normalizeFileUrl", "normalizeKillSignal", "normalizeForceKillAfterDelay", "lines", "fdNumber", "BINARY_ENCODINGS", "process", "path", "extendEnv", "preferLocal", "cwd", "localDirectory", "encoding", "reject", "cleanup", "all", "windowsHide", "killSignal", "forceKillAfterDelay", "gracefulCancel", "ipcInput", "ipc", "serialization", "envOption", "node", "nodePath", "env", "npmRunPathEnv", "concatenateShell", "init_shell", "__esmMin", "file", "commandArguments", "options", "stripFinalNewline", "input", "stripFinalNewlineString", "stripFinalNewlineBinary", "LF", "LF_BINARY", "CR", "CR_BINARY", "init_strip_final_newline", "__esmMin", "isStream", "stream", "checkOpen", "isWritableStream", "isReadableStream", "isDuplexStream", "options", "init_is_stream", "__esmMin", "i", "n", "o", "r", "h", "e", "t", "c", "s", "u", "a", "init_asyncIterator", "__esmMin", "#n", "#r", "#e", "#s", "#i", "init_fromAnyIterable", "__esmMin", "init_ponyfill", "__esmMin", "init_asyncIterator", "init_fromAnyIterable", "getAsyncIterable", "toString", "getStreamIterable", "handleStreamEnd", "nodeImports", "init_stream", "__esmMin", "init_is_stream", "init_ponyfill", "stream", "isReadableStream", "h", "controller", "state", "chunk", "error", "getStreamContents", "appendFinalChunk", "appendChunk", "addNewChunk", "getChunkType", "objectToString", "MaxBufferError", "init_contents", "__esmMin", "init_stream", "stream", "init", "convertChunk", "getSize", "truncateChunk", "addChunk", "getFinalChunk", "finalize", "maxBuffer", "asyncIterable", "getAsyncIterable", "state", "chunk", "chunkType", "convertedChunk", "error", "normalizedError", "chunkSize", "newLength", "truncatedChunk", "typeOfChunk", "prototypeName", "identity", "noop", "getContentsProperty", "throwObjectStream", "getLengthProperty", "init_utils", "__esmMin", "value", "contents", "chunk", "convertedChunk", "getStreamAsArray", "stream", "options", "getStreamContents", "arrayMethods", "initArray", "increment", "addArrayChunk", "init_array", "__esmMin", "init_contents", "init_utils", "convertedChunk", "contents", "identity", "noop", "getContentsProperty", "getStreamAsArrayBuffer", "stream", "options", "getStreamContents", "arrayBufferMethods", "initArrayBuffer", "useTextEncoder", "textEncoder", "useUint8Array", "useUint8ArrayWithOffset", "truncateArrayBufferChunk", "addArrayBufferChunk", "resizeArrayBufferSlow", "resizeArrayBuffer", "getNewContentsLength", "SCALE_FACTOR", "finalizeArrayBuffer", "hasArrayBufferResize", "init_array_buffer", "__esmMin", "init_contents", "init_utils", "chunk", "convertedChunk", "chunkSize", "contents", "previousLength", "length", "newContents", "arrayBuffer", "throwObjectStream", "getLengthProperty", "noop", "getStreamAsString", "stream", "options", "getStreamContents", "stringMethods", "initString", "useTextDecoder", "addStringChunk", "truncateStringChunk", "getFinalStringChunk", "init_string", "__esmMin", "init_contents", "init_utils", "chunk", "textDecoder", "convertedChunk", "contents", "chunkSize", "finalChunk", "identity", "throwObjectStream", "getLengthProperty", "getContentsProperty", "init_exports", "__esmMin", "init_array", "init_array_buffer", "init_string", "init_contents", "import_node_events", "import_promises", "init_source", "__esmMin", "init_stream", "init_exports", "nodeImports", "handleMaxBuffer", "getMaxBufferUnit", "checkIpcMaxBuffer", "getMaxBufferMessage", "getMaxBufferInfo", "isMaxBufferSync", "truncateMaxBufferSync", "getMaxBufferSync", "init_max_buffer", "__esmMin", "init_source", "init_standard_stream", "init_specific", "error", "stream", "readableObjectMode", "lines", "encoding", "fdNumber", "MaxBufferError", "unit", "subprocess", "ipcOutput", "maxBuffer", "streamName", "threshold", "getFdSpecificValue", "getStreamName", "resultError", "output", "result", "isMaxBuffer", "maxBufferValue", "stdoutMaxBuffer", "import_node_util", "createMessages", "getErrorPrefix", "getForcefulSuffix", "getOriginalMessage", "serializeIpcMessage", "serializeMessagePart", "serializeMessageItem", "init_message", "__esmMin", "init_strip_final_newline", "init_uint_array", "init_cwd", "init_escape", "init_max_buffer", "init_signal", "init_final_error", "stdio", "all", "ipcOutput", "originalError", "signal", "signalDescription", "exitCode", "escapedCommand", "timedOut", "isCanceled", "isGracefullyCanceled", "isMaxBuffer", "isForcefullyTerminated", "forceKillAfterDelay", "killSignal", "maxBuffer", "timeout", "cwd", "errorCode", "prefix", "originalMessage", "suffix", "shortMessage", "messageStdio", "message", "ipcMessage", "messagePart", "escapeLines", "stripFinalNewline", "forcefulSuffix", "getMaxBufferMessage", "getSignalDescription", "DiscardedError", "isExecaError", "escapedOriginalMessage", "fixCwdError", "messageItem", "isUint8Array", "uint8ArrayToString", "makeSuccessResult", "makeEarlyError", "makeError", "getErrorProperties", "omitUndefinedProperties", "normalizeExitPayload", "init_result", "__esmMin", "init_signal", "init_duration", "init_final_error", "init_message", "command", "escapedCommand", "stdio", "all", "ipcOutput", "cwd", "startTime", "getDurationMs", "error", "fileDescriptors", "options", "isSync", "originalError", "timedOut", "isCanceled", "isGracefullyCanceled", "isMaxBuffer", "isForcefullyTerminated", "rawExitCode", "rawSignal", "timeoutDuration", "timeout", "forceKillAfterDelay", "killSignal", "maxBuffer", "exitCode", "signal", "signalDescription", "originalMessage", "shortMessage", "message", "createMessages", "getFinalError", "result", "value", "getSignalDescription", "parseNumber", "milliseconds", "toZeroIfInfinity", "parseBigint", "parseMilliseconds", "init_parse_ms", "__esmMin", "value", "prettyMilliseconds", "milliseconds", "options", "isBigInt", "sign", "result", "floorDecimals", "value", "decimalDigits", "flooredInterimValue", "SECOND_ROUNDING_EPSILON", "add", "long", "short", "valueString", "isZero", "wholeDigits", "minLength", "pluralize", "parsed", "parseMilliseconds", "days", "seconds", "microseconds", "nanoseconds", "millisecondsAndBelow", "millisecondsDecimalDigits", "roundedMilliseconds", "millisecondsString", "ONE_DAY_IN_MILLISECONDS", "secondsDecimalDigits", "secondsFixed", "secondsString", "separator", "init_pretty_ms", "__esmMin", "init_parse_ms", "word", "count", "logError", "init_error", "__esmMin", "init_log", "result", "verboseInfo", "verboseLog", "logResult", "logDuration", "init_complete", "__esmMin", "init_pretty_ms", "init_values", "init_log", "init_error", "result", "verboseInfo", "isVerbose", "logError", "verboseMessage", "prettyMilliseconds", "verboseLog", "handleResult", "init_reject", "__esmMin", "init_complete", "result", "verboseInfo", "reject", "logResult", "getStdioItemType", "getTransformObjectType", "getDuplexType", "getTransformStreamType", "validateNonGeneratorType", "checkUndefinedOption", "getGeneratorObjectType", "checkBooleanOption", "isGenerator", "isAsyncGenerator", "isSyncGenerator", "isTransformOptions", "isUrl", "isRegularUrl", "isFilePathObject", "FILE_PATH_KEYS", "isFilePathString", "isUnknownStdioString", "KNOWN_STDIO_STRINGS", "isReadableStream", "isWritableStream", "isWebStream", "isTransformStream", "isAsyncIterableObject", "isIterableObject", "isObject", "TRANSFORM_TYPES", "FILE_TYPES", "SPECIAL_DUPLICATE_TYPES_SYNC", "SPECIAL_DUPLICATE_TYPES", "FORBID_DUPLICATE_TYPES", "TYPE_TO_MESSAGE", "init_type", "__esmMin", "init_is_stream", "init_is_plain_obj", "init_uint_array", "value", "optionName", "isStream", "isUint8Array", "isDuplexStream", "final", "binary", "objectMode", "typeName", "transform", "isPlainObject", "key", "file", "type", "getTransformObjectModes", "getOutputObjectModes", "getInputObjectModes", "getFdObjectMode", "init_object_mode", "__esmMin", "init_type", "objectMode", "index", "newTransforms", "direction", "writableObjectMode", "readableObjectMode", "stdioItems", "lastTransform", "type", "TRANSFORM_TYPES", "normalizeTransforms", "getTransforms", "normalizeTransform", "normalizeDuplex", "normalizeTransformStream", "normalizeGenerator", "sortTransforms", "init_normalize", "__esmMin", "init_is_plain_obj", "init_encoding_option", "init_type", "init_object_mode", "stdioItems", "optionName", "direction", "options", "type", "TRANSFORM_TYPES", "encoding", "transforms", "newTransforms", "index", "stdioItem", "transform", "writableObjectMode", "readableObjectMode", "objectMode", "value", "isPlainObject", "getTransformObjectModes", "final", "binaryOption", "preserveNewlines", "binary", "BINARY_ENCODINGS", "import_node_process", "getStreamDirection", "getStdioItemDirection", "KNOWN_DIRECTIONS", "anyDirection", "alwaysInput", "guessStreamDirection", "getStandardStreamDirection", "DEFAULT_DIRECTION", "init_direction", "__esmMin", "init_is_stream", "init_type", "stdioItems", "fdNumber", "optionName", "directions", "stdioItem", "type", "value", "isWritableStream", "isReadableStream", "standardStreamDirection", "isStream", "process", "normalizeIpcStdioArray", "init_array", "__esmMin", "stdioArray", "ipc", "normalizeStdioOption", "getStdioArray", "hasAlias", "addDefaultValue", "normalizeStdioSync", "isOutputPipeOnly", "init_stdio_option", "__esmMin", "init_standard_stream", "init_array", "init_values", "stdio", "ipc", "buffer", "options", "verboseInfo", "isSync", "stdioArray", "stdioOption", "fdNumber", "normalizeIpcStdioArray", "STANDARD_STREAMS_ALIASES", "alias", "length", "_", "item", "isFullVerbose", "import_node_fs", "import_node_tty", "handleNativeStream", "handleNativeStreamSync", "getTargetFd", "getTargetFdNumber", "handleNativeStreamAsync", "getStandardStream", "init_native", "__esmMin", "init_is_stream", "init_standard_stream", "init_uint_array", "init_fd_options", "stdioItem", "type", "isStdioArray", "fdNumber", "direction", "isSync", "value", "optionName", "targetFd", "isStream", "targetFdNumber", "tty", "serializeOptionValue", "bufferToUint8Array", "standardStreamIndex", "STANDARD_STREAMS", "standardStream", "handleInputOptions", "handleInputOption", "getInputType", "handleInputFileOption", "getInputFileType", "init_input_option", "__esmMin", "init_is_stream", "init_uint_array", "init_type", "input", "inputFile", "fdNumber", "isReadableStream", "isUint8Array", "isUrl", "isFilePathString", "filterDuplicates", "getDuplicateStream", "getOtherStdioItems", "validateDuplicateStreamSync", "getDuplicateStreamInstance", "hasSameValue", "validateDuplicateTransform", "throwOnDuplicateStream", "init_duplicate", "__esmMin", "init_type", "stdioItems", "stdioItemOne", "indexOne", "stdioItemTwo", "indexTwo", "type", "value", "optionName", "direction", "fileDescriptors", "isSync", "otherStdioItems", "SPECIAL_DUPLICATE_TYPES", "FORBID_DUPLICATE_TYPES", "stdioItem", "SPECIAL_DUPLICATE_TYPES_SYNC", "duplicateStdioItems", "differentStdioItem", "secondValue", "duplicateStdioItem", "transform", "TYPE_TO_MESSAGE", "handleStdio", "getFileDescriptor", "initializeStdioItems", "initializeStdioItem", "validateStdioArray", "INVALID_STDIO_ARRAY_OPTIONS", "validateStreams", "validateFileStdio", "validateFileObjectMode", "getFinalFileDescriptors", "getFinalFileDescriptor", "addStreamProperties", "cleanupCustomStreams", "forwardStdio", "init_handle", "__esmMin", "init_standard_stream", "init_normalize", "init_object_mode", "init_type", "init_direction", "init_stdio_option", "init_native", "init_input_option", "init_duplicate", "addProperties", "options", "verboseInfo", "isSync", "initialFileDescriptors", "normalizeStdioOption", "stdioOption", "fdNumber", "fileDescriptors", "stdioItems", "optionName", "getStreamName", "initialStdioItems", "isStdioArray", "direction", "getStreamDirection", "stdioItem", "handleNativeStream", "normalizedStdioItems", "normalizeTransforms", "objectMode", "getFdObjectMode", "value", "handleInputOptions", "filterDuplicates", "getStdioItemType", "type", "isRegularUrl", "isUnknownStdioString", "fileStdioItem", "FILE_TYPES", "fileDescriptor", "error", "finalStdioItems", "duplicateStream", "getDuplicateStream", "stream", "isStandardStream", "import_node_fs", "handleStdioSync", "forbiddenIfSync", "forbiddenNativeIfSync", "throwInvalidSyncValue", "addProperties", "addPropertiesSync", "init_handle_sync", "__esmMin", "init_uint_array", "init_handle", "init_type", "options", "verboseInfo", "handleStdio", "type", "optionName", "TYPE_TO_MESSAGE", "value", "bufferToUint8Array", "file", "append", "stripNewline", "getStripFinalNewline", "init_strip_newline", "__esmMin", "init_strip_final_newline", "value", "stripFinalNewline", "fdNumber", "getSplitLinesGenerator", "splitLinesSync", "splitLinesItemSync", "initializeSplitLines", "splitGenerator", "getNewlineLength", "linesFinal", "getAppendNewlineGenerator", "appendNewlineGenerator", "concatString", "linesStringInfo", "concatUint8Array", "linesUint8ArrayInfo", "init_split", "__esmMin", "binary", "preserveNewlines", "skipped", "state", "chunk", "objectMode", "item", "transform", "final", "previousChunks", "start", "end", "newlineLength", "line", "readableObjectMode", "isWindowsNewline", "unixNewline", "windowsNewline", "LF", "concatBytes", "firstChunk", "secondChunk", "import_node_buffer", "getValidateTransformInput", "validateStringTransformInput", "getValidateTransformReturn", "validateObjectTransformReturn", "validateStringTransformReturn", "validateEmptyReturn", "init_validate", "__esmMin", "init_uint_array", "writableObjectMode", "optionName", "chunk", "isUint8Array", "readableObjectMode", "import_node_buffer", "import_node_string_decoder", "getEncodingTransformGenerator", "encodingUint8ArrayGenerator", "encodingStringGenerator", "encodingStringFinal", "init_encoding_transform", "__esmMin", "init_uint_array", "binary", "encoding", "skipped", "stringDecoder", "textEncoder", "chunk", "bufferToUint8Array", "isUint8Array", "lastChunk", "import_node_util", "pushChunks", "transformChunk", "finalChunks", "generatorFinalChunks", "destroyTransform", "identityGenerator", "init_run_async", "__esmMin", "getChunks", "state", "getChunksArguments", "transformStream", "chunk", "generators", "index", "transform", "transformedChunk", "final", "finalChunk", "currentIterable", "error", "pushChunksSync", "runTransformSync", "transformChunkSync", "finalChunksSync", "generatorFinalChunksSync", "identityGenerator", "init_run_sync", "__esmMin", "getChunksSync", "getChunksArguments", "transformStream", "done", "chunk", "error", "generators", "chunks", "index", "transform", "transformedChunk", "final", "finalChunk", "import_node_stream", "generatorToStream", "runGeneratorsSync", "addInternalGenerators", "init_generator", "__esmMin", "init_type", "init_split", "init_validate", "init_encoding_transform", "init_run_async", "init_run_sync", "value", "transform", "final", "writableObjectMode", "readableObjectMode", "optionName", "encoding", "state", "generators", "transformAsync", "isAsyncGenerator", "finalAsync", "transformMethod", "pushChunks", "transformChunk", "pushChunksSync", "transformChunkSync", "finalMethod", "finalChunks", "finalChunksSync", "destroyMethod", "destroyTransform", "chunk", "done", "chunks", "stdioItems", "isInput", "type", "reversedGenerators", "runTransformSync", "binary", "preserveNewlines", "getValidateTransformInput", "getEncodingTransformGenerator", "getSplitLinesGenerator", "getValidateTransformReturn", "getAppendNewlineGenerator", "addInputOptionsSync", "getInputFdNumbers", "addInputOptionSync", "applySingleInputGeneratorsSync", "validateSerializable", "init_input_sync", "__esmMin", "init_generator", "init_uint_array", "init_type", "fileDescriptors", "options", "fdNumber", "direction", "stdioItems", "allStdioItems", "contents", "type", "optionName", "TYPE_TO_MESSAGE", "transformedContents", "joinToUint8Array", "newContents", "runGeneratorsSync", "invalidItem", "item", "isUint8Array", "shouldLogOutput", "fdUsesVerbose", "PIPED_STDIO_VALUES", "logLines", "logLinesSync", "isPipingStream", "logLine", "init_output", "__esmMin", "init_encoding_option", "init_type", "init_log", "init_values", "stdioItems", "encoding", "verboseInfo", "fdNumber", "isFullVerbose", "BINARY_ENCODINGS", "type", "value", "TRANSFORM_TYPES", "linesIterable", "stream", "line", "linesArray", "verboseMessage", "serializeVerboseMessage", "verboseLog", "import_node_fs", "transformOutputSync", "transformOutputResultSync", "runOutputGeneratorsSync", "serializeChunks", "logOutputSync", "writeToFiles", "init_output_sync", "__esmMin", "init_output", "init_generator", "init_split", "init_uint_array", "init_type", "init_max_buffer", "fileDescriptors", "output", "options", "isMaxBuffer", "verboseInfo", "state", "outputFiles", "result", "fdNumber", "buffer", "encoding", "lines", "stripFinalNewline", "maxBuffer", "truncatedResult", "truncateMaxBufferSync", "uint8ArrayResult", "bufferToUint8Array", "stdioItems", "objectMode", "chunks", "serializedResult", "finalResult", "returnedResult", "error", "runGeneratorsSync", "joinToUint8Array", "joinToString", "splitLinesSync", "shouldLogOutput", "linesArray", "logLinesSync", "path", "append", "type", "FILE_TYPES", "pathString", "getAllSync", "init_all_sync", "__esmMin", "init_uint_array", "init_strip_newline", "stdout", "stderr", "options", "stripNewline", "isUint8Array", "concatUint8Arrays", "import_node_events", "waitForExit", "waitForExitOrError", "waitForSubprocessExit", "waitForSuccessfulExit", "isSubprocessErrorExit", "isFailedExit", "init_exit_async", "__esmMin", "init_final_error", "subprocess", "context", "exitCode", "signal", "spawnPayload", "exitPayload", "exitPromise", "DiscardedError", "getExitResultSync", "getResultError", "init_exit_sync", "__esmMin", "init_final_error", "init_max_buffer", "init_exit_async", "error", "exitCode", "signal", "output", "maxBuffer", "resultError", "timedOut", "isMaxBuffer", "isMaxBufferSync", "isFailedExit", "DiscardedError", "import_node_child_process", "execaCoreSync", "handleSyncArguments", "normalizeSyncOptions", "validateSyncOptions", "throwInvalidSyncOption", "spawnSubprocessSync", "runSubprocessSync", "normalizeSpawnSyncOptions", "getSyncResult", "init_main_sync", "__esmMin", "init_command", "init_options", "init_shell", "init_result", "init_reject", "init_handle_sync", "init_strip_newline", "init_input_sync", "init_output_sync", "init_max_buffer", "init_all_sync", "init_exit_sync", "rawFile", "rawArguments", "rawOptions", "file", "commandArguments", "command", "escapedCommand", "startTime", "verboseInfo", "options", "fileDescriptors", "result", "handleResult", "handleCommand", "syncOptions", "normalizeOptions", "handleStdioSync", "ipc", "ipcInput", "detached", "cancelSignal", "value", "syncResult", "resultError", "exitCode", "signal", "timedOut", "isMaxBuffer", "getExitResultSync", "output", "error", "transformOutputSync", "stdio", "stdioOutput", "fdNumber", "stripNewline", "all", "getAllSync", "addInputOptionsSync", "normalizedOptions", "concatenateShell", "makeEarlyError", "encoding", "maxBuffer", "getMaxBufferSync", "makeSuccessResult", "makeError", "import_node_events", "getOneMessage", "getOneMessageAsync", "getMessage", "throwOnDisconnect", "throwOnStrictError", "init_get_one", "__esmMin", "init_validation", "init_forward", "init_reference", "anyProcess", "channel", "isSubprocess", "ipc", "reference", "filter", "validateIpcMethod", "isConnected", "addReference", "ipcEmitter", "getIpcEmitter", "controller", "error", "disconnect", "removeReference", "signal", "message", "throwOnEarlyDisconnect", "getStrictResponseError", "import_node_events", "getEachMessage", "loopOnMessages", "stopOnDisconnect", "abortOnStrictError", "iterateOnMessages", "throwIfStrictError", "init_get_each", "__esmMin", "init_validation", "init_forward", "init_reference", "anyProcess", "channel", "isSubprocess", "ipc", "reference", "shouldAwait", "validateIpcMethod", "isConnected", "addReference", "ipcEmitter", "getIpcEmitter", "controller", "state", "error", "getStrictResponseError", "message", "removeReference", "disconnect", "import_node_process", "addIpcMethods", "getIpcExport", "getIpcMethods", "init_methods", "__esmMin", "init_send", "init_get_one", "init_get_each", "init_graceful", "subprocess", "ipc", "anyProcess", "process", "isSubprocess", "getCancelSignal", "sendMessage", "getOneMessage", "getEachMessage", "import_node_child_process", "import_node_stream", "handleEarlyError", "createDummyStreams", "createDummyStream", "readable", "writable", "duplex", "handleDummyPromise", "init_early_error", "__esmMin", "init_handle", "init_result", "init_reject", "error", "command", "escapedCommand", "fileDescriptors", "options", "startTime", "verboseInfo", "cleanupCustomStreams", "subprocess", "earlyError", "makeEarlyError", "promise", "stdin", "stdout", "stderr", "extraStdio", "all", "stdio", "stream", "handleResult", "import_node_fs", "import_node_buffer", "import_node_stream", "handleStdioAsync", "forbiddenIfAsync", "addProperties", "addPropertiesAsync", "init_handle_async", "__esmMin", "init_generator", "init_handle", "init_type", "options", "verboseInfo", "handleStdio", "type", "optionName", "TYPE_TO_MESSAGE", "generatorToStream", "value", "transform", "writableObjectMode", "readableObjectMode", "objectMode", "file", "append", "mergeStreams", "streams", "stream", "validateStream", "objectMode", "readableObjectMode", "highWaterMark", "getHighWaterMark", "passThroughStream", "MergedStream", "import_node_events", "import_node_stream", "import_promises", "onMergedStreamFinished", "onMergedStreamEnd", "onInputStreamsUnpipe", "endWhenStreamsDone", "afterMergedStreamFinished", "onInputStreamEnd", "onInputStreamUnpipe", "endStream", "errorOrAbortStream", "isAbortError", "abortStream", "errorStream", "noop", "updateMaxListeners", "PASSTHROUGH_LISTENERS_COUNT", "PASSTHROUGH_LISTENERS_PER_STREAM", "init_merge_streams", "__esmMin", "highWaterMarks", "readableHighWaterMark", "PassThroughStream", "#streams", "#ended", "#aborted", "#onFinished", "#unpipeEvent", "#streamPromises", "streamPromise", "unpipeEvent", "controller", "signal", "error", "unpipedStream", "ended", "aborted", "onFinished", "increment", "maxListeners", "import_promises", "pipeStreams", "onSourceFinish", "endDestinationStream", "onDestinationFinish", "abortSourceStream", "init_pipeline", "__esmMin", "init_standard_stream", "source", "destination", "isStandardStream", "pipeOutputAsync", "pipeTransform", "SUBPROCESS_STREAM_PROPERTIES", "pipeStdioItem", "setStandardStreamMaxListeners", "MAX_LISTENERS_INCREMENT", "init_output_async", "__esmMin", "init_merge_streams", "init_standard_stream", "init_max_listeners", "init_type", "init_pipeline", "subprocess", "fileDescriptors", "controller", "pipeGroups", "fdNumber", "stdioItems", "direction", "stream", "type", "TRANSFORM_TYPES", "outputStream", "inputStreams", "inputStream", "mergeStreams", "pipeStreams", "streamProperty", "outputStreams", "signal", "isStandardStream", "incrementMaxListeners", "signals", "init_signals", "__esmMin", "processOk", "kExitEmitter", "global", "ObjectDefineProperty", "Emitter", "SignalExitBase", "signalExitWrap", "SignalExitFallback", "SignalExit", "process", "onExit", "load", "unload", "init_mjs", "__esmMin", "init_signals", "ev", "fn", "list", "i", "code", "signal", "ret", "handler", "cb", "opts", "#hupSig", "#emitter", "#process", "#originalProcessEmit", "#originalProcessReallyExit", "#sigListeners", "#loaded", "sig", "signals", "listeners", "count", "p", "s", "a", "#processEmit", "#processReallyExit", "listener", "args", "og", "import_node_events", "cleanupOnExit", "init_cleanup", "__esmMin", "init_mjs", "subprocess", "cleanup", "detached", "signal", "removeExitHandler", "onExit", "normalizePipeArguments", "getDestinationStream", "getDestination", "mapDestinationArguments", "getSourceStream", "init_pipe_arguments", "__esmMin", "init_parameters", "init_duration", "init_fd_options", "init_file_url", "source", "sourcePromise", "boundOptions", "createNested", "pipeArguments", "startTime", "getStartTime", "destination", "destinationStream", "destinationError", "from", "unpipeSignal", "sourceStream", "sourceError", "sourceOptions", "fileDescriptors", "SUBPROCESS_OPTIONS", "to", "getToStream", "error", "firstArgument", "isDenoExecPath", "rawFile", "rawArguments", "rawOptions", "normalizeParameters", "options", "getFromStream", "handlePipeArgumentsError", "getPipeArgumentsError", "createNonCommandError", "PIPE_COMMAND_MESSAGE", "init_throw", "__esmMin", "init_result", "init_pipeline", "sourceStream", "sourceError", "destinationStream", "destinationError", "fileDescriptors", "sourceOptions", "startTime", "error", "abortSourceStream", "endDestinationStream", "makeEarlyError", "waitForBothSubprocesses", "init_sequence", "__esmMin", "subprocessPromises", "sourceStatus", "sourceReason", "sourceResult", "destinationStatus", "destinationReason", "destinationResult", "import_promises", "pipeSubprocessStream", "pipeFirstSubprocessStream", "pipeMoreSubprocessStream", "cleanupMergedStreamsMap", "MERGED_STREAMS", "SOURCE_LISTENERS_PER_PIPE", "DESTINATION_LISTENERS_PER_PIPE", "init_streaming", "__esmMin", "init_merge_streams", "init_max_listeners", "init_pipeline", "sourceStream", "destinationStream", "maxListenersController", "mergedStream", "incrementMaxListeners", "mergeStreams", "pipeStreams", "import_node_util", "unpipeOnAbort", "unpipeOnSignalAbort", "init_abort", "__esmMin", "init_throw", "unpipeSignal", "unpipeContext", "sourceStream", "mergedStream", "fileDescriptors", "sourceOptions", "startTime", "error", "createNonCommandError", "pipeToSubprocess", "handlePipePromise", "getSubprocessPromises", "init_setup", "__esmMin", "init_is_plain_obj", "init_pipe_arguments", "init_throw", "init_sequence", "init_streaming", "init_abort", "sourceInfo", "pipeArguments", "isPlainObject", "destination", "normalizedInfo", "normalizePipeArguments", "promise", "sourcePromise", "sourceStream", "sourceOptions", "sourceError", "destinationStream", "destinationError", "unpipeSignal", "fileDescriptors", "startTime", "subprocessPromises", "handlePipeArgumentsError", "maxListenersController", "mergedStream", "pipeSubprocessStream", "waitForBothSubprocesses", "unpipeOnAbort", "import_node_events", "import_node_stream", "iterateOnSubprocessStream", "stopReadingOnExit", "iterateForResult", "stopReadingOnStreamEnd", "iterateOnStream", "DEFAULT_OBJECT_HIGH_WATER_MARK", "HIGH_WATER_MARK", "iterateOnData", "getGenerators", "init_iterate", "__esmMin", "init_encoding_transform", "init_split", "init_run_sync", "subprocessStdout", "subprocess", "binary", "shouldEncode", "encoding", "preserveNewlines", "controller", "stream", "onStreamEnd", "lines", "stripFinalNewline", "allMixed", "objectMode", "shouldSplit", "onStdoutChunk", "generators", "chunk", "transformChunkSync", "error", "finalChunksSync", "getEncodingTransformGenerator", "getSplitLinesGenerator", "import_promises", "getStreamOutput", "logOutputAsync", "resumeStream", "getStreamContents", "getBufferedData", "handleBufferedData", "init_contents", "__esmMin", "init_source", "init_uint_array", "init_output", "init_iterate", "init_max_buffer", "init_strip_newline", "stream", "onStreamEnd", "fdNumber", "encoding", "buffer", "maxBuffer", "lines", "allMixed", "stripFinalNewline", "verboseInfo", "streamInfo", "logPromise", "stripFinalNewlineValue", "getStripFinalNewline", "iterable", "iterateForResult", "output", "fileDescriptors", "shouldLogOutput", "linesIterable", "logLines", "readableObjectMode", "getStreamAsArray", "getStreamAsArrayBuffer", "getStreamAsString", "error", "handleMaxBuffer", "streamPromise", "bufferedData", "isArrayBuffer", "import_promises", "waitForStream", "handleStdinDestroy", "spyOnStdinDestroy", "setStdinCleanedUp", "handleStreamError", "shouldIgnoreStreamError", "isInputFileDescriptor", "isStreamAbort", "isStreamEpipe", "init_wait_stream", "__esmMin", "stream", "fdNumber", "streamInfo", "isSameDirection", "stopOnExit", "state", "abortController", "error", "originalStdin", "subprocess", "subprocessStdin", "_destroy", "destroyArguments", "exitCode", "signalCode", "fileDescriptors", "waitForStdioStreams", "waitForSubprocessStream", "init_stdio", "__esmMin", "init_contents", "init_wait_stream", "subprocess", "encoding", "buffer", "maxBuffer", "lines", "stripFinalNewline", "verboseInfo", "streamInfo", "stream", "fdNumber", "allMixed", "onStreamEnd", "waitForStream", "isInputFileDescriptor", "output", "getStreamOutput", "makeAllStream", "waitForAllStream", "getAllStream", "getAllMixed", "init_all_async", "__esmMin", "init_merge_streams", "init_stdio", "stdout", "stderr", "all", "mergeStreams", "subprocess", "encoding", "buffer", "maxBuffer", "lines", "stripFinalNewline", "verboseInfo", "streamInfo", "waitForSubprocessStream", "bufferStdout", "bufferStderr", "shouldLogIpc", "logIpcOutput", "init_ipc", "__esmMin", "init_log", "init_values", "verboseInfo", "isFullVerbose", "message", "verboseMessage", "serializeVerboseMessage", "verboseLog", "waitForIpcOutput", "getBufferedIpcOutput", "init_buffer_messages", "__esmMin", "init_max_buffer", "init_ipc", "init_specific", "init_get_each", "subprocess", "bufferArray", "maxBufferArray", "ipc", "ipcOutput", "verboseInfo", "isVerbose", "shouldLogIpc", "buffer", "getFdSpecificValue", "maxBuffer", "message", "loopOnMessages", "checkIpcMaxBuffer", "logIpcOutput", "ipcOutputPromise", "import_node_events", "waitForSubprocessResult", "waitForOriginalStreams", "waitForCustomStreamsEnd", "throwOnSubprocessError", "init_wait_subprocess", "__esmMin", "init_is_stream", "init_timeout", "init_cancel", "init_graceful", "init_standard_stream", "init_type", "init_contents", "init_buffer_messages", "init_ipc_input", "init_all_async", "init_stdio", "init_exit_async", "init_wait_stream", "subprocess", "encoding", "buffer", "maxBuffer", "lines", "timeout", "cancelSignal", "gracefulCancel", "forceKillAfterDelay", "stripFinalNewline", "ipc", "ipcInput", "context", "verboseInfo", "fileDescriptors", "originalStreams", "onInternalError", "controller", "exitPromise", "waitForExit", "streamInfo", "stdioPromises", "waitForStdioStreams", "allPromise", "waitForAllStream", "ipcOutput", "ipcOutputPromise", "waitForIpcOutput", "originalPromises", "customStreamsEndPromises", "waitForSuccessfulExit", "sendIpcInput", "throwOnTimeout", "throwOnCancel", "throwOnGracefulCancel", "error", "stdioPromise", "getBufferedData", "getBufferedIpcOutput", "stream", "fdNumber", "waitForStream", "stdioItems", "value", "isStream", "isStandardStream", "type", "TRANSFORM_TYPES", "signal", "initializeConcurrentStreams", "addConcurrentStream", "waitForConcurrentStreams", "init_concurrent", "__esmMin", "init_deferred", "concurrentStreams", "stream", "waitName", "weakMap", "promises", "promise", "createDeferred", "resolve", "subprocess", "isSubprocessExit", "import_promises", "safeWaitForSubprocessStdin", "safeWaitForSubprocessStdout", "waitForSubprocessStdin", "waitForSubprocessStdout", "waitForSubprocess", "destroyOtherStream", "init_shared", "__esmMin", "init_wait_stream", "subprocessStdin", "subprocessStdout", "subprocess", "error", "stream", "isOpen", "isStreamAbort", "import_node_stream", "import_node_util", "createReadable", "getSubprocessStdout", "getReadableOptions", "getReadableMethods", "onRead", "onStdoutFinished", "onReadableDestroy", "destroyOtherReadable", "init_readable", "__esmMin", "init_encoding_option", "init_fd_options", "init_iterate", "init_deferred", "init_concurrent", "init_shared", "subprocess", "concurrentStreams", "encoding", "from", "binaryOption", "preserveNewlines", "binary", "BINARY_ENCODINGS", "subprocessStdout", "waitReadableDestroy", "readableEncoding", "readableObjectMode", "readableHighWaterMark", "read", "onStdoutDataDone", "readable", "getFromStream", "addConcurrentStream", "DEFAULT_OBJECT_HIGH_WATER_MARK", "createDeferred", "onStdoutData", "iterateOnSubprocessStream", "value", "done", "subprocessStdin", "waitForSubprocessStdout", "safeWaitForSubprocessStdin", "error", "waitForConcurrentStreams", "waitForSubprocess", "stream", "destroyOtherStream", "import_node_stream", "import_node_util", "createWritable", "getSubprocessStdin", "getWritableMethods", "onWrite", "onWritableFinal", "onStdinFinished", "onWritableDestroy", "destroyOtherWritable", "init_writable", "__esmMin", "init_fd_options", "init_concurrent", "init_shared", "subprocess", "concurrentStreams", "to", "subprocessStdin", "waitWritableFinal", "waitWritableDestroy", "writable", "getToStream", "addConcurrentStream", "chunk", "encoding", "done", "waitForConcurrentStreams", "subprocessStdout", "waitForSubprocessStdin", "error", "safeWaitForSubprocessStdout", "waitForSubprocess", "stream", "destroyOtherStream", "import_node_stream", "import_node_util", "createDuplex", "onDuplexDestroy", "init_duplex", "__esmMin", "init_encoding_option", "init_readable", "init_writable", "subprocess", "concurrentStreams", "encoding", "from", "to", "binaryOption", "preserveNewlines", "binary", "BINARY_ENCODINGS", "subprocessStdout", "waitReadableDestroy", "getSubprocessStdout", "subprocessStdin", "waitWritableFinal", "waitWritableDestroy", "getSubprocessStdin", "readableEncoding", "readableObjectMode", "readableHighWaterMark", "getReadableOptions", "read", "onStdoutDataDone", "getReadableMethods", "duplex", "getWritableMethods", "onStdoutFinished", "onStdinFinished", "error", "onReadableDestroy", "onWritableDestroy", "createIterable", "iterateOnStdoutData", "init_iterable", "__esmMin", "init_encoding_option", "init_fd_options", "init_iterate", "subprocess", "encoding", "from", "binaryOption", "preserveNewlines", "binary", "BINARY_ENCODINGS", "subprocessStdout", "getFromStream", "onStdoutData", "iterateOnSubprocessStream", "addConvertedStreams", "init_add", "__esmMin", "init_concurrent", "init_readable", "init_writable", "init_duplex", "init_iterable", "subprocess", "encoding", "concurrentStreams", "initializeConcurrentStreams", "createReadable", "createWritable", "createDuplex", "createIterable", "mergePromise", "nativePromisePrototype", "descriptors", "init_promise", "__esmMin", "subprocess", "promise", "property", "descriptor", "value", "import_node_events", "import_node_child_process", "execaCoreAsync", "handleAsyncArguments", "handleAsyncOptions", "spawnSubprocessAsync", "handlePromise", "getAsyncResult", "init_main_async", "__esmMin", "init_source", "init_command", "init_options", "init_fd_options", "init_shell", "init_methods", "init_result", "init_reject", "init_early_error", "init_handle_async", "init_strip_newline", "init_output_async", "init_kill", "init_cleanup", "init_setup", "init_all_async", "init_wait_subprocess", "init_add", "init_deferred", "init_promise", "rawFile", "rawArguments", "rawOptions", "createNested", "file", "commandArguments", "command", "escapedCommand", "startTime", "verboseInfo", "options", "fileDescriptors", "subprocess", "promise", "pipeToSubprocess", "mergePromise", "SUBPROCESS_OPTIONS", "handleCommand", "normalizedOptions", "normalizeOptions", "handleStdioAsync", "timeout", "signal", "concatenateShell", "error", "handleEarlyError", "controller", "originalStreams", "pipeOutputAsync", "cleanupOnExit", "context", "onInternalError", "createDeferred", "subprocessKill", "makeAllStream", "addConvertedStreams", "addIpcMethods", "errorInfo", "exitCode", "stdioResults", "allResult", "ipcOutput", "waitForSubprocessResult", "stdio", "stdioResult", "fdNumber", "stripNewline", "all", "result", "handleResult", "makeError", "MaxBufferError", "makeSuccessResult", "mergeOptions", "mergeOption", "DEEP_OPTIONS", "init_bind", "__esmMin", "init_is_plain_obj", "init_specific", "boundOptions", "options", "newOptions", "optionName", "optionValue", "boundOptionValue", "isPlainObject", "FD_SPECIFIC_OPTIONS", "createExeca", "callBoundExeca", "parseArguments", "init_create", "__esmMin", "init_is_plain_obj", "init_parameters", "init_template", "init_main_sync", "init_main_async", "init_bind", "mapArguments", "boundOptions", "deepOptions", "setBoundExeca", "createNested", "boundExeca", "execaArguments", "firstArgument", "nextArguments", "isPlainObject", "mergeOptions", "file", "commandArguments", "options", "isSync", "execaCoreSync", "execaCoreAsync", "callArguments", "isTemplateString", "parseTemplates", "initialFile", "initialArguments", "initialOptions", "normalizeParameters", "mergedOptions", "mapCommandAsync", "mapCommandSync", "parseCommand", "parseCommandString", "SPACES_REGEXP", "init_command", "__esmMin", "file", "commandArguments", "command", "unusedArguments", "trimmedCommand", "tokens", "token", "previousToken", "setScriptSync", "mapScriptAsync", "mapScriptSync", "getScriptOptions", "getScriptStdinOption", "deepScriptOptions", "init_script", "__esmMin", "boundExeca", "createNested", "boundOptions", "options", "input", "inputFile", "stdio", "execa", "execaSync", "execaCommand", "execaCommandSync", "execaNode", "$", "sendMessage", "getOneMessage", "getEachMessage", "getCancelSignal", "init_execa", "__esmMin", "init_create", "init_command", "init_node", "init_script", "init_methods", "createExeca", "mapCommandAsync", "mapCommandSync", "mapNode", "mapScriptAsync", "deepScriptOptions", "setScriptSync", "getIpcExport", "macos_exports", "__export", "macosAudioAPI", "ensureBinary", "fs", "binary", "binaryAsset", "execa", "throwIfStderr", "stderr", "parseStdout", "stdout", "import_path", "import_api", "import_fs", "init_macos", "__esmMin", "init_execa", "path", "deviceId", "volume", "name", "mainDeviceId", "otherDeviceIds", "options", "windows_exports", "__export", "windowsAudioAPI", "downloadBinary", "url", "dest", "redirectCount", "resolve", "reject", "file", "fs", "error", "https", "response", "location", "err", "verifyChecksum", "filePath", "expectedChecksum", "hash", "crypto", "stream", "chunk", "actualChecksum", "ensureBinary", "binary", "hasVerifiedBinaryThisSession", "WINDOWS_BINARY_CHECKSUM", "logBinaryInfo", "isDownloading", "downloadPromise", "WINDOWS_BINARY_URL", "hasLoggedBinaryInfo", "stdout", "execa", "info", "parseJson", "mapToDevice", "device", "type", "mapTransportType", "deviceName", "typeMap", "lowerName", "key", "value", "runBinary", "args", "getDevices", "import_path", "import_fs", "import_https", "import_crypto", "import_api", "init_windows", "__esmMin", "init_execa", "path", "devices", "output", "input", "deviceId", "auto_switch_input_exports", "__export", "Command", "__toCommonJS", "import_api", "platform", "isMacOS", "isWindows", "apiInstance", "getAudioAPI", "macosAudioAPI", "windowsAudioAPI", "apiInstance", "getAPI", "getAudioAPI", "getInputDevices", "getAPI", "getOutputDevices", "getDefaultOutputDevice", "getDefaultInputDevice", "setDefaultOutputDevice", "deviceId", "getAPI", "setDefaultInputDevice", "setDefaultSystemDevice", "api", "import_api", "setOutputAndSystemDevice", "deviceId", "systemOutput", "setDefaultOutputDevice", "setDefaultSystemDevice", "AUTO_SWITCH_KEYS", "import_api", "LEGACY_DISABLED_DEVICES_KEY", "LEGACY_HIDDEN_DEVICES_KEY", "HIDDEN_DEVICES_KEYS", "INPUT_ORDER_KEY", "OUTPUT_ORDER_KEY", "parseStoredList", "value", "parsed", "readList", "key", "writeList", "list", "mergeUnique", "lists", "migrateHiddenDevices", "type", "storedRaw", "HIDDEN_DEVICES_KEYS", "legacyHidden", "LEGACY_HIDDEN_DEVICES_KEY", "legacyDisabled", "LEGACY_DISABLED_DEVICES_KEY", "merged", "getHiddenDevices", "getDeviceOrder", "type", "readList", "INPUT_ORDER_KEY", "OUTPUT_ORDER_KEY", "normalizeDeviceOrder", "order", "devices", "deviceIds", "device", "filtered", "id", "missing", "applyDeviceOrder", "normalized", "deviceMap", "AUTO_SWITCH_INTERVAL_SECONDS", "MS_PER_SECOND", "AUTO_SWITCH_LAST_RUN_KEYS", "shouldSkipForInterval", "type", "lastRunRaw", "lastRun", "intervalMs", "markLastRun", "isAutoSwitchEnabled", "AUTO_SWITCH_KEYS", "setAutoSwitchEnabled", "enabled", "maybeSwitchInput", "hiddenDevices", "devices", "getInputDevices", "order", "getDeviceOrder", "hiddenSet", "target", "applyDeviceOrder", "device", "getDefaultInputDevice", "setDefaultInputDevice", "maybeSwitchOutput", "getOutputDevices", "getDefaultOutputDevice", "setOutputAndSystemDevice", "runSwitch", "getHiddenDevices", "runAutoSwitch", "type", "isBackground", "enabled", "isAutoSwitchEnabled", "nextEnabled", "setAutoSwitchEnabled", "shouldSkipForInterval", "runSwitch", "markLastRun", "error", "Command", "runAutoSwitch"]
}
