{
  "version": 3,
  "sources": ["../node_modules/@chrismessina/raycast-logger/src/redaction.ts", "../node_modules/@chrismessina/raycast-logger/src/logger.ts", "../node_modules/@chrismessina/raycast-logger/src/index.ts", "../node_modules/stream-chain/index.js", "../node_modules/stream-json/utils/Utf8Stream.js", "../node_modules/stream-json/Parser.js", "../node_modules/stream-json/utils/emit.js", "../node_modules/stream-json/index.js", "../node_modules/stream-json/filters/FilterBase.js", "../node_modules/stream-json/utils/withParser.js", "../node_modules/stream-json/filters/Filter.js", "../node_modules/stream-json/Assembler.js", "../node_modules/stream-json/streamers/StreamBase.js", "../node_modules/stream-json/streamers/StreamArray.js", "../src/clean-up.tsx", "../src/utils/brew/paths.ts", "../src/utils/preferences.ts", "../src/utils/brew/commands.ts", "../src/utils/logger.ts", "../src/utils/errors.ts", "../src/utils/cache.ts", "../src/utils/brew/progress.ts", "../src/utils/brew/fetch.ts", "../src/utils/brew/actions.ts", "../src/utils/toast.ts", "../src/utils/array.ts", "../src/utils/async.ts", "../src/utils/memory.ts"],
  "sourcesContent": [null, null, null, "'use strict';\n\nconst {Readable, Writable, Duplex, Transform} = require('stream');\n\nconst none = Symbol.for('object-stream.none');\nconst finalSymbol = Symbol.for('object-stream.final');\nconst manySymbol = Symbol.for('object-stream.many');\n\nconst final = value => ({[finalSymbol]: value});\nconst many = values => ({[manySymbol]: values});\n\nconst isFinal = o => o && typeof o == 'object' && finalSymbol in o;\nconst isMany = o => o && typeof o == 'object' && manySymbol in o;\n\nconst getFinalValue = o => o[finalSymbol];\nconst getManyValues = o => o[manySymbol];\n\nconst runAsyncGenerator = async (gen, stream) => {\n  for (;;) {\n    let data = gen.next();\n    if (data && typeof data.then == 'function') {\n      data = await data;\n    }\n    if (data.done) break;\n    let value = data.value;\n    if (value && typeof value.then == 'function') {\n      value = await value;\n    }\n    Chain.sanitize(value, stream);\n  }\n};\n\nconst wrapFunction = fn =>\n  new Transform({\n    writableObjectMode: true,\n    readableObjectMode: true,\n    transform(chunk, encoding, callback) {\n      try {\n        const result = fn.call(this, chunk, encoding);\n        if (result && typeof result.then == 'function') {\n          // thenable\n          result.then(\n            result => (Chain.sanitize(result, this), callback(null)),\n            error => callback(error)\n          );\n          return;\n        }\n        if (result && typeof result.next == 'function') {\n          // generator\n          runAsyncGenerator(result, this).then(\n            () => callback(null),\n            error => callback(error)\n          );\n          return;\n        }\n        Chain.sanitize(result, this);\n        callback(null);\n      } catch (error) {\n        callback(error);\n      }\n    }\n  });\n\nconst wrapArray = fns =>\n  new Transform({\n    writableObjectMode: true,\n    readableObjectMode: true,\n    transform(chunk, encoding, callback) {\n      try {\n        let value = chunk;\n        for (let i = 0; i < fns.length; ++i) {\n          const result = fns[i].call(this, value, encoding);\n          if (result === Chain.none) {\n            callback(null);\n            return;\n          }\n          if (Chain.isFinal(result)) {\n            value = Chain.getFinalValue(result);\n            break;\n          }\n          value = result;\n        }\n        Chain.sanitize(value, this);\n        callback(null);\n      } catch (error) {\n        callback(error);\n      }\n    }\n  });\n\n// is*NodeStream functions taken from https://github.com/nodejs/node/blob/master/lib/internal/streams/utils.js\nconst isReadableNodeStream = obj =>\n  obj &&\n  typeof obj.pipe === 'function' &&\n  typeof obj.on === 'function' &&\n  (!obj._writableState || (typeof obj._readableState === 'object' ? obj._readableState.readable : null) !== false) && // Duplex\n  (!obj._writableState || obj._readableState); // Writable has .pipe.\n\nconst isWritableNodeStream = obj =>\n  obj &&\n  typeof obj.write === 'function' &&\n  typeof obj.on === 'function' &&\n  (!obj._readableState || (typeof obj._writableState === 'object' ? obj._writableState.writable : null) !== false); // Duplex\n\nconst isDuplexNodeStream = obj =>\n  obj && typeof obj.pipe === 'function' && obj._readableState && typeof obj.on === 'function' && typeof obj.write === 'function';\n\nclass Chain extends Duplex {\n  constructor(fns, options) {\n    super(options || {writableObjectMode: true, readableObjectMode: true});\n\n    if (!(fns instanceof Array) || !fns.length) {\n      throw Error(\"Chain's argument should be a non-empty array.\");\n    }\n\n    this.streams = fns\n      .filter(fn => fn)\n      .map((fn, index, fns) => {\n        if (typeof fn === 'function' || fn instanceof Array) return Chain.convertToTransform(fn);\n        if (isDuplexNodeStream(fn) || (!index && isReadableNodeStream(fn)) || (index === fns.length - 1 && isWritableNodeStream(fn))) {\n          return fn;\n        }\n        throw Error('Arguments should be functions, arrays or streams.');\n      })\n      .filter(s => s);\n    this.input = this.streams[0];\n    this.output = this.streams.reduce((output, stream) => (output && output.pipe(stream)) || stream);\n\n    if (!isWritableNodeStream(this.input)) {\n      this._write = (_1, _2, callback) => callback(null);\n      this._final = callback => callback(null); // unavailable in Node 6\n      this.input.on('end', () => this.end());\n    }\n\n    if (isReadableNodeStream(this.output)) {\n      this.output.on('data', chunk => !this.push(chunk) && this.output.pause());\n      this.output.on('end', () => this.push(null));\n    } else {\n      this._read = () => {}; // nop\n      this.resume();\n      this.output.on('finish', () => this.push(null));\n    }\n\n    // connect events\n    if (!options || !options.skipEvents) {\n      this.streams.forEach(stream => stream.on('error', error => this.emit('error', error)));\n    }\n  }\n  _write(chunk, encoding, callback) {\n    let error = null;\n    try {\n      this.input.write(chunk, encoding, e => callback(e || error));\n    } catch (e) {\n      error = e;\n    }\n  }\n  _final(callback) {\n    let error = null;\n    try {\n      this.input.end(null, null, e => callback(e || error));\n    } catch (e) {\n      error = e;\n    }\n  }\n  _read() {\n    this.output.resume();\n  }\n  static make(fns, options) {\n    return new Chain(fns, options);\n  }\n  static sanitize(result, stream) {\n    if (Chain.isFinal(result)) {\n      result = Chain.getFinalValue(result);\n    } else if (Chain.isMany(result)) {\n      result = Chain.getManyValues(result);\n    }\n    if (result !== undefined && result !== null && result !== Chain.none) {\n      if (result instanceof Array) {\n        result.forEach(value => value !== undefined && value !== null && stream.push(value));\n      } else {\n        stream.push(result);\n      }\n    }\n  }\n  static convertToTransform(fn) {\n    if (typeof fn === 'function') return wrapFunction(fn);\n    if (fn instanceof Array) return fn.length ? wrapArray(fn) : null;\n    return null;\n  }\n}\n\nChain.none = none;\nChain.final = final;\nChain.isFinal = isFinal;\nChain.getFinalValue = getFinalValue;\nChain.many = many;\nChain.isMany = isMany;\nChain.getManyValues = getManyValues;\n\nChain.chain = Chain.make;\nChain.make.Constructor = Chain;\n\nmodule.exports = Chain;\n", "'use strict';\n\nconst {Transform} = require('stream');\nconst {StringDecoder} = require('string_decoder');\n\nclass Utf8Stream extends Transform {\n  constructor(options) {\n    super(Object.assign({}, options, {writableObjectMode: false}));\n    this._buffer = '';\n  }\n\n  _transform(chunk, encoding, callback) {\n    if (typeof chunk == 'string') {\n      this._transform = this._transformString;\n    } else {\n      this._stringDecoder = new StringDecoder();\n      this._transform = this._transformBuffer;\n    }\n    this._transform(chunk, encoding, callback);\n  }\n\n  _transformBuffer(chunk, _, callback) {\n    this._buffer += this._stringDecoder.write(chunk);\n    this._processBuffer(callback);\n  }\n\n  _transformString(chunk, _, callback) {\n    this._buffer += chunk.toString();\n    this._processBuffer(callback);\n  }\n\n  _processBuffer(callback) {\n    if (this._buffer) {\n      this.push(this._buffer, 'utf8');\n      this._buffer = '';\n    }\n    callback(null);\n  }\n\n  _flushInput() {\n    // meant to be called from _flush()\n    if (this._stringDecoder) {\n      this._buffer += this._stringDecoder.end();\n    }\n  }\n\n  _flush(callback) {\n    this._flushInput();\n    this._processBuffer(callback);\n  }\n}\n\nmodule.exports = Utf8Stream;\n", "'use strict';\n\nconst Utf8Stream = require('./utils/Utf8Stream');\n\nconst patterns = {\n  value1: /^(?:[\\\"\\{\\[\\]\\-\\d]|true\\b|false\\b|null\\b|\\s{1,256})/,\n  string: /^(?:[^\\x00-\\x1f\\\"\\\\]{1,256}|\\\\[bfnrt\\\"\\\\\\/]|\\\\u[\\da-fA-F]{4}|\\\")/,\n  key1: /^(?:[\\\"\\}]|\\s{1,256})/,\n  colon: /^(?:\\:|\\s{1,256})/,\n  comma: /^(?:[\\,\\]\\}]|\\s{1,256})/,\n  ws: /^\\s{1,256}/,\n  numberStart: /^\\d/,\n  numberDigit: /^\\d{0,256}/,\n  numberFraction: /^[\\.eE]/,\n  numberExponent: /^[eE]/,\n  numberExpSign: /^[-+]/\n};\nconst MAX_PATTERN_SIZE = 16;\n\nlet noSticky = true;\ntry {\n  new RegExp('.', 'y');\n  noSticky = false;\n} catch (e) {\n  // suppress\n}\n\n!noSticky &&\n  Object.keys(patterns).forEach(key => {\n    let src = patterns[key].source.slice(1); // lop off ^\n    if (src.slice(0, 3) === '(?:' && src.slice(-1) === ')') {\n      src = src.slice(3, -1);\n    }\n    patterns[key] = new RegExp(src, 'y');\n  });\n\npatterns.numberFracStart = patterns.numberExpStart = patterns.numberStart;\npatterns.numberFracDigit = patterns.numberExpDigit = patterns.numberDigit;\n\nconst values = {true: true, false: false, null: null},\n  expected = {object: 'objectStop', array: 'arrayStop', '': 'done'};\n\n// long hexadecimal codes: \\uXXXX\nconst fromHex = s => String.fromCharCode(parseInt(s.slice(2), 16));\n\n// short codes: \\b \\f \\n \\r \\t \\\" \\\\ \\/\nconst codes = {b: '\\b', f: '\\f', n: '\\n', r: '\\r', t: '\\t', '\"': '\"', '\\\\': '\\\\', '/': '/'};\n\nclass Parser extends Utf8Stream {\n  static make(options) {\n    return new Parser(options);\n  }\n\n  constructor(options) {\n    super(Object.assign({}, options, {readableObjectMode: true}));\n\n    this._packKeys = this._packStrings = this._packNumbers = this._streamKeys = this._streamStrings = this._streamNumbers = true;\n    if (options) {\n      'packValues' in options && (this._packKeys = this._packStrings = this._packNumbers = options.packValues);\n      'packKeys' in options && (this._packKeys = options.packKeys);\n      'packStrings' in options && (this._packStrings = options.packStrings);\n      'packNumbers' in options && (this._packNumbers = options.packNumbers);\n      'streamValues' in options && (this._streamKeys = this._streamStrings = this._streamNumbers = options.streamValues);\n      'streamKeys' in options && (this._streamKeys = options.streamKeys);\n      'streamStrings' in options && (this._streamStrings = options.streamStrings);\n      'streamNumbers' in options && (this._streamNumbers = options.streamNumbers);\n      this._jsonStreaming = options.jsonStreaming;\n    }\n    !this._packKeys && (this._streamKeys = true);\n    !this._packStrings && (this._streamStrings = true);\n    !this._packNumbers && (this._streamNumbers = true);\n\n    this._done = false;\n    this._expect = this._jsonStreaming ? 'done' : 'value';\n    this._stack = [];\n    this._parent = '';\n    this._open_number = false;\n    this._accumulator = '';\n  }\n\n  _flush(callback) {\n    this._done = true;\n    super._flush(error => {\n      if (error) return callback(error);\n      if (this._open_number) {\n        if (this._streamNumbers) {\n          this.push({name: 'endNumber'});\n        }\n        this._open_number = false;\n        if (this._packNumbers) {\n          this.push({name: 'numberValue', value: this._accumulator});\n          this._accumulator = '';\n        }\n      }\n      callback(null);\n    });\n  }\n\n  _processBuffer(callback) {\n    let match,\n      value,\n      index = 0;\n    main: for (;;) {\n      switch (this._expect) {\n        case 'value1':\n        case 'value':\n          patterns.value1.lastIndex = index;\n          match = patterns.value1.exec(this._buffer);\n          if (!match) {\n            if (this._done || index + MAX_PATTERN_SIZE < this._buffer.length) {\n              if (index < this._buffer.length) return callback(new Error('Parser cannot parse input: expected a value'));\n              return callback(new Error('Parser has expected a value'));\n            }\n            break main; // wait for more input\n          }\n          value = match[0];\n          switch (value) {\n            case '\"':\n              this._streamStrings && this.push({name: 'startString'});\n              this._expect = 'string';\n              break;\n            case '{':\n              this.push({name: 'startObject'});\n              this._stack.push(this._parent);\n              this._parent = 'object';\n              this._expect = 'key1';\n              break;\n            case '[':\n              this.push({name: 'startArray'});\n              this._stack.push(this._parent);\n              this._parent = 'array';\n              this._expect = 'value1';\n              break;\n            case ']':\n              if (this._expect !== 'value1') return callback(new Error(\"Parser cannot parse input: unexpected token ']'\"));\n              if (this._open_number) {\n                this._streamNumbers && this.push({name: 'endNumber'});\n                this._open_number = false;\n                if (this._packNumbers) {\n                  this.push({name: 'numberValue', value: this._accumulator});\n                  this._accumulator = '';\n                }\n              }\n              this.push({name: 'endArray'});\n              this._parent = this._stack.pop();\n              this._expect = expected[this._parent];\n              break;\n            case '-':\n              this._open_number = true;\n              if (this._streamNumbers) {\n                this.push({name: 'startNumber'});\n                this.push({name: 'numberChunk', value: '-'});\n              }\n              this._packNumbers && (this._accumulator = '-');\n              this._expect = 'numberStart';\n              break;\n            case '0':\n              this._open_number = true;\n              if (this._streamNumbers) {\n                this.push({name: 'startNumber'});\n                this.push({name: 'numberChunk', value: '0'});\n              }\n              this._packNumbers && (this._accumulator = '0');\n              this._expect = 'numberFraction';\n              break;\n            case '1':\n            case '2':\n            case '3':\n            case '4':\n            case '5':\n            case '6':\n            case '7':\n            case '8':\n            case '9':\n              this._open_number = true;\n              if (this._streamNumbers) {\n                this.push({name: 'startNumber'});\n                this.push({name: 'numberChunk', value: value});\n              }\n              this._packNumbers && (this._accumulator = value);\n              this._expect = 'numberDigit';\n              break;\n            case 'true':\n            case 'false':\n            case 'null':\n              if (this._buffer.length - index === value.length && !this._done) break main; // wait for more input\n              this.push({name: value + 'Value', value: values[value]});\n              this._expect = expected[this._parent];\n              break;\n            // default: // ws\n          }\n          if (noSticky) {\n            this._buffer = this._buffer.slice(value.length);\n          } else {\n            index += value.length;\n          }\n          break;\n        case 'keyVal':\n        case 'string':\n          patterns.string.lastIndex = index;\n          match = patterns.string.exec(this._buffer);\n          if (!match) {\n            if (index < this._buffer.length && (this._done || this._buffer.length - index >= 6))\n              return callback(new Error('Parser cannot parse input: escaped characters'));\n            if (this._done) return callback(new Error('Parser has expected a string value'));\n            break main; // wait for more input\n          }\n          value = match[0];\n          if (value === '\"') {\n            if (this._expect === 'keyVal') {\n              this._streamKeys && this.push({name: 'endKey'});\n              if (this._packKeys) {\n                this.push({name: 'keyValue', value: this._accumulator});\n                this._accumulator = '';\n              }\n              this._expect = 'colon';\n            } else {\n              this._streamStrings && this.push({name: 'endString'});\n              if (this._packStrings) {\n                this.push({name: 'stringValue', value: this._accumulator});\n                this._accumulator = '';\n              }\n              this._expect = expected[this._parent];\n            }\n          } else if (value.length > 1 && value.charAt(0) === '\\\\') {\n            const t = value.length == 2 ? codes[value.charAt(1)] : fromHex(value);\n            if (this._expect === 'keyVal' ? this._streamKeys : this._streamStrings) {\n              this.push({name: 'stringChunk', value: t});\n            }\n            if (this._expect === 'keyVal' ? this._packKeys : this._packStrings) {\n              this._accumulator += t;\n            }\n          } else {\n            if (this._expect === 'keyVal' ? this._streamKeys : this._streamStrings) {\n              this.push({name: 'stringChunk', value: value});\n            }\n            if (this._expect === 'keyVal' ? this._packKeys : this._packStrings) {\n              this._accumulator += value;\n            }\n          }\n          if (noSticky) {\n            this._buffer = this._buffer.slice(value.length);\n          } else {\n            index += value.length;\n          }\n          break;\n        case 'key1':\n        case 'key':\n          patterns.key1.lastIndex = index;\n          match = patterns.key1.exec(this._buffer);\n          if (!match) {\n            if (index < this._buffer.length || this._done) return callback(new Error('Parser cannot parse input: expected an object key'));\n            break main; // wait for more input\n          }\n          value = match[0];\n          if (value === '\"') {\n            this._streamKeys && this.push({name: 'startKey'});\n            this._expect = 'keyVal';\n          } else if (value === '}') {\n            if (this._expect !== 'key1') return callback(new Error(\"Parser cannot parse input: unexpected token '}'\"));\n            this.push({name: 'endObject'});\n            this._parent = this._stack.pop();\n            this._expect = expected[this._parent];\n          }\n          if (noSticky) {\n            this._buffer = this._buffer.slice(value.length);\n          } else {\n            index += value.length;\n          }\n          break;\n        case 'colon':\n          patterns.colon.lastIndex = index;\n          match = patterns.colon.exec(this._buffer);\n          if (!match) {\n            if (index < this._buffer.length || this._done) return callback(new Error(\"Parser cannot parse input: expected ':'\"));\n            break main; // wait for more input\n          }\n          value = match[0];\n          value === ':' && (this._expect = 'value');\n          if (noSticky) {\n            this._buffer = this._buffer.slice(value.length);\n          } else {\n            index += value.length;\n          }\n          break;\n        case 'arrayStop':\n        case 'objectStop':\n          patterns.comma.lastIndex = index;\n          match = patterns.comma.exec(this._buffer);\n          if (!match) {\n            if (index < this._buffer.length || this._done) return callback(new Error(\"Parser cannot parse input: expected ','\"));\n            break main; // wait for more input\n          }\n          if (this._open_number) {\n            this._streamNumbers && this.push({name: 'endNumber'});\n            this._open_number = false;\n            if (this._packNumbers) {\n              this.push({name: 'numberValue', value: this._accumulator});\n              this._accumulator = '';\n            }\n          }\n          value = match[0];\n          if (value === ',') {\n            this._expect = this._expect === 'arrayStop' ? 'value' : 'key';\n          } else if (value === '}' || value === ']') {\n            if (value === '}' ? this._expect === 'arrayStop' : this._expect !== 'arrayStop') {\n              return callback(new Error(\"Parser cannot parse input: expected '\" + (this._expect === 'arrayStop' ? ']' : '}') + \"'\"));\n            }\n            this.push({name: value === '}' ? 'endObject' : 'endArray'});\n            this._parent = this._stack.pop();\n            this._expect = expected[this._parent];\n          }\n          if (noSticky) {\n            this._buffer = this._buffer.slice(value.length);\n          } else {\n            index += value.length;\n          }\n          break;\n        // number chunks\n        case 'numberStart': // [0-9]\n          patterns.numberStart.lastIndex = index;\n          match = patterns.numberStart.exec(this._buffer);\n          if (!match) {\n            if (index < this._buffer.length || this._done) return callback(new Error('Parser cannot parse input: expected a starting digit'));\n            break main; // wait for more input\n          }\n          value = match[0];\n          this._streamNumbers && this.push({name: 'numberChunk', value: value});\n          this._packNumbers && (this._accumulator += value);\n          this._expect = value === '0' ? 'numberFraction' : 'numberDigit';\n          if (noSticky) {\n            this._buffer = this._buffer.slice(value.length);\n          } else {\n            index += value.length;\n          }\n          break;\n        case 'numberDigit': // [0-9]*\n          patterns.numberDigit.lastIndex = index;\n          match = patterns.numberDigit.exec(this._buffer);\n          if (!match) {\n            if (index < this._buffer.length || this._done) return callback(new Error('Parser cannot parse input: expected a digit'));\n            break main; // wait for more input\n          }\n          value = match[0];\n          if (value) {\n            this._streamNumbers && this.push({name: 'numberChunk', value: value});\n            this._packNumbers && (this._accumulator += value);\n            if (noSticky) {\n              this._buffer = this._buffer.slice(value.length);\n            } else {\n              index += value.length;\n            }\n          } else {\n            if (index < this._buffer.length) {\n              this._expect = 'numberFraction';\n              break;\n            }\n            if (this._done) {\n              this._expect = expected[this._parent];\n              break;\n            }\n            break main; // wait for more input\n          }\n          break;\n        case 'numberFraction': // [\\.eE]?\n          patterns.numberFraction.lastIndex = index;\n          match = patterns.numberFraction.exec(this._buffer);\n          if (!match) {\n            if (index < this._buffer.length || this._done) {\n              this._expect = expected[this._parent];\n              break;\n            }\n            break main; // wait for more input\n          }\n          value = match[0];\n          this._streamNumbers && this.push({name: 'numberChunk', value: value});\n          this._packNumbers && (this._accumulator += value);\n          this._expect = value === '.' ? 'numberFracStart' : 'numberExpSign';\n          if (noSticky) {\n            this._buffer = this._buffer.slice(value.length);\n          } else {\n            index += value.length;\n          }\n          break;\n        case 'numberFracStart': // [0-9]\n          patterns.numberFracStart.lastIndex = index;\n          match = patterns.numberFracStart.exec(this._buffer);\n          if (!match) {\n            if (index < this._buffer.length || this._done) return callback(new Error('Parser cannot parse input: expected a fractional part of a number'));\n            break main; // wait for more input\n          }\n          value = match[0];\n          this._streamNumbers && this.push({name: 'numberChunk', value: value});\n          this._packNumbers && (this._accumulator += value);\n          this._expect = 'numberFracDigit';\n          if (noSticky) {\n            this._buffer = this._buffer.slice(value.length);\n          } else {\n            index += value.length;\n          }\n          break;\n        case 'numberFracDigit': // [0-9]*\n          patterns.numberFracDigit.lastIndex = index;\n          match = patterns.numberFracDigit.exec(this._buffer);\n          value = match[0];\n          if (value) {\n            this._streamNumbers && this.push({name: 'numberChunk', value: value});\n            this._packNumbers && (this._accumulator += value);\n            if (noSticky) {\n              this._buffer = this._buffer.slice(value.length);\n            } else {\n              index += value.length;\n            }\n          } else {\n            if (index < this._buffer.length) {\n              this._expect = 'numberExponent';\n              break;\n            }\n            if (this._done) {\n              this._expect = expected[this._parent];\n              break;\n            }\n            break main; // wait for more input\n          }\n          break;\n        case 'numberExponent': // [eE]?\n          patterns.numberExponent.lastIndex = index;\n          match = patterns.numberExponent.exec(this._buffer);\n          if (!match) {\n            if (index < this._buffer.length) {\n              this._expect = expected[this._parent];\n              break;\n            }\n            if (this._done) {\n              this._expect = 'done';\n              break;\n            }\n            break main; // wait for more input\n          }\n          value = match[0];\n          this._streamNumbers && this.push({name: 'numberChunk', value: value});\n          this._packNumbers && (this._accumulator += value);\n          this._expect = 'numberExpSign';\n          if (noSticky) {\n            this._buffer = this._buffer.slice(value.length);\n          } else {\n            index += value.length;\n          }\n          break;\n        case 'numberExpSign': // [-+]?\n          patterns.numberExpSign.lastIndex = index;\n          match = patterns.numberExpSign.exec(this._buffer);\n          if (!match) {\n            if (index < this._buffer.length) {\n              this._expect = 'numberExpStart';\n              break;\n            }\n            if (this._done) return callback(new Error('Parser has expected an exponent value of a number'));\n            break main; // wait for more input\n          }\n          value = match[0];\n          this._streamNumbers && this.push({name: 'numberChunk', value: value});\n          this._packNumbers && (this._accumulator += value);\n          this._expect = 'numberExpStart';\n          if (noSticky) {\n            this._buffer = this._buffer.slice(value.length);\n          } else {\n            index += value.length;\n          }\n          break;\n        case 'numberExpStart': // [0-9]\n          patterns.numberExpStart.lastIndex = index;\n          match = patterns.numberExpStart.exec(this._buffer);\n          if (!match) {\n            if (index < this._buffer.length || this._done) return callback(new Error('Parser cannot parse input: expected an exponent part of a number'));\n            break main; // wait for more input\n          }\n          value = match[0];\n          this._streamNumbers && this.push({name: 'numberChunk', value: value});\n          this._packNumbers && (this._accumulator += value);\n          this._expect = 'numberExpDigit';\n          if (noSticky) {\n            this._buffer = this._buffer.slice(value.length);\n          } else {\n            index += value.length;\n          }\n          break;\n        case 'numberExpDigit': // [0-9]*\n          patterns.numberExpDigit.lastIndex = index;\n          match = patterns.numberExpDigit.exec(this._buffer);\n          value = match[0];\n          if (value) {\n            this._streamNumbers && this.push({name: 'numberChunk', value: value});\n            this._packNumbers && (this._accumulator += value);\n            if (noSticky) {\n              this._buffer = this._buffer.slice(value.length);\n            } else {\n              index += value.length;\n            }\n          } else {\n            if (index < this._buffer.length || this._done) {\n              this._expect = expected[this._parent];\n              break;\n            }\n            break main; // wait for more input\n          }\n          break;\n        case 'done':\n          patterns.ws.lastIndex = index;\n          match = patterns.ws.exec(this._buffer);\n          if (!match) {\n            if (index < this._buffer.length) {\n              if (this._jsonStreaming) {\n                this._expect = 'value';\n                break;\n              }\n              return callback(new Error('Parser cannot parse input: unexpected characters'));\n            }\n            break main; // wait for more input\n          }\n          value = match[0];\n          if (this._open_number) {\n            this._streamNumbers && this.push({name: 'endNumber'});\n            this._open_number = false;\n            if (this._packNumbers) {\n              this.push({name: 'numberValue', value: this._accumulator});\n              this._accumulator = '';\n            }\n          }\n          if (noSticky) {\n            this._buffer = this._buffer.slice(value.length);\n          } else {\n            index += value.length;\n          }\n          break;\n      }\n    }\n    !noSticky && (this._buffer = this._buffer.slice(index));\n    callback(null);\n  }\n}\nParser.parser = Parser.make;\nParser.make.Constructor = Parser;\n\nmodule.exports = Parser;\n", "'use strict';\n\nconst emit = stream => stream.on('data', item => stream.emit(item.name, item.value));\n\nmodule.exports = emit;\n", "'use strict';\n\nconst Parser = require('./Parser');\nconst emit = require('./utils/emit');\n\nconst make = options => emit(new Parser(options));\n\nmake.Parser = Parser;\nmake.parser = Parser.parser;\n\nmodule.exports = make;\n", "'use strict';\n\nconst {Transform} = require('stream');\n\nclass FilterBase extends Transform {\n  static stringFilter(string, separator) {\n    return stack => {\n      const path = stack.join(separator);\n      return (\n        (path.length === string.length && path === string) ||\n        (path.length > string.length && path.substr(0, string.length) === string && path.substr(string.length, separator.length) === separator)\n      );\n    };\n  }\n\n  static regExpFilter(regExp, separator) {\n    return stack => regExp.test(stack.join(separator));\n  }\n\n  static arrayReplacement(array) {\n    return () => array;\n  }\n\n  constructor(options) {\n    super(Object.assign({}, options, {writableObjectMode: true, readableObjectMode: true}));\n    this._transform = this._check;\n    this._stack = [];\n\n    const filter = options && options.filter,\n      separator = (options && options.pathSeparator) || '.';\n    if (typeof filter == 'string') {\n      this._filter = FilterBase.stringFilter(filter, separator);\n    } else if (typeof filter == 'function') {\n      this._filter = filter;\n    } else if (filter instanceof RegExp) {\n      this._filter = FilterBase.regExpFilter(filter, separator);\n    }\n\n    const replacement = options && options.replacement;\n    if (typeof replacement == 'function') {\n      this._replacement = replacement;\n    } else {\n      this._replacement = FilterBase.arrayReplacement(replacement || FilterBase.defaultReplacement);\n    }\n    this._allowEmptyReplacement = options && options.allowEmptyReplacement;\n\n    this._streamKeys = true;\n    if (options) {\n      'streamValues' in options && (this._streamKeys = options.streamValues);\n      'streamKeys' in options && (this._streamKeys = options.streamKeys);\n    }\n\n    this._once = options && options.once;\n    this._previousToken = '';\n  }\n\n  _check(chunk, _, callback) {\n    // update the last stack key\n    switch (chunk.name) {\n      case 'startObject':\n      case 'startArray':\n      case 'startString':\n      case 'startNumber':\n      case 'nullValue':\n      case 'trueValue':\n      case 'falseValue':\n        if (typeof this._stack[this._stack.length - 1] == 'number') {\n          // array\n          ++this._stack[this._stack.length - 1];\n        }\n        break;\n      case 'keyValue':\n        this._stack[this._stack.length - 1] = chunk.value;\n        break;\n      case 'numberValue':\n        if (this._previousToken !== 'endNumber' && typeof this._stack[this._stack.length - 1] == 'number') {\n          // array\n          ++this._stack[this._stack.length - 1];\n        }\n        break;\n      case 'stringValue':\n        if (this._previousToken !== 'endString' && typeof this._stack[this._stack.length - 1] == 'number') {\n          // array\n          ++this._stack[this._stack.length - 1];\n        }\n        break;\n    }\n    this._previousToken = chunk.name;\n    // check, if we allow a chunk\n    if (this._checkChunk(chunk)) {\n      return callback(null);\n    }\n    // update the stack\n    switch (chunk.name) {\n      case 'startObject':\n        this._stack.push(null);\n        break;\n      case 'startArray':\n        this._stack.push(-1);\n        break;\n      case 'endObject':\n      case 'endArray':\n        this._stack.pop();\n        break;\n    }\n    callback(null);\n  }\n\n  _passObject(chunk, _, callback) {\n    this.push(chunk);\n    switch (chunk.name) {\n      case 'startObject':\n      case 'startArray':\n        ++this._depth;\n        break;\n      case 'endObject':\n      case 'endArray':\n        --this._depth;\n        break;\n    }\n    if (!this._depth) {\n      this._transform = this._once ? this._skip : this._check;\n    }\n    callback(null);\n  }\n\n  _pass(chunk, _, callback) {\n    this.push(chunk);\n    callback(null);\n  }\n\n  _skipObject(chunk, _, callback) {\n    switch (chunk.name) {\n      case 'startObject':\n      case 'startArray':\n        ++this._depth;\n        break;\n      case 'endObject':\n      case 'endArray':\n        --this._depth;\n        break;\n    }\n    if (!this._depth) {\n      this._transform = this._once ? this._pass : this._check;\n    }\n    callback(null);\n  }\n\n  _skip(chunk, _, callback) {\n    callback(null);\n  }\n}\n\nFilterBase.defaultReplacement = [{name: 'nullValue', value: null}];\n\nconst passValue = (last, post) =>\n  function(chunk, _, callback) {\n    if (this._expected) {\n      const expected = this._expected;\n      this._expected = '';\n      this._transform = this._once ? this._skip : this._check;\n      if (expected === chunk.name) {\n        this.push(chunk);\n      } else {\n        return this._transform(chunk, _, callback);\n      }\n    } else {\n      this.push(chunk);\n      if (chunk.name === last) {\n        this._expected = post;\n      }\n    }\n    callback(null);\n  };\n\nFilterBase.prototype._passNumber = passValue('endNumber', 'numberValue');\nFilterBase.prototype._passString = passValue('endString', 'stringValue');\nFilterBase.prototype._passKey = passValue('endKey', 'keyValue');\n\nconst skipValue = (last, post) =>\n  function(chunk, _, callback) {\n    if (this._expected) {\n      const expected = this._expected;\n      this._expected = '';\n      this._transform = this._once ? this._pass : this._check;\n      if (expected !== chunk.name) {\n        return this._transform(chunk, _, callback);\n      }\n    } else {\n      if (chunk.name === last) {\n        this._expected = post;\n      }\n    }\n    callback(null);\n  };\n\nFilterBase.prototype._skipNumber = skipValue('endNumber', 'numberValue');\nFilterBase.prototype._skipString = skipValue('endString', 'stringValue');\nFilterBase.prototype._skipKey = skipValue('endKey', 'keyValue');\n\nmodule.exports = FilterBase;\n", "'use strict';\n\nconst {chain} = require('stream-chain');\n\nconst Parser = require('../Parser');\n\nconst withParser = (fn, options) =>\n  chain([new Parser(options), fn(options)], Object.assign({}, options, {writableObjectMode: false, readableObjectMode: true}));\n\nmodule.exports = withParser;\n", "'use strict';\n\nconst FilterBase = require('./FilterBase');\nconst withParser = require('../utils/withParser');\n\nclass Filter extends FilterBase {\n  static make(options) {\n    return new Filter(options);\n  }\n\n  static withParser(options) {\n    return withParser(Filter.make, options);\n  }\n\n  constructor(options) {\n    super(options);\n    this._once = false;\n    this._lastStack = [];\n  }\n\n  _flush(callback) {\n    this._syncStack();\n    callback(null);\n  }\n\n  _checkChunk(chunk) {\n    switch (chunk.name) {\n      case 'startObject':\n        if (this._filter(this._stack, chunk)) {\n          this._syncStack();\n          this.push(chunk);\n          this._lastStack.push(null);\n        }\n        break;\n      case 'startArray':\n        if (this._filter(this._stack, chunk)) {\n          this._syncStack();\n          this.push(chunk);\n          this._lastStack.push(-1);\n        }\n        break;\n      case 'nullValue':\n      case 'trueValue':\n      case 'falseValue':\n      case 'stringValue':\n      case 'numberValue':\n        if (this._filter(this._stack, chunk)) {\n          this._syncStack();\n          this.push(chunk);\n        }\n        break;\n      case 'startString':\n        if (this._filter(this._stack, chunk)) {\n          this._syncStack();\n          this.push(chunk);\n          this._transform = this._passString;\n        } else {\n          this._transform = this._skipString;\n        }\n        break;\n      case 'startNumber':\n        if (this._filter(this._stack, chunk)) {\n          this._syncStack();\n          this.push(chunk);\n          this._transform = this._passNumber;\n        } else {\n          this._transform = this._skipNumber;\n        }\n        break;\n    }\n    return false;\n  }\n\n  _syncStack() {\n    const stack = this._stack,\n      last = this._lastStack,\n      stackLength = stack.length,\n      lastLength = last.length;\n\n    // find the common part\n    let commonLength = 0;\n    for (const n = Math.min(stackLength, lastLength); commonLength < n && stack[commonLength] === last[commonLength]; ++commonLength);\n\n    // close old objects\n    for (let i = lastLength - 1; i > commonLength; --i) {\n      this.push({name: typeof last[i] == 'number' ? 'endArray' : 'endObject'});\n    }\n    if (commonLength < lastLength) {\n      if (commonLength < stackLength) {\n        if (typeof stack[commonLength] == 'string') {\n          const key = stack[commonLength];\n          if (this._streamKeys) {\n            this.push({name: 'startKey'});\n            this.push({name: 'stringChunk', value: key});\n            this.push({name: 'endKey'});\n          }\n          this.push({name: 'keyValue', value: key});\n        }\n        ++commonLength;\n      } else {\n        this.push({name: typeof last[commonLength] == 'number' ? 'endArray' : 'endObject'});\n      }\n    }\n\n    // open new objects\n    for (let i = commonLength; i < stackLength; ++i) {\n      const key = stack[i];\n      if (typeof key == 'number') {\n        if (key >= 0) {\n          this.push({name: 'startArray'});\n        }\n      } else if (typeof key == 'string') {\n        this.push({name: 'startObject'});\n        if (this._streamKeys) {\n          this.push({name: 'startKey'});\n          this.push({name: 'stringChunk', value: key});\n          this.push({name: 'endKey'});\n        }\n        this.push({name: 'keyValue', value: key});\n      }\n    }\n\n    // update the last stack\n    this._lastStack = Array.prototype.concat.call(stack);\n  }\n}\nFilter.filter = Filter.make;\nFilter.make.Constructor = Filter;\n\nmodule.exports = Filter;\n", "'use strict';\n\nconst EventEmitter = require('events');\n\nconst startObject = Ctr =>\n  function () {\n    if (this.done) {\n      this.done = false;\n    } else {\n      this.stack.push(this.current, this.key);\n    }\n    this.current = new Ctr();\n    this.key = null;\n  };\n\nclass Assembler extends EventEmitter {\n  static connectTo(stream, options) {\n    return new Assembler(options).connectTo(stream);\n  }\n\n  constructor(options) {\n    super();\n    this.stack = [];\n    this.current = this.key = null;\n    this.done = true;\n    if (options) {\n      this.reviver = typeof options.reviver == 'function' && options.reviver;\n      if (this.reviver) {\n        this.stringValue = this._saveValue = this._saveValueWithReviver;\n      }\n      if (options.numberAsString) {\n        this.numberValue = this.stringValue;\n      }\n    }\n  }\n\n  connectTo(stream) {\n    stream.on('data', chunk => {\n      if (this[chunk.name]) {\n        this[chunk.name](chunk.value);\n        if (this.done) this.emit('done', this);\n      }\n    });\n    return this;\n  }\n\n  get depth() {\n    return (this.stack.length >> 1) + (this.done ? 0 : 1);\n  }\n\n  get path() {\n    const path = [];\n    for (let i = 0; i < this.stack.length; i += 2) {\n      const key = this.stack[i + 1];\n      path.push(key === null ? this.stack[i].length : key);\n    }\n    return path;\n  }\n\n  dropToLevel(level) {\n    if (level < this.depth) {\n      if (level) {\n        const index = (level - 1) << 1;\n        this.current = this.stack[index];\n        this.key = this.stack[index + 1];\n        this.stack.splice(index);\n      } else {\n        this.stack = [];\n        this.current = this.key = null;\n        this.done = true;\n      }\n    }\n    return this;\n  }\n\n  consume(chunk) {\n    this[chunk.name] && this[chunk.name](chunk.value);\n    return this;\n  }\n\n  keyValue(value) {\n    this.key = value;\n  }\n\n  //stringValue() - aliased below to _saveValue()\n\n  numberValue(value) {\n    this._saveValue(parseFloat(value));\n  }\n  nullValue() {\n    this._saveValue(null);\n  }\n  trueValue() {\n    this._saveValue(true);\n  }\n  falseValue() {\n    this._saveValue(false);\n  }\n\n  //startObject() - assigned below\n\n  endObject() {\n    if (this.stack.length) {\n      const value = this.current;\n      this.key = this.stack.pop();\n      this.current = this.stack.pop();\n      this._saveValue(value);\n    } else {\n      this.done = true;\n    }\n  }\n\n  //startArray() - assigned below\n  //endArray() - aliased below to endObject()\n\n  _saveValue(value) {\n    if (this.done) {\n      this.current = value;\n    } else {\n      if (this.current instanceof Array) {\n        this.current.push(value);\n      } else {\n        this.current[this.key] = value;\n        this.key = null;\n      }\n    }\n  }\n  _saveValueWithReviver(value) {\n    if (this.done) {\n      this.current = this.reviver('', value);\n    } else {\n      if (this.current instanceof Array) {\n        value = this.reviver('' + this.current.length, value);\n        this.current.push(value);\n        if (value === undefined) {\n          delete this.current[this.current.length - 1];\n        }\n      } else {\n        value = this.reviver(this.key, value);\n        if (value !== undefined) {\n          this.current[this.key] = value;\n        }\n        this.key = null;\n      }\n    }\n  }\n}\n\nAssembler.prototype.stringValue = Assembler.prototype._saveValue;\nAssembler.prototype.startObject = startObject(Object);\nAssembler.prototype.startArray = startObject(Array);\nAssembler.prototype.endArray = Assembler.prototype.endObject;\n\nmodule.exports = Assembler;\n", "'use strict';\n\nconst {Transform} = require('stream');\nconst Assembler = require('../Assembler');\n\nclass Counter {\n  constructor(initialDepth) {\n    this.depth = initialDepth;\n  }\n  startObject() {\n    ++this.depth;\n  }\n  endObject() {\n    --this.depth;\n  }\n  startArray() {\n    ++this.depth;\n  }\n  endArray() {\n    --this.depth;\n  }\n}\n\nclass StreamBase extends Transform {\n  constructor(options) {\n    super(Object.assign({}, options, {writableObjectMode: true, readableObjectMode: true}));\n    if (options) {\n      this.objectFilter = options.objectFilter;\n      this.includeUndecided = options.includeUndecided;\n    }\n    if (typeof this.objectFilter != 'function') {\n      this._filter = this._transform;\n    }\n    this._transform = this._wait || this._filter;\n    this._assembler = new Assembler(options);\n  }\n\n  _transform(chunk, encoding, callback) {\n    if (this._assembler[chunk.name]) {\n      this._assembler[chunk.name](chunk.value);\n      if (this._assembler.depth === this._level) {\n        this._push();\n      }\n    }\n    callback(null);\n  }\n\n  _filter(chunk, encoding, callback) {\n    if (this._assembler[chunk.name]) {\n      this._assembler[chunk.name](chunk.value);\n      const result = this.objectFilter(this._assembler);\n      if (result) {\n        if (this._assembler.depth === this._level) {\n          this._push();\n          this._transform = this._filter;\n        }\n        this._transform = this._accept;\n        return callback(null);\n      }\n      if (result === false) {\n        this._saved_assembler = this._assembler;\n        this._assembler = new Counter(this._saved_assembler.depth);\n        this._saved_assembler.dropToLevel(this._level);\n        if (this._assembler.depth === this._level) {\n          this._assembler = this._saved_assembler;\n          this._transform = this._filter;\n        }\n        this._transform = this._reject;\n        return callback(null);\n      }\n      if (this._assembler.depth === this._level) {\n        this._push(!this.includeUndecided);\n      }\n    }\n    callback(null);\n  }\n\n  _accept(chunk, encoding, callback) {\n    if (this._assembler[chunk.name]) {\n      this._assembler[chunk.name](chunk.value);\n      if (this._assembler.depth === this._level) {\n        this._push();\n        this._transform = this._filter;\n      }\n    }\n    callback(null);\n  }\n\n  _reject(chunk, encoding, callback) {\n    if (this._assembler[chunk.name]) {\n      this._assembler[chunk.name](chunk.value);\n      if (this._assembler.depth === this._level) {\n        this._assembler = this._saved_assembler;\n        this._transform = this._filter;\n      }\n    }\n    callback(null);\n  }\n}\n\nmodule.exports = StreamBase;\n", "'use strict';\n\nconst StreamBase = require('./StreamBase');\nconst withParser = require('../utils/withParser');\n\nclass StreamArray extends StreamBase {\n  static make(options) {\n    return new StreamArray(options);\n  }\n\n  static withParser(options) {\n    return withParser(StreamArray.make, options);\n  }\n\n  constructor(options) {\n    super(options);\n    this._level = 1;\n    this._counter = 0;\n  }\n\n  _wait(chunk, _, callback) {\n    // first chunk should open an array\n    if (chunk.name !== 'startArray') {\n      return callback(new Error('Top-level object should be an array.'));\n    }\n    this._transform = this._filter;\n    return this._transform(chunk, _, callback);\n  }\n\n  _push(discard) {\n    if (this._assembler.current.length) {\n      if (discard) {\n        ++this._counter;\n        this._assembler.current.pop();\n      } else {\n        this.push({key: this._counter++, value: this._assembler.current.pop()});\n      }\n    }\n  }\n}\nStreamArray.streamArray = StreamArray.make;\nStreamArray.make.Constructor = StreamArray;\n\nmodule.exports = StreamArray;\n", "import { showToast, Toast } from \"@raycast/api\";\nimport { brewCleanup } from \"./utils/brew\";\nimport { showActionToast, showBrewFailureToast, wait, ensureError } from \"./utils\";\nimport { preferences } from \"./utils\";\n\nexport default async (): Promise<void> => {\n  try {\n    const handle = showActionToast({\n      title: \"Cleaning files & packages from the cache\" + String.ellipsis,\n      cancelable: true,\n    });\n    await brewCleanup(preferences.withoutThreshold, handle.abort?.signal);\n    showToast(Toast.Style.Success, \"Cleaning completed\");\n  } catch (err) {\n    await showBrewFailureToast(\"Cleaning failed\", ensureError(err));\n    await wait(3000);\n  }\n};\n", "/**\n * Homebrew path utilities.\n *\n * Provides functions for resolving brew installation paths.\n */\n\nimport { execSync } from \"child_process\";\nimport { join as path_join } from \"path\";\nimport { cpus } from \"os\";\nimport { preferences } from \"../preferences\";\n\n/**\n * The Homebrew prefix directory.\n * Determined by:\n * 1. Custom brew path preference (if set)\n * 2. Running `brew --prefix` command\n * 3. Fallback based on CPU architecture\n */\nexport const brewPrefix = (() => {\n  if (preferences.customBrewPath && preferences.customBrewPath.length > 0)\n    return path_join(preferences.customBrewPath, \"..\", \"..\");\n  try {\n    return execSync(\"brew --prefix\", { encoding: \"utf8\" }).trim();\n  } catch {\n    const firstCpu = cpus()[0];\n    return firstCpu?.model?.includes(\"Apple\") ? \"/opt/homebrew\" : \"/usr/local\";\n  }\n})();\n\n/**\n * Get a path relative to the brew prefix.\n */\nexport const brewPath = (suffix: string): string => path_join(brewPrefix, suffix);\n\n/**\n * Get the path to the brew executable.\n */\nexport const brewExecutable = (): string => brewPath(\"bin/brew\");\n", "import { getPreferenceValues } from \"@raycast/api\";\n\nexport const preferences = <Preferences & Preferences.CleanUp>getPreferenceValues();\n", "/**\n * Homebrew command execution utilities.\n *\n * Provides functions for executing brew commands with proper error handling.\n *\n * Homebrew 5.0 Compatibility Notes:\n * - Download concurrency is now enabled by default (HOMEBREW_DOWNLOAD_CONCURRENCY=auto)\n * - The extension supports controlling this via preferences\n * - --no-quarantine and --quarantine flags are deprecated\n * - HOMEBREW_USE_INTERNAL_API can be enabled for the new smaller JSON API\n */\n\nimport { exec } from \"child_process\";\nimport { promisify } from \"util\";\nimport { constants as fs_constants } from \"fs\";\nimport * as fs from \"fs/promises\";\nimport { join as path_join } from \"path\";\nimport { environment } from \"@raycast/api\";\nimport { ExecError, ExecResult } from \"../types\";\nimport { brewExecutable } from \"./paths\";\nimport { preferences } from \"../preferences\";\nimport { brewLogger } from \"../logger\";\nimport { BrewLockError, isBrewLockMessage } from \"../errors\";\nimport { bundleIdentifier } from \"../cache\";\n\nconst execp = promisify(exec);\n\n// Track if we've logged the Homebrew 5.0 environment configuration\nlet homebrewEnvLogged = false;\n\n/**\n * Execute a brew command.\n */\nexport async function execBrew(cmd: string, options?: { signal?: AbortSignal }): Promise<ExecResult> {\n  try {\n    const env = await execBrewEnv();\n    return await execp(`${brewExecutable()} ${cmd}`, {\n      signal: options?.signal,\n      env: env,\n      maxBuffer: 10 * 1024 * 1024,\n    });\n  } catch (err) {\n    const execErr = err as ExecError;\n\n    // Check for brew lock/concurrent process error\n    const errorOutput = execErr?.stderr || execErr?.stdout || \"\";\n    if (isBrewLockMessage(errorOutput)) {\n      brewLogger.warn(\"Brew lock detected - another process is running\", {\n        command: cmd,\n        stderr: execErr?.stderr,\n      });\n      throw new BrewLockError(\"Another brew process is already running\", {\n        command: cmd,\n        cause: execErr,\n      });\n    }\n\n    // Check for brew not found\n    if (preferences.customBrewPath && execErr && execErr.code === 127) {\n      execErr.stderr = `Brew executable not found at: ${preferences.customBrewPath}`;\n      throw execErr;\n    }\n\n    throw err;\n  }\n}\n\n/**\n * Get the environment variables for brew execution.\n *\n * Homebrew 5.0 environment variables:\n * - HOMEBREW_DOWNLOAD_CONCURRENCY: Controls parallel downloads (default: \"auto\")\n *   Set to \"1\" to disable concurrent downloads\n */\nexport async function execBrewEnv(): Promise<NodeJS.ProcessEnv> {\n  const askpassPath = path_join(environment.assetsPath, \"askpass.sh\");\n  try {\n    await fs.access(askpassPath, fs_constants.X_OK);\n  } catch {\n    await fs.chmod(askpassPath, 0o755);\n  }\n  const env = { ...process.env };\n  env[\"SUDO_ASKPASS\"] = askpassPath;\n  // Use HOMEBREW_BROWSER to pass through the app's bundle identifier.\n  // Brew will ignore custom environment variables.\n  env[\"HOMEBREW_BROWSER\"] = bundleIdentifier;\n\n  // Homebrew 5.0: Control download concurrency\n  // By default, Homebrew 5.0 enables concurrent downloads (auto)\n  // Users can disable this via preferences if they experience issues\n  const downloadConcurrencyDisabled = preferences.disableDownloadConcurrency;\n  if (downloadConcurrencyDisabled) {\n    env[\"HOMEBREW_DOWNLOAD_CONCURRENCY\"] = \"1\";\n  }\n\n  // Homebrew 5.0: Opt-in to the new internal API (smaller JSON)\n  // This will become default in a future version\n  const useInternalApi = preferences.useInternalApi;\n  if (useInternalApi) {\n    env[\"HOMEBREW_USE_INTERNAL_API\"] = \"1\";\n  }\n\n  // Log Homebrew 5.0 configuration once per session\n  if (!homebrewEnvLogged) {\n    homebrewEnvLogged = true;\n    brewLogger.log(\"Homebrew 5.0 Configuration\", {\n      downloadConcurrencyEnabled: !downloadConcurrencyDisabled,\n      downloadConcurrencyMode: downloadConcurrencyDisabled ? \"sequential (1)\" : \"parallel (auto)\",\n      internalApiEnabled: useInternalApi,\n      verboseLogging: preferences.verboseLogging,\n    });\n  }\n\n  return env;\n}\n", "/**\n * Logger utilities for the Brew extension.\n *\n * Uses @chrismessina/raycast-logger for verbose logging support.\n * Child loggers are created for different modules to provide context.\n */\n\nimport { Logger } from \"@chrismessina/raycast-logger\";\n\n/**\n * Main logger instance for the Brew extension.\n */\nexport const logger = new Logger({\n  prefix: \"[Brew]\",\n});\n\n/**\n * Child logger for brew command operations.\n */\nexport const brewLogger = logger.child(\"[Commands]\");\n\n/**\n * Child logger for cache operations.\n */\nexport const cacheLogger = logger.child(\"[Cache]\");\n\n/**\n * Child logger for action operations (install, uninstall, upgrade).\n */\nexport const actionsLogger = logger.child(\"[Actions]\");\n\n/**\n * Child logger for fetch operations.\n */\nexport const fetchLogger = logger.child(\"[Fetch]\");\n\n/**\n * Child logger for search operations.\n */\nexport const searchLogger = logger.child(\"[Search]\");\n\n/**\n * Child logger for UI operations (toasts, etc.).\n */\nexport const uiLogger = logger.child(\"[UI]\");\n", "/**\n * Error types for the Brew extension.\n *\n * Provides granular error types for different failure scenarios:\n * - Network errors (transient, recoverable)\n * - Parse errors (corrupted data)\n * - Brew command errors (brew-specific failures)\n * - Brew lock errors (concurrent process detection)\n * - Cache errors (file system issues)\n */\n\n/**\n * Base error class for all Brew extension errors.\n */\nexport class BrewError extends Error {\n  readonly brewCause?: Error;\n\n  constructor(message: string, options?: { cause?: Error }) {\n    super(message);\n    this.name = \"BrewError\";\n    this.brewCause = options?.cause;\n  }\n}\n\n/**\n * Network-related errors (HTTP failures, timeouts, etc.).\n * These are typically transient and recoverable.\n */\nexport class NetworkError extends BrewError {\n  readonly statusCode?: number;\n  readonly url?: string;\n\n  constructor(message: string, options?: { cause?: Error; statusCode?: number; url?: string }) {\n    super(message, { cause: options?.cause });\n    this.name = \"NetworkError\";\n    this.statusCode = options?.statusCode;\n    this.url = options?.url;\n  }\n}\n\n/**\n * Parse errors for corrupted or invalid data.\n */\nexport class ParseError extends BrewError {\n  constructor(message: string, options?: { cause?: Error }) {\n    super(message, options);\n    this.name = \"ParseError\";\n  }\n}\n\n/**\n * Brew command execution errors.\n */\nexport class BrewCommandError extends BrewError {\n  readonly command?: string;\n  readonly exitCode?: number;\n  readonly stderr?: string;\n\n  constructor(message: string, options?: { cause?: Error; command?: string; exitCode?: number; stderr?: string }) {\n    super(message, { cause: options?.cause });\n    this.name = \"BrewCommandError\";\n    this.command = options?.command;\n    this.exitCode = options?.exitCode;\n    this.stderr = options?.stderr;\n  }\n}\n\n/**\n * Error when brew executable is not found.\n */\nexport class BrewNotFoundError extends BrewError {\n  readonly path?: string;\n\n  constructor(message: string, options?: { cause?: Error; path?: string }) {\n    super(message, { cause: options?.cause });\n    this.name = \"BrewNotFoundError\";\n    this.path = options?.path;\n  }\n}\n\n/**\n * Cache-related errors (file system issues).\n */\nexport class CacheError extends BrewError {\n  readonly path?: string;\n\n  constructor(message: string, options?: { cause?: Error; path?: string }) {\n    super(message, { cause: options?.cause });\n    this.name = \"CacheError\";\n    this.path = options?.path;\n  }\n}\n\n/**\n * Error when another brew process is already running.\n * This is a recoverable error - the user can retry after the other process finishes.\n */\nexport class BrewLockError extends BrewError {\n  readonly command?: string;\n\n  constructor(message: string, options?: { cause?: Error; command?: string }) {\n    super(message, { cause: options?.cause });\n    this.name = \"BrewLockError\";\n    this.command = options?.command;\n  }\n}\n\n/**\n * Error when a download or operation times out.\n * This is a recoverable error - the user can retry.\n */\nexport class DownloadTimeoutError extends BrewError {\n  readonly packageName?: string;\n  readonly phase?: string;\n  readonly timeoutMs?: number;\n  readonly elapsedMs?: number;\n\n  constructor(\n    message: string,\n    options?: {\n      cause?: Error;\n      packageName?: string;\n      phase?: string;\n      timeoutMs?: number;\n      elapsedMs?: number;\n    },\n  ) {\n    super(message, { cause: options?.cause });\n    this.name = \"DownloadTimeoutError\";\n    this.packageName = options?.packageName;\n    this.phase = options?.phase;\n    this.timeoutMs = options?.timeoutMs;\n    this.elapsedMs = options?.elapsedMs;\n  }\n}\n\n/**\n * Error when a brew process appears to be stale/stuck.\n * This happens when no progress is made for an extended period.\n */\nexport class StaleProcessError extends BrewError {\n  readonly packageName?: string;\n  readonly lastPhase?: string;\n  readonly staleDurationMs?: number;\n\n  constructor(\n    message: string,\n    options?: {\n      cause?: Error;\n      packageName?: string;\n      lastPhase?: string;\n      staleDurationMs?: number;\n    },\n  ) {\n    super(message, { cause: options?.cause });\n    this.name = \"StaleProcessError\";\n    this.packageName = options?.packageName;\n    this.lastPhase = options?.lastPhase;\n    this.staleDurationMs = options?.staleDurationMs;\n  }\n}\n\n/**\n * Error when a package is not found.\n */\nexport class PackageNotFoundError extends BrewError {\n  readonly packageName?: string;\n  readonly packageType?: \"formula\" | \"cask\";\n\n  constructor(message: string, options?: { cause?: Error; packageName?: string; packageType?: \"formula\" | \"cask\" }) {\n    super(message, { cause: options?.cause });\n    this.name = \"PackageNotFoundError\";\n    this.packageName = options?.packageName;\n    this.packageType = options?.packageType;\n  }\n}\n\n/**\n * Error when a package has been disabled/discontinued.\n * This is not recoverable - the package is no longer available.\n */\nexport class PackageDisabledError extends BrewError {\n  readonly packageName?: string;\n  readonly packageType?: \"formula\" | \"cask\";\n  readonly disabledDate?: string;\n  readonly reason?: string;\n\n  constructor(\n    message: string,\n    options?: {\n      cause?: Error;\n      packageName?: string;\n      packageType?: \"formula\" | \"cask\";\n      disabledDate?: string;\n      reason?: string;\n    },\n  ) {\n    super(message, { cause: options?.cause });\n    this.name = \"PackageDisabledError\";\n    this.packageName = options?.packageName;\n    this.packageType = options?.packageType;\n    this.disabledDate = options?.disabledDate;\n    this.reason = options?.reason;\n  }\n}\n\n/**\n * Error when a package conflicts with another installed package.\n */\nexport class PackageConflictError extends BrewError {\n  readonly packageName?: string;\n  readonly conflictsWith?: string[];\n\n  constructor(message: string, options?: { cause?: Error; packageName?: string; conflictsWith?: string[] }) {\n    super(message, { cause: options?.cause });\n    this.name = \"PackageConflictError\";\n    this.packageName = options?.packageName;\n    this.conflictsWith = options?.conflictsWith;\n  }\n}\n\n/**\n * Error when a package requires a specific macOS version.\n */\nexport class UnsupportedMacOSError extends BrewError {\n  readonly packageName?: string;\n  readonly requiredVersion?: string;\n  readonly currentVersion?: string;\n\n  constructor(\n    message: string,\n    options?: { cause?: Error; packageName?: string; requiredVersion?: string; currentVersion?: string },\n  ) {\n    super(message, { cause: options?.cause });\n    this.name = \"UnsupportedMacOSError\";\n    this.packageName = options?.packageName;\n    this.requiredVersion = options?.requiredVersion;\n    this.currentVersion = options?.currentVersion;\n  }\n}\n\n/// Type Guards\n\n/**\n * Check if an error is a BrewError.\n */\nexport function isBrewError(error: unknown): error is BrewError {\n  return error instanceof BrewError;\n}\n\n/**\n * Check if an error is a NetworkError.\n */\nexport function isNetworkError(error: unknown): error is NetworkError {\n  return error instanceof NetworkError;\n}\n\n/**\n * Check if an error is a BrewLockError.\n */\nexport function isBrewLockError(error: unknown): error is BrewLockError {\n  return error instanceof BrewLockError;\n}\n\n/**\n * Check if an error is a DownloadTimeoutError.\n */\nexport function isDownloadTimeoutError(error: unknown): error is DownloadTimeoutError {\n  return error instanceof DownloadTimeoutError;\n}\n\n/**\n * Check if an error is a StaleProcessError.\n */\nexport function isStaleProcessError(error: unknown): error is StaleProcessError {\n  return error instanceof StaleProcessError;\n}\n\n/**\n * Check if an error is a PackageDisabledError.\n */\nexport function isPackageDisabledError(error: unknown): error is PackageDisabledError {\n  return error instanceof PackageDisabledError;\n}\n\n/**\n * Check if an error is a PackageConflictError.\n */\nexport function isPackageConflictError(error: unknown): error is PackageConflictError {\n  return error instanceof PackageConflictError;\n}\n\n/**\n * Check if an error is an UnsupportedMacOSError.\n */\nexport function isUnsupportedMacOSError(error: unknown): error is UnsupportedMacOSError {\n  return error instanceof UnsupportedMacOSError;\n}\n\n/**\n * Check if an error is recoverable (can be retried).\n * Network errors, lock errors, timeout errors, and stale process errors are typically recoverable.\n * Disabled packages, conflicts, and macOS version errors are NOT recoverable.\n */\nexport function isRecoverableError(error: unknown): boolean {\n  return isNetworkError(error) || isBrewLockError(error) || isDownloadTimeoutError(error) || isStaleProcessError(error);\n}\n\n/// Message Detection\n\n/**\n * Patterns that indicate a brew lock/concurrent process error.\n */\nconst BREW_LOCK_PATTERNS = [\n  /lockf:.*already locked/i,\n  /another active Homebrew/i,\n  /another brew process/i,\n  /another.*brew.*update.*process/i,\n  /Homebrew is already running/i,\n  /Error: Another active Homebrew/i,\n  /Error: Another.*brew.*process/i,\n  /waiting for lock/i,\n  /lock file/i,\n  /has already locked/i, // Homebrew 5.0: \"A `brew upgrade` process has already locked ...\"\n  /brew upgrade.*process has already/i,\n];\n\n/**\n * Pattern to detect disabled/discontinued packages.\n * Matches: \"Error: Cask 'name' has been disabled because it is discontinued upstream! It was disabled on 2024-12-16.\"\n * Or: \"Error: Formula 'name' has been disabled because ...\"\n */\nconst DISABLED_PACKAGE_PATTERN =\n  /Error: (Cask|Formula) '([^']+)' has been disabled(?: because (.+?))?(?:! It was disabled on (\\d{4}-\\d{2}-\\d{2}))?/i;\n\n/**\n * Pattern to detect package conflicts.\n * Matches: \"Error: Cask 'name' conflicts with 'other'\"\n */\nconst CONFLICT_PATTERN = /Error: (Cask|Formula) '([^']+)' conflicts with '([^']+)'/i;\n\n/**\n * Pattern to detect macOS version requirements.\n * Matches: \"Error: Cask 'name' requires macOS >= 12.0\"\n */\nconst MACOS_VERSION_PATTERN = /Error: (Cask|Formula) '([^']+)' requires macOS\\s*([><=]+\\s*[\\d.]+)/i;\n\n/**\n * Check if an error message indicates a brew lock error.\n */\nexport function isBrewLockMessage(message: string): boolean {\n  return BREW_LOCK_PATTERNS.some((pattern) => pattern.test(message));\n}\n\n/**\n * Check if an error message indicates a disabled package.\n */\nexport function isDisabledPackageMessage(message: string): boolean {\n  return DISABLED_PACKAGE_PATTERN.test(message);\n}\n\n/**\n * Parse disabled package details from an error message.\n */\nexport function parseDisabledPackageMessage(message: string): {\n  packageType: \"formula\" | \"cask\";\n  packageName: string;\n  reason?: string;\n  disabledDate?: string;\n} | null {\n  const match = message.match(DISABLED_PACKAGE_PATTERN);\n  if (!match) return null;\n\n  return {\n    packageType: match[1].toLowerCase() as \"formula\" | \"cask\",\n    packageName: match[2],\n    reason: match[3]?.trim(),\n    disabledDate: match[4],\n  };\n}\n\n/**\n * Check if an error message indicates a package conflict.\n */\nexport function isConflictMessage(message: string): boolean {\n  return CONFLICT_PATTERN.test(message);\n}\n\n/**\n * Check if an error message indicates a macOS version requirement.\n */\nexport function isMacOSVersionMessage(message: string): boolean {\n  return MACOS_VERSION_PATTERN.test(message);\n}\n\n/**\n * Safely cast an unknown error to an Error instance.\n * If the value is already an Error, returns it as-is.\n * Otherwise, wraps it in a new Error with the string representation.\n */\nexport function ensureError(err: unknown): Error {\n  return err instanceof Error ? err : new Error(String(err));\n}\n\n/**\n * Get a user-friendly error message from an error.\n */\nexport function getErrorMessage(error: unknown): string {\n  if (error instanceof BrewLockError) {\n    return \"Another brew process is already running. Please wait for it to finish and try again.\";\n  }\n\n  if (error instanceof DownloadTimeoutError) {\n    const pkg = error.packageName ? ` for \"${error.packageName}\"` : \"\";\n    const phase = error.phase ? ` during ${error.phase}` : \"\";\n    return `Download timed out${pkg}${phase}. Please try again.`;\n  }\n\n  if (error instanceof StaleProcessError) {\n    const pkg = error.packageName ? ` for \"${error.packageName}\"` : \"\";\n    const phase = error.lastPhase ? ` (stuck at ${error.lastPhase})` : \"\";\n    return `Process appears stuck${pkg}${phase}. The operation was cancelled.`;\n  }\n\n  if (error instanceof PackageDisabledError) {\n    const type = error.packageType ?? \"package\";\n    const typeName = type.charAt(0).toUpperCase() + type.slice(1);\n    let message = `${typeName} \"${error.packageName}\" has been discontinued`;\n    if (error.reason) {\n      message += `: ${error.reason}`;\n    }\n    if (error.disabledDate) {\n      message += ` (disabled on ${error.disabledDate})`;\n    }\n    return message;\n  }\n\n  if (error instanceof PackageConflictError) {\n    const conflicts = error.conflictsWith?.join(\", \") ?? \"another package\";\n    return `\"${error.packageName}\" conflicts with ${conflicts}. Please uninstall the conflicting package first.`;\n  }\n\n  if (error instanceof UnsupportedMacOSError) {\n    let message = `\"${error.packageName}\" requires a different macOS version`;\n    if (error.requiredVersion) {\n      message += ` (requires ${error.requiredVersion})`;\n    }\n    return message;\n  }\n\n  if (error instanceof NetworkError) {\n    if (error.statusCode) {\n      return `Network error (HTTP ${error.statusCode}): ${error.message}`;\n    }\n    return `Network error: ${error.message}`;\n  }\n\n  if (error instanceof BrewNotFoundError) {\n    return `Homebrew not found: ${error.message}`;\n  }\n\n  if (error instanceof PackageNotFoundError) {\n    const type = error.packageType ?? \"package\";\n    return `${type.charAt(0).toUpperCase() + type.slice(1)} not found: ${error.packageName ?? error.message}`;\n  }\n\n  if (error instanceof BrewCommandError) {\n    // Check for null exit code (process was killed/cancelled)\n    if (error.exitCode === undefined || error.exitCode === null) {\n      return \"Cancelled\";\n    }\n    // Check if the stderr contains a known error pattern for better messages\n    if (error.stderr) {\n      // Check for disabled package\n      const disabledInfo = parseDisabledPackageMessage(error.stderr);\n      if (disabledInfo) {\n        let message = `${disabledInfo.packageType.charAt(0).toUpperCase() + disabledInfo.packageType.slice(1)} \"${disabledInfo.packageName}\" has been discontinued`;\n        if (disabledInfo.reason) {\n          message += `: ${disabledInfo.reason}`;\n        }\n        if (disabledInfo.disabledDate) {\n          message += ` (disabled on ${disabledInfo.disabledDate})`;\n        }\n        return message;\n      }\n    }\n    return error.stderr ?? error.message;\n  }\n\n  if (error instanceof BrewError) {\n    return error.message;\n  }\n\n  if (error instanceof Error) {\n    // Handle abort errors with user-friendly message\n    if (error.name === \"AbortError\") {\n      return \"Cancelled\";\n    }\n\n    // Check for ExecError-like objects\n    const execError = error as { stderr?: string; stdout?: string };\n    if (execError.stderr) {\n      // Check for disabled package in raw stderr\n      const disabledInfo = parseDisabledPackageMessage(execError.stderr);\n      if (disabledInfo) {\n        let message = `${disabledInfo.packageType.charAt(0).toUpperCase() + disabledInfo.packageType.slice(1)} \"${disabledInfo.packageName}\" has been discontinued`;\n        if (disabledInfo.reason) {\n          message += `: ${disabledInfo.reason}`;\n        }\n        if (disabledInfo.disabledDate) {\n          message += ` (disabled on ${disabledInfo.disabledDate})`;\n        }\n        return message;\n      }\n      return execError.stderr;\n    }\n    return error.message;\n  }\n\n  return String(error);\n}\n", "/**\n * Cache utilities for the Brew extension.\n *\n * Provides functions for managing cached data and remote fetching.\n */\n\nimport { environment, showToast, Toast } from \"@raycast/api\";\nimport path from \"path\";\nimport fs from \"fs\";\nimport { rm, mkdir, readFile, writeFile } from \"fs/promises\";\nimport { stat } from \"fs/promises\";\nimport { Readable } from \"stream\";\nimport { ReadableStream } from \"stream/web\";\nimport { chain } from \"stream-chain\";\nimport { parser } from \"stream-json\";\nimport { filter } from \"stream-json/filters/Filter\";\nimport { streamArray } from \"stream-json/streamers/StreamArray\";\nimport { pipeline as streamPipeline } from \"stream/promises\";\nimport { DownloadProgressCallback, ChunkedCacheConfig, ChunkedCacheMeta, CacheIndex, IndexEntry } from \"./types\";\nimport { cacheLogger, fetchLogger } from \"./logger\";\nimport { NetworkError, ParseError, ensureError } from \"./errors\";\n\n/// Cache Paths\n\nexport const supportPath: string = (() => {\n  try {\n    fs.mkdirSync(environment.supportPath, { recursive: true });\n  } catch {\n    cacheLogger.warn(\"Failed to create supportPath\");\n  }\n  return environment.supportPath;\n})();\n\nexport const bundleIdentifier: string = (() => {\n  return (\n    environment.supportPath.split(path.sep).find((comp) => {\n      if (comp.startsWith(\"com.raycast\")) {\n        return true;\n      }\n      return false;\n    }) ?? \"com.raycast.macos\"\n  );\n})();\n\nexport function cachePath(name: string): string {\n  return path.join(supportPath, name);\n}\n\nconst CACHE_FILES = [\"formula.json\", \"cask.json\", \"installedv2.json\"];\n\n/**\n * Clear all cached data files (formulae, casks, installed packages).\n */\nexport async function clearCache(): Promise<void> {\n  try {\n    cacheLogger.log(\"Starting cache clear operation\");\n    await showToast(Toast.Style.Animated, \"Clearing downloaded casks and formulae...\");\n\n    // Check which files exist before clearing\n    const existingFiles: string[] = [];\n    const fileSizes: Record<string, number> = {};\n\n    for (const file of CACHE_FILES) {\n      const filePath = path.join(environment.supportPath, file);\n      try {\n        const stats = await stat(filePath);\n        existingFiles.push(file);\n        fileSizes[file] = stats.size;\n      } catch {\n        // File doesn't exist\n      }\n    }\n\n    if (existingFiles.length > 0) {\n      cacheLogger.log(\"Clearing cache files\", {\n        files: existingFiles,\n        sizes: fileSizes,\n        totalBytes: Object.values(fileSizes).reduce((a, b) => a + b, 0),\n      });\n    } else {\n      cacheLogger.log(\"No cache files to clear\");\n    }\n\n    await Promise.all([\n      // Clear legacy cache files\n      ...CACHE_FILES.map((file) =>\n        rm(path.join(environment.supportPath, file), { force: true }).catch(() => {\n          // Ignore errors for files that don't exist\n        }),\n      ),\n      // Clear chunked cache directories\n      rm(path.join(environment.supportPath, \"formula\"), { recursive: true, force: true }).catch(() => {}),\n      rm(path.join(environment.supportPath, \"cask\"), { recursive: true, force: true }).catch(() => {}),\n    ]);\n\n    cacheLogger.log(\"Cache clear completed\", {\n      filesCleared: existingFiles,\n      fileCount: existingFiles.length,\n    });\n\n    await showToast(Toast.Style.Success, \"Cache files cleared\");\n  } catch (err) {\n    const error = ensureError(err);\n    cacheLogger.error(\"Failed to clear cache\", { error: error.message });\n    await showToast(Toast.Style.Failure, \"Failed to clear cache\", error.message);\n  }\n}\n\n/// Remote Fetching\n\n// Top-level object keys which should be parsed from the raw JSON objects.\nconst valid_keys = [\n  \"name\",\n  \"tap\",\n  \"desc\",\n  \"homepage\",\n  \"versions\",\n  \"outdated\",\n  \"caveats\",\n  \"token\",\n  \"version\",\n  \"installed\",\n  \"auto_updates\",\n  \"depends_on\",\n  \"conflicts_with\",\n  \"license\",\n  \"aliases\",\n  \"dependencies\",\n  \"build_dependencies\",\n  \"installed\",\n  \"keg_only\",\n  \"linked_key\",\n  \"pinned\",\n];\n\n/**\n * Download remote data to cache file WITHOUT parsing into memory.\n * Use this when you only need the file on disk (e.g., for chunked cache building).\n * Returns the last-modified timestamp from the remote.\n */\nexport async function downloadRemoteToCache(\n  url: string,\n  cachePath: string,\n  onProgress?: DownloadProgressCallback,\n  signal?: AbortSignal,\n): Promise<number> {\n  // Check if cache is already up to date\n  let cacheInfo: fs.Stats | undefined;\n  let lastModified = 0;\n  try {\n    cacheInfo = await stat(cachePath);\n    const response = await fetch(url, { method: \"HEAD\", signal });\n    lastModified = Date.parse(response.headers.get(\"last-modified\") ?? \"\");\n  } catch (err) {\n    // Re-throw abort errors, ignore others (cache miss is normal on first run)\n    if (err instanceof Error && err.name === \"AbortError\") throw err;\n    cacheLogger.log(\"Cache miss for download\", { path: cachePath });\n  }\n\n  if (cacheInfo && cacheInfo.size > 0 && lastModified <= cacheInfo.mtimeMs) {\n    fetchLogger.log(\"Using cached file (up to date)\", {\n      url,\n      cacheAgeMs: Date.now() - cacheInfo.mtimeMs,\n    });\n    return lastModified || cacheInfo.mtimeMs;\n  }\n\n  // Need to download\n  const downloadStartTime = Date.now();\n  fetchLogger.log(\"Starting download (no parse)\", { url });\n\n  const response = await fetch(url, {\n    headers: {\n      \"Accept-Encoding\": \"identity\",\n    },\n    signal,\n  });\n\n  if (!response.ok || !response.body) {\n    throw new NetworkError(`HTTP ${response.status}: ${response.statusText}`, {\n      statusCode: response.status,\n      url,\n    });\n  }\n\n  const contentLength = response.headers.get(\"content-length\");\n  const totalBytes = contentLength ? parseInt(contentLength, 10) : 0;\n  let bytesDownloaded = 0;\n\n  onProgress?.({\n    url,\n    bytesDownloaded: 0,\n    totalBytes,\n    percent: 0,\n    complete: false,\n  });\n\n  const writeStream = fs.createWriteStream(cachePath);\n\n  try {\n    if (onProgress) {\n      let lastProgressUpdate = 0;\n      const PROGRESS_THROTTLE_MS = 100;\n\n      const progressStream = new TransformStream({\n        transform(chunk, controller) {\n          bytesDownloaded += chunk.length;\n          const now = Date.now();\n\n          const isComplete = totalBytes > 0 && bytesDownloaded >= totalBytes;\n          if (isComplete || now - lastProgressUpdate >= PROGRESS_THROTTLE_MS) {\n            const percent = totalBytes > 0 ? Math.round((bytesDownloaded / totalBytes) * 100) : -1;\n            lastProgressUpdate = now;\n\n            onProgress({\n              url,\n              bytesDownloaded,\n              totalBytes,\n              percent: Math.min(percent, 100),\n              complete: false,\n            });\n          }\n\n          controller.enqueue(chunk);\n        },\n      });\n\n      const progressBody = response.body.pipeThrough(progressStream);\n      await streamPipeline(Readable.fromWeb(progressBody as ReadableStream), writeStream);\n    } else {\n      await streamPipeline(Readable.fromWeb(response.body as ReadableStream), writeStream);\n    }\n  } catch (streamError) {\n    writeStream.destroy();\n    try {\n      fs.unlinkSync(cachePath);\n    } catch {\n      // Ignore cleanup errors\n    }\n    throw streamError;\n  }\n\n  onProgress?.({\n    url,\n    bytesDownloaded,\n    totalBytes,\n    percent: 100,\n    complete: true,\n  });\n\n  const downloadDurationMs = Date.now() - downloadStartTime;\n  cacheLogger.log(\"Downloaded to cache (no parse)\", {\n    path: cachePath,\n    url,\n    downloadDurationMs,\n    sizeBytes: totalBytes,\n  });\n\n  // Return the last-modified time\n  lastModified = Date.parse(response.headers.get(\"last-modified\") ?? \"\") || Date.now();\n  return lastModified;\n}\n\n/// Chunked Cache\n\n/** Number of items per chunk file */\nconst CHUNK_SIZE = 500;\n\n/** Current schema version for chunked cache */\nconst CHUNKED_CACHE_VERSION = 1;\n\n/**\n * Get configuration for chunked cache paths.\n */\nexport function getChunkedCacheConfig(type: \"formula\" | \"cask\"): ChunkedCacheConfig {\n  const baseDir = path.join(supportPath, type);\n  return {\n    baseDir,\n    indexPath: path.join(baseDir, \"index.json\"),\n    metaPath: path.join(baseDir, \"meta.json\"),\n    type,\n  };\n}\n\n/**\n * Get the path for a specific chunk file.\n */\nfunction getChunkPath(config: ChunkedCacheConfig, chunkNumber: number): string {\n  const paddedNumber = String(chunkNumber).padStart(4, \"0\");\n  return path.join(config.baseDir, `chunk-${paddedNumber}.json`);\n}\n\n/**\n * Check if chunked cache is valid (exists and not stale).\n */\nexport async function isChunkedCacheValid(\n  config: ChunkedCacheConfig,\n  remoteUrl: string,\n  signal?: AbortSignal,\n): Promise<boolean> {\n  try {\n    const metaContent = await readFile(config.metaPath, \"utf-8\");\n    const meta = JSON.parse(metaContent) as ChunkedCacheMeta;\n\n    // Check version compatibility\n    if (meta.version !== CHUNKED_CACHE_VERSION) {\n      cacheLogger.log(\"Chunked cache version mismatch\", {\n        type: config.type,\n        cacheVersion: meta.version,\n        currentVersion: CHUNKED_CACHE_VERSION,\n      });\n      return false;\n    }\n\n    // Check if remote has been updated\n    const response = await fetch(remoteUrl, { method: \"HEAD\", signal });\n    const lastModified = Date.parse(response.headers.get(\"last-modified\") ?? \"\");\n\n    if (lastModified > meta.lastModified) {\n      cacheLogger.log(\"Chunked cache outdated\", {\n        type: config.type,\n        cacheTime: meta.lastModified,\n        remoteTime: lastModified,\n      });\n      return false;\n    }\n\n    cacheLogger.log(\"Chunked cache valid\", {\n      type: config.type,\n      cacheAgeMs: Date.now() - meta.createdAt,\n      itemCount: meta.totalItems,\n    });\n    return true;\n  } catch (err) {\n    // Re-throw abort errors, ignore others (missing cache is normal on first run)\n    if (err instanceof Error && err.name === \"AbortError\") throw err;\n    cacheLogger.log(\"Chunked cache not found or invalid\", { type: config.type });\n    return false;\n  }\n}\n\n/** Type for index entry extractor function */\nexport type IndexExtractor<T> = (item: T, chunkNumber: number, indexInChunk: number) => IndexEntry;\n\n/**\n * Build chunked cache from source JSON file.\n * Streams through the source, writing chunks and building an index.\n */\nexport async function buildChunkedCache<T>(\n  sourcePath: string,\n  sourceUrl: string,\n  config: ChunkedCacheConfig,\n  extractIndex: IndexExtractor<T>,\n  onProgress?: DownloadProgressCallback,\n  signal?: AbortSignal,\n): Promise<void> {\n  // Check for abort before starting\n  if (signal?.aborted) {\n    const error = new Error(\"Aborted\");\n    error.name = \"AbortError\";\n    throw error;\n  }\n\n  const buildStartTime = Date.now();\n  cacheLogger.log(\"Building chunked cache\", { type: config.type, sourcePath });\n\n  // Reset and ensure directory exists\n  await rm(config.baseDir, { recursive: true, force: true }).catch(() => {});\n  await mkdir(config.baseDir, { recursive: true });\n\n  // Get last modified time from source file (will use this for cache validity)\n  let lastModified = Date.now();\n  try {\n    const response = await fetch(sourceUrl, { method: \"HEAD\", signal });\n    lastModified = Date.parse(response.headers.get(\"last-modified\") ?? \"\") || lastModified;\n  } catch (err) {\n    // Re-throw abort errors, ignore others (use current time)\n    if (err instanceof Error && err.name === \"AbortError\") throw err;\n  }\n\n  const keysRe = new RegExp(`\\\\b(${valid_keys.join(\"|\")})\\\\b`);\n\n  return new Promise<void>((resolve, reject) => {\n    let aborted = false;\n    const index: IndexEntry[] = [];\n    let currentChunk: T[] = [];\n    let chunkNumber = 0;\n    let totalItems = 0;\n\n    // Track progress\n    let lastProgressUpdate = 0;\n    const PROGRESS_THROTTLE_MS = 100;\n\n    const reportProgress = (complete: boolean) => {\n      if (aborted) return;\n      onProgress?.({\n        url: sourceUrl,\n        bytesDownloaded: 0,\n        totalBytes: 0,\n        percent: 100,\n        complete,\n        phase: \"processing\",\n        itemsProcessed: totalItems,\n        totalItems: complete ? totalItems : undefined,\n      });\n    };\n\n    // Pending write operations\n    const writePromises: Promise<void>[] = [];\n\n    const pipeline = chain([fs.createReadStream(sourcePath), parser(), filter({ filter: keysRe }), streamArray()]);\n\n    // Abort handler: destroy the pipeline when signal fires\n    const onAbort = () => {\n      aborted = true;\n      pipeline.destroy();\n    };\n    signal?.addEventListener(\"abort\", onAbort, { once: true });\n\n    pipeline.on(\"data\", (data) => {\n      if (data && typeof data === \"object\" && \"value\" in data) {\n        const item = data.value as T;\n        const indexInChunk = currentChunk.length;\n\n        // Build index entry\n        const entry = extractIndex(item, chunkNumber, indexInChunk);\n        index.push(entry);\n\n        // Add to current chunk\n        currentChunk.push(item);\n        totalItems++;\n\n        // Write chunk when full\n        if (currentChunk.length >= CHUNK_SIZE) {\n          // Capture current chunk for async write\n          const chunkToWrite = currentChunk;\n          const chunkNum = chunkNumber;\n          currentChunk = [];\n          chunkNumber++;\n\n          writePromises.push(\n            (async () => {\n              const chunkPath = getChunkPath(config, chunkNum);\n              await writeFile(chunkPath, JSON.stringify(chunkToWrite));\n            })(),\n          );\n        }\n\n        // Report progress (throttled)\n        const now = Date.now();\n        if (onProgress && now - lastProgressUpdate >= PROGRESS_THROTTLE_MS) {\n          lastProgressUpdate = now;\n          reportProgress(false);\n        }\n      }\n    });\n\n    pipeline.on(\"end\", async () => {\n      signal?.removeEventListener(\"abort\", onAbort);\n      try {\n        // Wait for any pending chunk writes\n        await Promise.all(writePromises);\n\n        // Write final partial chunk\n        if (currentChunk.length > 0) {\n          const chunkPath = getChunkPath(config, chunkNumber);\n          await writeFile(chunkPath, JSON.stringify(currentChunk));\n          chunkNumber++;\n        }\n\n        // Write index\n        await writeFile(config.indexPath, JSON.stringify(index));\n\n        // Write meta\n        const meta: ChunkedCacheMeta = {\n          version: CHUNKED_CACHE_VERSION,\n          sourceUrl,\n          lastModified,\n          createdAt: Date.now(),\n          totalItems,\n          chunkSize: CHUNK_SIZE,\n          chunkCount: chunkNumber,\n          type: config.type,\n        };\n        await writeFile(config.metaPath, JSON.stringify(meta));\n\n        const buildDurationMs = Date.now() - buildStartTime;\n        cacheLogger.log(\"Chunked cache built\", {\n          type: config.type,\n          totalItems,\n          chunkCount: chunkNumber,\n          buildDurationMs,\n        });\n\n        reportProgress(true);\n        resolve();\n      } catch (err) {\n        reject(err);\n      }\n    });\n\n    pipeline.on(\"error\", async (err) => {\n      signal?.removeEventListener(\"abort\", onAbort);\n\n      // Clean up partial cache\n      try {\n        await rm(config.baseDir, { recursive: true, force: true });\n      } catch {\n        // Ignore cleanup errors\n      }\n\n      // If aborted, reject with AbortError instead of ParseError\n      if (aborted) {\n        cacheLogger.log(\"Chunked cache build aborted\", { type: config.type });\n        const abortError = new Error(\"Aborted\");\n        abortError.name = \"AbortError\";\n        reject(abortError);\n        return;\n      }\n\n      cacheLogger.error(\"Failed to build chunked cache\", {\n        type: config.type,\n        error: err.message,\n      });\n\n      reject(\n        new ParseError(\"Failed to build chunked cache\", {\n          cause: err,\n        }),\n      );\n    });\n  });\n}\n\n/**\n * Load the index from chunked cache.\n */\nexport async function loadIndex(config: ChunkedCacheConfig): Promise<CacheIndex> {\n  const [indexContent, metaContent] = await Promise.all([\n    readFile(config.indexPath, \"utf-8\"),\n    readFile(config.metaPath, \"utf-8\"),\n  ]);\n\n  const entries = JSON.parse(indexContent) as IndexEntry[];\n  const meta = JSON.parse(metaContent) as ChunkedCacheMeta;\n\n  cacheLogger.log(\"Loaded chunked index\", {\n    type: config.type,\n    entryCount: entries.length,\n  });\n\n  return { entries, meta };\n}\n\n/**\n * Load specific chunks from chunked cache.\n * Returns a map of chunk number to items array.\n */\nexport async function loadChunks<T>(config: ChunkedCacheConfig, chunkNumbers: Set<number>): Promise<Map<number, T[]>> {\n  const chunks = new Map<number, T[]>();\n\n  if (chunkNumbers.size === 0) {\n    return chunks;\n  }\n\n  const loadPromises = Array.from(chunkNumbers).map(async (chunkNum) => {\n    const chunkPath = getChunkPath(config, chunkNum);\n    const content = await readFile(chunkPath, \"utf-8\");\n    const items = JSON.parse(content) as T[];\n    return { chunkNum, items };\n  });\n\n  const results = await Promise.all(loadPromises);\n  for (const { chunkNum, items } of results) {\n    chunks.set(chunkNum, items);\n  }\n\n  cacheLogger.log(\"Loaded chunks\", {\n    type: config.type,\n    chunkCount: chunks.size,\n    totalItems: Array.from(chunks.values()).reduce((sum, items) => sum + items.length, 0),\n  });\n\n  return chunks;\n}\n\n/**\n * Load specific items from chunked cache based on index entries.\n * Groups entries by chunk to minimize file reads.\n */\nexport async function loadItemsFromChunks<T>(config: ChunkedCacheConfig, entries: IndexEntry[]): Promise<T[]> {\n  if (entries.length === 0) {\n    return [];\n  }\n\n  // Determine which chunks we need\n  const neededChunks = new Set(entries.map((e) => e.c));\n\n  // Load those chunks\n  const chunks = await loadChunks<T>(config, neededChunks);\n\n  // Extract items in entry order\n  const items: T[] = [];\n  for (const entry of entries) {\n    const chunk = chunks.get(entry.c);\n    if (chunk && entry.i < chunk.length) {\n      items.push(chunk[entry.i]);\n    }\n  }\n\n  return items;\n}\n", "/**\n * Homebrew progress tracking utilities.\n *\n * Provides functions for executing brew commands with real-time progress updates.\n */\n\nimport { spawn } from \"child_process\";\nimport { brewExecutable } from \"./paths\";\nimport { execBrewEnv } from \"./commands\";\nimport { brewLogger } from \"../logger\";\nimport { BrewLockError, isBrewLockMessage, BrewCommandError, StaleProcessError } from \"../errors\";\nimport { ExecResult } from \"../types\";\n\n/// Configuration\n\n/**\n * Default timeout for stale process detection (5 minutes).\n * If no progress is made for this duration, the process is considered stuck.\n */\nexport const DEFAULT_STALE_TIMEOUT_MS = 5 * 60 * 1000;\n\n/**\n * Timeout for download phase specifically (10 minutes).\n * Downloads can take longer, especially for large packages like LLVM.\n */\nexport const DOWNLOAD_PHASE_TIMEOUT_MS = 10 * 60 * 1000;\n\n/// Progress Types\n\n/**\n * Phases of a brew operation.\n */\nexport type BrewPhase =\n  | \"starting\"\n  | \"downloading\"\n  | \"verifying\"\n  | \"extracting\"\n  | \"installing\"\n  | \"linking\"\n  | \"cleaning\"\n  | \"complete\"\n  | \"error\";\n\n/**\n * Progress information for a brew operation.\n */\nexport interface BrewProgress {\n  phase: BrewPhase;\n  message: string;\n  percentage?: number;\n  bytesDownloaded?: number;\n  totalBytes?: number;\n}\n\n/**\n * Callback for progress updates.\n */\nexport type ProgressCallback = (progress: BrewProgress) => void;\n\n/// Progress Parsing\n\n/**\n * Parse brew output to extract progress information.\n */\nexport function parseBrewOutput(line: string): BrewProgress | null {\n  const trimmedLine = line.trim();\n  if (!trimmedLine) return null;\n\n  // Strip the \"==>\" prefix from Homebrew output for cleaner UI messages\n  const cleanMessage = trimmedLine.replace(/^=+>\\s*/, \"\");\n\n  // Downloading phase\n  if (trimmedLine.includes(\"Downloading\")) {\n    return { phase: \"downloading\", message: cleanMessage };\n  }\n\n  // Download progress (e.g., \"######## 50.0%\")\n  const percentMatch = trimmedLine.match(/#+\\s*(\\d+\\.?\\d*)%/);\n  if (percentMatch) {\n    return {\n      phase: \"downloading\",\n      message: `Downloading... ${percentMatch[1]}%`,\n      percentage: parseFloat(percentMatch[1]),\n    };\n  }\n\n  // Verifying checksum\n  if (trimmedLine.includes(\"Verifying\") || trimmedLine.includes(\"checksum\")) {\n    return { phase: \"verifying\", message: cleanMessage };\n  }\n\n  // Extracting/Pouring\n  if (trimmedLine.includes(\"Pouring\") || trimmedLine.includes(\"Extracting\")) {\n    return { phase: \"extracting\", message: cleanMessage };\n  }\n\n  // Installing\n  if (trimmedLine.includes(\"Installing\") || trimmedLine.includes(\"==> Installing\")) {\n    return { phase: \"installing\", message: cleanMessage };\n  }\n\n  // Linking\n  if (trimmedLine.includes(\"Linking\") || trimmedLine.includes(\"==> Linking\")) {\n    return { phase: \"linking\", message: cleanMessage };\n  }\n\n  // Cleaning\n  if (trimmedLine.includes(\"Cleaning\") || trimmedLine.includes(\"Removing\")) {\n    return { phase: \"cleaning\", message: cleanMessage };\n  }\n\n  // Caveats or summary\n  if (trimmedLine.includes(\"==> Caveats\") || trimmedLine.includes(\"==> Summary\")) {\n    return { phase: \"complete\", message: cleanMessage };\n  }\n\n  // Generic progress message\n  if (trimmedLine.startsWith(\"==>\")) {\n    return { phase: \"installing\", message: cleanMessage };\n  }\n\n  return null;\n}\n\n/**\n * Format bytes to human-readable string.\n */\nexport function formatBytes(bytes: number): string {\n  if (bytes < 1024) return `${bytes} B`;\n  if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;\n  if (bytes < 1024 * 1024 * 1024) return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;\n  return `${(bytes / (1024 * 1024 * 1024)).toFixed(1)} GB`;\n}\n\n/**\n * Options for executing brew commands with progress tracking.\n */\nexport interface ExecBrewWithProgressOptions {\n  /** Callback for progress updates */\n  onProgress?: ProgressCallback;\n  /** AbortSignal for cancellation */\n  cancel?: AbortSignal;\n  /** Timeout for stale process detection (ms). Default: 5 minutes */\n  staleTimeoutMs?: number;\n  /** Package name for error context */\n  packageName?: string;\n  /** Enable detailed phase logging */\n  verboseLogging?: boolean;\n}\n\n/**\n * Execute a brew command with real-time progress updates and stale process detection.\n *\n * Features:\n * - Real-time progress parsing from stdout/stderr\n * - Stale process detection (kills process if no progress for timeout period)\n * - Detailed phase logging for debugging stuck operations\n * - Lock error detection and proper error handling\n */\nexport async function execBrewWithProgress(\n  cmd: string,\n  onProgress?: ProgressCallback,\n  cancel?: AbortSignal,\n  options?: Omit<ExecBrewWithProgressOptions, \"onProgress\" | \"cancel\">,\n): Promise<ExecResult> {\n  const env = await execBrewEnv();\n  const args = cmd.split(/\\s+/).filter(Boolean);\n  const staleTimeoutMs = options?.staleTimeoutMs ?? DEFAULT_STALE_TIMEOUT_MS;\n  const packageName = options?.packageName;\n  const verboseLogging = options?.verboseLogging ?? false;\n\n  brewLogger.log(\"Executing brew with progress\", { command: cmd, packageName, staleTimeoutMs });\n\n  return new Promise((resolve, reject) => {\n    const proc = spawn(brewExecutable(), args, {\n      env,\n      stdio: [\"ignore\", \"pipe\", \"pipe\"],\n    });\n\n    let stdout = \"\";\n    let stderr = \"\";\n    let lastProgressTime = Date.now();\n    let currentPhase: BrewPhase = \"starting\";\n    let staleCheckInterval: NodeJS.Timeout | null = null;\n    let isRejected = false;\n\n    // Helper to clean up and reject\n    const cleanup = () => {\n      if (staleCheckInterval) {\n        clearInterval(staleCheckInterval);\n        staleCheckInterval = null;\n      }\n    };\n\n    const rejectOnce = (error: Error) => {\n      if (isRejected) return;\n      isRejected = true;\n      cleanup();\n      proc.kill(\"SIGTERM\");\n      reject(error);\n    };\n\n    // Stale process detection - check every 30 seconds\n    staleCheckInterval = setInterval(() => {\n      const now = Date.now();\n      const staleDuration = now - lastProgressTime;\n\n      // Use longer timeout for download phase\n      const effectiveTimeout = currentPhase === \"downloading\" ? DOWNLOAD_PHASE_TIMEOUT_MS : staleTimeoutMs;\n\n      if (staleDuration > effectiveTimeout) {\n        brewLogger.warn(\"Stale process detected\", {\n          command: cmd,\n          packageName,\n          lastPhase: currentPhase,\n          staleDurationMs: staleDuration,\n          timeoutMs: effectiveTimeout,\n        });\n\n        rejectOnce(\n          new StaleProcessError(`Process appears stuck during ${currentPhase}`, {\n            packageName,\n            lastPhase: currentPhase,\n            staleDurationMs: staleDuration,\n          }),\n        );\n      } else if (verboseLogging) {\n        brewLogger.log(\"Stale check passed\", {\n          command: cmd,\n          phase: currentPhase,\n          timeSinceLastProgress: staleDuration,\n          timeout: effectiveTimeout,\n        });\n      }\n    }, 30000);\n\n    // Handle cancellation\n    if (cancel) {\n      cancel.addEventListener(\"abort\", () => {\n        if (isRejected) return;\n        isRejected = true;\n        cleanup();\n        proc.kill(\"SIGTERM\");\n        const error = new Error(\"Cancelled\");\n        error.name = \"AbortError\";\n        reject(error);\n      });\n    }\n\n    // Report starting\n    onProgress?.({ phase: \"starting\", message: `Running: brew ${cmd.trim()}` });\n\n    // Helper to process output and update progress\n    const processOutput = (text: string, source: \"stdout\" | \"stderr\") => {\n      lastProgressTime = Date.now();\n\n      const lines = text.split(\"\\n\");\n      for (const line of lines) {\n        const progress = parseBrewOutput(line);\n        if (progress) {\n          // Track phase transitions for detailed logging\n          if (progress.phase !== currentPhase) {\n            brewLogger.log(\"Phase transition\", {\n              command: cmd,\n              packageName,\n              from: currentPhase,\n              to: progress.phase,\n              message: progress.message,\n            });\n            currentPhase = progress.phase;\n          }\n          onProgress?.(progress);\n        } else if (verboseLogging && line.trim()) {\n          // Log unparsed output for debugging\n          brewLogger.log(`Unparsed ${source}`, { line: line.trim() });\n        }\n      }\n    };\n\n    proc.stdout?.on(\"data\", (data: Buffer) => {\n      const text = data.toString();\n      stdout += text;\n      processOutput(text, \"stdout\");\n    });\n\n    proc.stderr?.on(\"data\", (data: Buffer) => {\n      const text = data.toString();\n      stderr += text;\n\n      // Check for lock errors\n      if (isBrewLockMessage(text)) {\n        rejectOnce(\n          new BrewLockError(\"Another brew process is already running\", {\n            command: cmd,\n          }),\n        );\n        return;\n      }\n\n      // Parse stderr for progress too (brew outputs some progress to stderr)\n      processOutput(text, \"stderr\");\n    });\n\n    proc.on(\"close\", (code) => {\n      cleanup();\n      if (isRejected) return;\n\n      brewLogger.log(\"Command completed\", {\n        command: cmd,\n        packageName,\n        exitCode: code,\n        finalPhase: currentPhase,\n      });\n\n      if (code === 0) {\n        onProgress?.({ phase: \"complete\", message: \"Operation completed successfully\" });\n        resolve({ stdout, stderr });\n      } else {\n        onProgress?.({ phase: \"error\", message: `Command failed with exit code ${code}` });\n        reject(\n          new BrewCommandError(`brew ${cmd} failed with exit code ${code}`, {\n            command: cmd,\n            exitCode: code ?? undefined,\n            stderr,\n          }),\n        );\n      }\n    });\n\n    proc.on(\"error\", (err) => {\n      cleanup();\n      if (isRejected) return;\n      onProgress?.({ phase: \"error\", message: err.message });\n      reject(err);\n    });\n  });\n}\n", "/**\n * Homebrew data fetching utilities.\n *\n * Provides functions for fetching installed and outdated packages.\n *\n * Performance optimization: Uses a two-phase loading strategy:\n * 1. Fast initial load with `brew list --versions` (returns minimal data quickly)\n * 2. Background fetch with `brew info --json=v2 --installed` for full metadata\n */\n\nimport * as fs from \"fs/promises\";\nimport {\n  Cask,\n  Formula,\n  InstallableResults,\n  InstalledMap,\n  OutdatedResults,\n  DownloadProgressCallback,\n  ChunkedRemote,\n  CacheIndex,\n  IndexEntry,\n} from \"../types\";\nimport {\n  cachePath,\n  downloadRemoteToCache,\n  getChunkedCacheConfig,\n  isChunkedCacheValid,\n  buildChunkedCache,\n  loadIndex,\n  loadItemsFromChunks,\n  IndexExtractor,\n} from \"../cache\";\nimport { brewPath } from \"./paths\";\nimport { execBrew } from \"./commands\";\nimport { brewLogger, cacheLogger } from \"../logger\";\n\n/// Cache Paths\n\nconst installedCachePath = cachePath(\"installedv2.json\");\nconst formulaCachePath = cachePath(\"formula.json\");\nconst caskCachePath = cachePath(\"cask.json\");\n\n/// Remote URLs\n\nconst formulaURL = \"https://formulae.brew.sh/api/formula.json\";\nconst caskURL = \"https://formulae.brew.sh/api/cask.json\";\n\nconst formulaRemote: ChunkedRemote<Formula> = {\n  url: formulaURL,\n  cachePath: formulaCachePath,\n  chunkedConfig: getChunkedCacheConfig(\"formula\"),\n};\n\nconst caskRemote: ChunkedRemote<Cask> = {\n  url: caskURL,\n  cachePath: caskCachePath,\n  chunkedConfig: getChunkedCacheConfig(\"cask\"),\n};\n\n/** Extract index entry from a Formula */\nconst extractFormulaIndex: IndexExtractor<Formula> = (item, chunkNumber, indexInChunk): IndexEntry => {\n  return {\n    id: item.name,\n    n: item.name.toLowerCase(),\n    d: item.desc?.toLowerCase().slice(0, 100),\n    a: item.aliases?.length > 0 ? item.aliases.map((a) => a.toLowerCase()) : undefined,\n    c: chunkNumber,\n    i: indexInChunk,\n  };\n};\n\n/** Extract index entry from a Cask */\nconst extractCaskIndex: IndexExtractor<Cask> = (item, chunkNumber, indexInChunk): IndexEntry => {\n  return {\n    id: item.token,\n    n: item.token.toLowerCase(),\n    d: item.desc?.toLowerCase().slice(0, 100),\n    a: item.name?.length > 0 ? item.name.map((n) => n.toLowerCase()) : undefined,\n    c: chunkNumber,\n    i: indexInChunk,\n  };\n};\n\n/**\n * Check if the search cache files exist (formula.json and cask.json).\n * Used to determine if this is a cold start (no cache) or warm start (cache exists).\n */\nexport async function hasSearchCache(): Promise<boolean> {\n  try {\n    const [formulaStats, caskStats] = await Promise.all([fs.stat(formulaCachePath), fs.stat(caskCachePath)]);\n    // Both files must exist and have content\n    return formulaStats.size > 0 && caskStats.size > 0;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Minimal installed package info parsed from `brew list --versions`.\n * This is much faster than `brew info --json=v2 --installed`.\n */\ninterface InstalledListItem {\n  name: string;\n  version: string;\n  installed_on_request: boolean;\n}\n\n/**\n * Parse `brew list --versions` output into InstalledListItem array.\n * Format: \"package_name version1 version2 ...\" (one per line)\n */\nfunction parseListVersionsOutput(output: string): InstalledListItem[] {\n  const items: InstalledListItem[] = [];\n  const lines = output\n    .trim()\n    .split(\"\\n\")\n    .filter((line) => line.length > 0);\n\n  for (const line of lines) {\n    const parts = line.split(/\\s+/);\n    if (parts.length >= 2) {\n      const name = parts[0];\n      // Use the first (most recent) version\n      const version = parts[1];\n      items.push({\n        name,\n        version,\n        // We don't know this from list output, default to true\n        installed_on_request: true,\n      });\n    }\n  }\n\n  return items;\n}\n\n/**\n * Fetch a fast list of installed packages (names and versions only).\n * Uses `brew list --versions` which is significantly faster than `brew info --json=v2 --installed`.\n *\n * @returns Minimal installed package data for quick initial display\n */\nexport async function brewFetchInstalledFast(cancel?: AbortSignal): Promise<InstalledMap | undefined> {\n  const startTime = Date.now();\n\n  try {\n    // Try to read from cache first\n    const cacheBuffer = await fs.readFile(installedCachePath);\n    const cached = JSON.parse(cacheBuffer.toString()) as InstallableResults;\n    const mapped = brewMapInstalled(cached);\n    const duration = Date.now() - startTime;\n\n    cacheLogger.log(\"Fast load from cache\", {\n      formulaeCount: mapped?.formulae.size ?? 0,\n      casksCount: mapped?.casks.size ?? 0,\n      durationMs: duration,\n    });\n\n    return mapped;\n  } catch {\n    // Cache miss - fall back to fast list command\n    const listStartTime = Date.now();\n\n    try {\n      // brew list --versions is fast and gives us name + version\n      // Note: --versions output is \"name version1 version2 ...\" per line\n      const [formulaeOutput, casksOutput] = await Promise.all([\n        execBrew(`list --formula --versions`, cancel ? { signal: cancel } : undefined),\n        execBrew(`list --cask --versions`, cancel ? { signal: cancel } : undefined),\n      ]);\n\n      const formulaeList = parseListVersionsOutput(formulaeOutput.stdout);\n      const casksList = parseListVersionsOutput(casksOutput.stdout);\n\n      // Create minimal Formula/Cask objects for display\n      const formulae = new Map<string, Formula>();\n      for (const item of formulaeList) {\n        formulae.set(item.name, createMinimalFormula(item));\n      }\n\n      const casks = new Map<string, Cask>();\n      for (const item of casksList) {\n        casks.set(item.name, createMinimalCask(item));\n      }\n\n      const duration = Date.now() - listStartTime;\n      brewLogger.log(\"Fast list fetched\", {\n        formulaeCount: formulae.size,\n        casksCount: casks.size,\n        durationMs: duration,\n      });\n\n      return { formulae, casks };\n    } catch (err) {\n      brewLogger.error(\"Fast list fetch failed\", { error: err });\n      return undefined;\n    }\n  }\n}\n\n/**\n * Create a minimal Formula object from list data.\n */\nfunction createMinimalFormula(item: InstalledListItem): Formula {\n  return {\n    name: item.name,\n    tap: \"\",\n    homepage: \"\",\n    versions: { stable: item.version, bottle: false },\n    outdated: false,\n    license: null,\n    aliases: [],\n    dependencies: [],\n    build_dependencies: [],\n    installed: [\n      {\n        version: item.version,\n        installed_as_dependency: !item.installed_on_request,\n        installed_on_request: item.installed_on_request,\n      },\n    ],\n    keg_only: false,\n    linked_key: \"\",\n    pinned: false,\n  };\n}\n\n/**\n * Create a minimal Cask object from list data.\n */\nfunction createMinimalCask(item: InstalledListItem): Cask {\n  return {\n    token: item.name,\n    name: [item.name],\n    tap: \"\",\n    homepage: \"\",\n    version: item.version,\n    versions: { stable: item.version, bottle: false },\n    outdated: false,\n    installed: item.version,\n    auto_updates: false,\n    depends_on: {},\n  };\n}\n\n/**\n * Fetch all installed packages with full metadata.\n */\nexport async function brewFetchInstalled(useCache: boolean, cancel?: AbortSignal): Promise<InstalledMap | undefined> {\n  const startTime = Date.now();\n  const results = await brewFetchInstallableResults(useCache, cancel);\n  const mapped = brewMapInstalled(results);\n  const duration = Date.now() - startTime;\n\n  if (mapped) {\n    brewLogger.log(\"Installed packages fetched\", {\n      formulaeCount: mapped.formulae.size,\n      casksCount: mapped.casks.size,\n      totalCount: mapped.formulae.size + mapped.casks.size,\n      durationMs: duration,\n      fromCache: useCache,\n    });\n  }\n\n  return mapped;\n}\n\nasync function brewFetchInstallableResults(\n  useCache: boolean,\n  cancel?: AbortSignal,\n): Promise<InstallableResults | undefined> {\n  async function installed(): Promise<string> {\n    return (await execBrew(`info --json=v2 --installed`, cancel ? { signal: cancel } : undefined)).stdout;\n  }\n\n  if (!useCache) {\n    return JSON.parse(await installed());\n  }\n\n  async function updateCache(): Promise<InstallableResults> {\n    const startTime = Date.now();\n    const info = await installed();\n    const parsed = JSON.parse(info) as InstallableResults;\n    const duration = Date.now() - startTime;\n\n    try {\n      await fs.writeFile(installedCachePath, info);\n      const responseSizeBytes = Buffer.byteLength(info, \"utf8\");\n      const responseSizeKb = (responseSizeBytes / 1024).toFixed(2);\n\n      cacheLogger.log(\"Updated installed cache\", {\n        path: installedCachePath,\n        formulaeCount: parsed.formulae.length,\n        casksCount: parsed.casks.length,\n        totalCount: parsed.formulae.length + parsed.casks.length,\n        durationMs: duration,\n        responseSizeBytes,\n        responseSizeKb: `${responseSizeKb} KB`,\n      });\n    } catch (err) {\n      cacheLogger.error(\"Failed to write installed cache\", {\n        path: installedCachePath,\n        formulaeCount: parsed.formulae.length,\n        casksCount: parsed.casks.length,\n        error: err,\n      });\n    }\n    return parsed;\n  }\n\n  async function mtimeMs(path: string): Promise<number> {\n    return (await fs.stat(path)).mtimeMs;\n  }\n\n  async function readCache(): Promise<InstallableResults> {\n    const cacheTime = await mtimeMs(installedCachePath);\n    // 'var/homebrew/locks' is updated after installed keg_only or linked formula.\n    const locksTime = await mtimeMs(brewPath(\"var/homebrew/locks\"));\n    // Casks\n    const caskroomTime = await mtimeMs(brewPath(\"Caskroom\"));\n\n    // 'var/homebrew/pinned' is updated after pin/unpin actions (but does not exist if there are no pinned formula).\n    let pinnedTime;\n    try {\n      pinnedTime = await mtimeMs(brewPath(\"var/homebrew/pinned\"));\n    } catch {\n      pinnedTime = 0;\n    }\n    // Because '/var/homebrew/pinned can be removed, we need to also check the parent directory'\n    const homebrewTime = await mtimeMs(brewPath(\"var/homebrew\"));\n\n    if (homebrewTime < cacheTime && caskroomTime < cacheTime && locksTime < cacheTime && pinnedTime < cacheTime) {\n      const cacheBuffer = await fs.readFile(installedCachePath);\n      const cached = JSON.parse(cacheBuffer.toString()) as InstallableResults;\n      cacheLogger.log(\"Using cached installed data\", {\n        path: installedCachePath,\n        formulaeCount: cached.formulae.length,\n        casksCount: cached.casks.length,\n        totalCount: cached.formulae.length + cached.casks.length,\n        cacheAgeMs: Date.now() - cacheTime,\n      });\n      return cached;\n    } else {\n      cacheLogger.log(\"Cache invalidated, refreshing\", {\n        reason: \"brew state changed\",\n        homebrewTime,\n        caskroomTime,\n        locksTime,\n        pinnedTime,\n        cacheTime,\n      });\n      return await updateCache();\n    }\n  }\n\n  try {\n    return await readCache();\n  } catch {\n    return await updateCache();\n  }\n}\n\nfunction brewMapInstalled(installed?: InstallableResults): InstalledMap | undefined {\n  if (!installed) {\n    return undefined;\n  }\n\n  const formulae = new Map<string, Formula>();\n  for (const formula of installed.formulae) {\n    formulae.set(formula.name, formula);\n  }\n\n  const casks = new Map<string, Cask>();\n  for (const cask of installed.casks) {\n    casks.set(cask.token, cask);\n  }\n\n  return { formulae: formulae, casks: casks };\n}\n\n/**\n * Fetch outdated packages.\n *\n * @param greedy - Include auto-updating casks\n * @param cancel - AbortController for cancellation\n * @param skipUpdate - Skip brew update (use cached index). Faster but may miss recent updates.\n */\nexport async function brewFetchOutdated(\n  greedy: boolean,\n  cancel?: AbortSignal,\n  skipUpdate = false,\n): Promise<OutdatedResults> {\n  brewLogger.log(\"Fetching outdated packages\", { greedy, skipUpdate });\n  let cmd = `outdated --json=v2`;\n  if (greedy) {\n    cmd += \" --greedy\"; // include auto_update casks\n  }\n  // 'outdated' is only reliable after performing a 'brew update'\n  // skipUpdate allows showing stale data quickly, then refreshing\n  if (!skipUpdate) {\n    await brewUpdate(cancel);\n  }\n  const output = await execBrew(cmd, cancel ? { signal: cancel } : undefined);\n  const results = JSON.parse(output.stdout) as OutdatedResults;\n  brewLogger.log(\"Outdated packages fetched\", {\n    formulaeCount: results.formulae.length,\n    casksCount: results.casks.length,\n    skipUpdate,\n  });\n  return results;\n}\n\n/**\n * Run brew update.\n */\nexport async function brewUpdate(cancel?: AbortSignal): Promise<void> {\n  brewLogger.log(\"Running brew update\");\n  await execBrew(`update`, cancel ? { signal: cancel } : undefined);\n  brewLogger.log(\"Brew update completed\");\n}\n\n/// Chunked Cache Functions\n\n// Mutex to prevent concurrent chunked cache builds\nlet formulaeChunkedBuildInProgress: Promise<void> | null = null;\nlet casksChunkedBuildInProgress: Promise<void> | null = null;\n\n/**\n * Ensure chunked cache exists and is valid.\n * Downloads source JSON to disk (without parsing) and builds chunks.\n */\nasync function ensureChunkedCache<T>(\n  remote: ChunkedRemote<T>,\n  extractIndex: IndexExtractor<T>,\n  onProgress?: DownloadProgressCallback,\n  signal?: AbortSignal,\n): Promise<void> {\n  const isValid = await isChunkedCacheValid(remote.chunkedConfig, remote.url, signal);\n  if (isValid) {\n    return;\n  }\n\n  // Check if stale cache exists (for fallback on failure)\n  let hasStaleCacheIndex = false;\n  try {\n    await fs.stat(remote.chunkedConfig.indexPath);\n    await fs.stat(remote.chunkedConfig.metaPath);\n    hasStaleCacheIndex = true;\n  } catch {\n    // No stale cache available\n  }\n\n  try {\n    // Need to rebuild - download source JSON to disk WITHOUT parsing into memory\n    // This is critical to avoid heap exhaustion on initial load\n    brewLogger.log(\"Building chunked cache\", { type: remote.chunkedConfig.type });\n\n    // Download to disk only (no parsing)\n    await downloadRemoteToCache(remote.url, remote.cachePath, onProgress, signal);\n\n    // Now build the chunked cache from the downloaded file\n    // This streams through the file and writes chunks incrementally\n    await buildChunkedCache(remote.cachePath, remote.url, remote.chunkedConfig, extractIndex, onProgress, signal);\n  } catch (err) {\n    // Always re-throw abort errors - the caller handles these\n    if (err instanceof Error && err.name === \"AbortError\") throw err;\n\n    // For other errors, fall back to stale cache if available\n    if (hasStaleCacheIndex) {\n      brewLogger.warn(\"Chunked cache rebuild failed, using stale cache\", {\n        type: remote.chunkedConfig.type,\n        error: err instanceof Error ? err.message : String(err),\n      });\n      return;\n    }\n\n    // No stale cache to fall back to\n    throw err;\n  }\n}\n\n/**\n * Fetch the chunked index for formulae.\n * Builds chunked cache if it doesn't exist or is stale.\n */\nexport async function fetchFormulaIndex(\n  onProgress?: DownloadProgressCallback,\n  signal?: AbortSignal,\n): Promise<CacheIndex> {\n  // Check if already cached in memory\n  if (formulaRemote.index) {\n    return formulaRemote.index;\n  }\n\n  // Check if fetch is already in progress (deduplication)\n  if (formulaRemote.indexFetch) {\n    // Don't pass our signal to the existing build - just await it\n    try {\n      const result = await formulaRemote.indexFetch;\n      // Check abort after awaiting another caller's build\n      if (signal?.aborted) {\n        const error = new Error(\"Aborted\");\n        error.name = \"AbortError\";\n        throw error;\n      }\n      return result;\n    } catch (err) {\n      // If the existing build was aborted but OUR signal is still active, retry\n      if (err instanceof Error && err.name === \"AbortError\" && !signal?.aborted) {\n        return fetchFormulaIndex(onProgress, signal);\n      }\n      throw err;\n    }\n  }\n\n  // Start fetch with deduplication\n  formulaRemote.indexFetch = (async () => {\n    // Use mutex to prevent concurrent builds\n    if (formulaeChunkedBuildInProgress) {\n      brewLogger.log(\"Waiting for existing formula chunked cache build\");\n      await formulaeChunkedBuildInProgress;\n    } else {\n      formulaeChunkedBuildInProgress = ensureChunkedCache(formulaRemote, extractFormulaIndex, onProgress, signal);\n      try {\n        await formulaeChunkedBuildInProgress;\n      } finally {\n        formulaeChunkedBuildInProgress = null;\n      }\n    }\n\n    // Load index\n    const index = await loadIndex(formulaRemote.chunkedConfig);\n    formulaRemote.index = index;\n    return index;\n  })();\n\n  try {\n    return await formulaRemote.indexFetch;\n  } finally {\n    formulaRemote.indexFetch = undefined;\n  }\n}\n\n/**\n * Fetch the chunked index for casks.\n * Builds chunked cache if it doesn't exist or is stale.\n */\nexport async function fetchCaskIndex(onProgress?: DownloadProgressCallback, signal?: AbortSignal): Promise<CacheIndex> {\n  // Check if already cached in memory\n  if (caskRemote.index) {\n    return caskRemote.index;\n  }\n\n  // Check if fetch is already in progress (deduplication)\n  if (caskRemote.indexFetch) {\n    // Don't pass our signal to the existing build - just await it\n    try {\n      const result = await caskRemote.indexFetch;\n      // Check abort after awaiting another caller's build\n      if (signal?.aborted) {\n        const error = new Error(\"Aborted\");\n        error.name = \"AbortError\";\n        throw error;\n      }\n      return result;\n    } catch (err) {\n      // If the existing build was aborted but OUR signal is still active, retry\n      if (err instanceof Error && err.name === \"AbortError\" && !signal?.aborted) {\n        return fetchCaskIndex(onProgress, signal);\n      }\n      throw err;\n    }\n  }\n\n  // Start fetch with deduplication\n  caskRemote.indexFetch = (async () => {\n    // Use mutex to prevent concurrent builds\n    if (casksChunkedBuildInProgress) {\n      brewLogger.log(\"Waiting for existing cask chunked cache build\");\n      await casksChunkedBuildInProgress;\n    } else {\n      casksChunkedBuildInProgress = ensureChunkedCache(caskRemote, extractCaskIndex, onProgress, signal);\n      try {\n        await casksChunkedBuildInProgress;\n      } finally {\n        casksChunkedBuildInProgress = null;\n      }\n    }\n\n    // Load index\n    const index = await loadIndex(caskRemote.chunkedConfig);\n    caskRemote.index = index;\n    return index;\n  })();\n\n  try {\n    return await caskRemote.indexFetch;\n  } finally {\n    caskRemote.indexFetch = undefined;\n  }\n}\n\n/**\n * Fetch specific formulae by their index entries.\n * Only loads the chunks containing the requested items.\n */\nexport async function fetchFormulaItems(entries: IndexEntry[]): Promise<Formula[]> {\n  return loadItemsFromChunks<Formula>(formulaRemote.chunkedConfig, entries);\n}\n\n/**\n * Fetch specific casks by their index entries.\n * Only loads the chunks containing the requested items.\n */\nexport async function fetchCaskItems(entries: IndexEntry[]): Promise<Cask[]> {\n  return loadItemsFromChunks<Cask>(caskRemote.chunkedConfig, entries);\n}\n\n/**\n * Fetch info for a single formula by name.\n * Much faster than fetching all installed packages.\n */\nexport async function brewFetchFormulaInfo(name: string, cancel?: AbortSignal): Promise<Formula | undefined> {\n  const startTime = Date.now();\n  brewLogger.log(\"Fetching formula info\", { name });\n\n  try {\n    const output = await execBrew(`info --json=v2 ${name}`, cancel ? { signal: cancel } : undefined);\n    const results = JSON.parse(output.stdout) as InstallableResults;\n    const duration = Date.now() - startTime;\n\n    if (results.formulae.length > 0) {\n      brewLogger.log(\"Formula info fetched\", { name, durationMs: duration });\n      return results.formulae[0];\n    }\n\n    brewLogger.warn(\"Formula not found\", { name, durationMs: duration });\n    return undefined;\n  } catch (err) {\n    brewLogger.error(\"Failed to fetch formula info\", { name, error: err });\n    return undefined;\n  }\n}\n\n/**\n * Fetch info for a single cask by token.\n * Much faster than fetching all installed packages.\n */\nexport async function brewFetchCaskInfo(token: string, cancel?: AbortSignal): Promise<Cask | undefined> {\n  const startTime = Date.now();\n  brewLogger.log(\"Fetching cask info\", { token });\n\n  try {\n    const output = await execBrew(`info --json=v2 ${token}`, cancel ? { signal: cancel } : undefined);\n    const results = JSON.parse(output.stdout) as InstallableResults;\n    const duration = Date.now() - startTime;\n\n    if (results.casks.length > 0) {\n      brewLogger.log(\"Cask info fetched\", { token, durationMs: duration });\n      return results.casks[0];\n    }\n\n    brewLogger.warn(\"Cask not found\", { token, durationMs: duration });\n    return undefined;\n  } catch (err) {\n    brewLogger.error(\"Failed to fetch cask info\", { token, error: err });\n    return undefined;\n  }\n}\n", "/**\n * Homebrew action utilities.\n *\n * Provides functions for installing, uninstalling, and upgrading packages.\n */\n\nimport { Cask, Formula, Nameable, OutdatedFormula } from \"../types\";\nimport { actionsLogger } from \"../logger\";\nimport { preferences } from \"../preferences\";\nimport { execBrew } from \"./commands\";\nimport { execBrewWithProgress, ProgressCallback } from \"./progress\";\nimport { brewIdentifier, brewCaskOption, isCask } from \"./helpers\";\nimport { ExecError } from \"../types\";\n\n/**\n * Install a package.\n */\nexport async function brewInstall(installable: Cask | Formula, cancel?: AbortSignal): Promise<void> {\n  const identifier = brewIdentifier(installable);\n  const isCaskType = isCask(installable);\n  actionsLogger.log(\"Installing package\", {\n    identifier,\n    type: isCaskType ? \"cask\" : \"formula\",\n  });\n  await execBrew(`install ${brewCaskOption(installable)} ${identifier}`, cancel ? { signal: cancel } : undefined);\n  if (isCaskType) {\n    (installable as Cask).installed = (installable as Cask).version;\n  } else {\n    installable.installed = [\n      { version: installable.versions.stable, installed_as_dependency: false, installed_on_request: true },\n    ];\n  }\n  actionsLogger.log(\"Package installed successfully\", { identifier });\n}\n\n/**\n * Install a package with real-time progress updates.\n */\nexport async function brewInstallWithProgress(\n  installable: Cask | Formula,\n  onProgress?: ProgressCallback,\n  cancel?: AbortSignal,\n): Promise<void> {\n  const identifier = brewIdentifier(installable);\n  const isCaskType = isCask(installable);\n  actionsLogger.log(\"Installing package with progress\", {\n    identifier,\n    type: isCaskType ? \"cask\" : \"formula\",\n  });\n  await execBrewWithProgress(`install ${brewCaskOption(installable)} ${identifier}`, onProgress, cancel);\n  if (isCaskType) {\n    (installable as Cask).installed = (installable as Cask).version;\n  } else {\n    installable.installed = [\n      { version: installable.versions.stable, installed_as_dependency: false, installed_on_request: true },\n    ];\n  }\n  actionsLogger.log(\"Package installed successfully\", { identifier });\n}\n\n/**\n * Uninstall a package.\n */\nexport async function brewUninstall(installable: Cask | Nameable, cancel?: AbortSignal): Promise<void> {\n  const identifier = brewIdentifier(installable);\n  actionsLogger.log(\"Uninstalling package\", {\n    identifier,\n    type: isCask(installable) ? \"cask\" : \"formula\",\n    zap: preferences.zapCask,\n  });\n  await execBrew(`rm ${brewCaskOption(installable, true)} ${identifier}`, cancel ? { signal: cancel } : undefined);\n  actionsLogger.log(\"Package uninstalled successfully\", { identifier });\n}\n\n/**\n * Upgrade a package.\n */\nexport async function brewUpgrade(upgradable: Cask | Nameable, cancel?: AbortSignal): Promise<void> {\n  const identifier = brewIdentifier(upgradable);\n  actionsLogger.log(\"Upgrading package\", {\n    identifier,\n    type: isCask(upgradable) ? \"cask\" : \"formula\",\n  });\n  await execBrew(`upgrade ${brewCaskOption(upgradable)} ${identifier}`, cancel ? { signal: cancel } : undefined);\n  actionsLogger.log(\"Package upgraded successfully\", { identifier });\n}\n\n/**\n * Upgrade a package with real-time progress updates.\n */\nexport async function brewUpgradeSingleWithProgress(\n  upgradable: Cask | Nameable,\n  onProgress?: ProgressCallback,\n  cancel?: AbortSignal,\n): Promise<void> {\n  const identifier = brewIdentifier(upgradable);\n  actionsLogger.log(\"Upgrading package with progress\", {\n    identifier,\n    type: isCask(upgradable) ? \"cask\" : \"formula\",\n  });\n  await execBrewWithProgress(`upgrade ${brewCaskOption(upgradable)} ${identifier}`, onProgress, cancel);\n  actionsLogger.log(\"Package upgraded successfully\", { identifier });\n}\n\n/**\n * Upgrade all packages.\n */\nexport async function brewUpgradeAll(greedy: boolean, cancel?: AbortSignal): Promise<void> {\n  actionsLogger.log(\"Upgrading all packages\", { greedy });\n  let cmd = `upgrade`;\n  if (greedy) {\n    cmd += \" --greedy\";\n  }\n  await execBrew(cmd, cancel ? { signal: cancel } : undefined);\n  actionsLogger.log(\"All packages upgraded successfully\");\n}\n\n/**\n * Run cleanup to remove old versions.\n */\nexport async function brewCleanup(withoutThreshold: boolean, cancel?: AbortSignal): Promise<void> {\n  actionsLogger.log(\"Running cleanup\", { pruneAll: withoutThreshold });\n  let cmd = `cleanup`;\n  if (withoutThreshold) {\n    cmd += \" --prune=all\";\n  }\n  await execBrew(cmd, cancel ? { signal: cancel } : undefined);\n  actionsLogger.log(\"Cleanup completed successfully\");\n}\n\n/**\n * Pin a formula to prevent upgrades.\n */\nexport async function brewPinFormula(formula: Formula | OutdatedFormula): Promise<void> {\n  actionsLogger.log(\"Pinning formula\", { name: formula.name });\n  await execBrew(`pin ${formula.name}`);\n  formula.pinned = true;\n  actionsLogger.log(\"Formula pinned successfully\", { name: formula.name });\n}\n\n/**\n * Unpin a formula to allow upgrades.\n */\nexport async function brewUnpinFormula(formula: Formula | OutdatedFormula): Promise<void> {\n  actionsLogger.log(\"Unpinning formula\", { name: formula.name });\n  await execBrew(`unpin ${formula.name}`);\n  formula.pinned = false;\n  actionsLogger.log(\"Formula unpinned successfully\", { name: formula.name });\n}\n\n/**\n * Run brew doctor to check for issues.\n */\nexport async function brewDoctor(): Promise<string> {\n  try {\n    const output = await execBrew(`doctor`);\n    return output.stdout;\n  } catch (err) {\n    const execErr = err as ExecError;\n    if (execErr?.code === 1) {\n      return execErr.stderr;\n    } else {\n      return `${err}`;\n    }\n  }\n}\n", "/**\n * Toast utilities for the Brew extension.\n *\n * Provides functions for displaying toast notifications.\n */\n\nimport { Clipboard, Toast, showHUD } from \"@raycast/api\";\nimport { ExecError } from \"./types\";\nimport { uiLogger } from \"./logger\";\nimport { isRecoverableError, getErrorMessage, isBrewLockError } from \"./errors\";\nimport { preferences } from \"./preferences\";\n\n/// Toast Types\n\ninterface ActionToastOptions {\n  title: string;\n  message?: string;\n  cancelable: boolean;\n}\n\n/**\n * Result from showActionToast that allows updating progress and showing final HUD.\n */\nexport interface ActionToastHandle {\n  /** AbortController for cancellation (if cancelable) */\n  abort?: AbortController;\n  /** Update the toast message to show progress */\n  updateMessage: (message: string) => void;\n  /** Update the toast title */\n  updateTitle: (title: string) => void;\n  /** Show success HUD (persists after Raycast closes) */\n  showSuccessHUD: (message: string) => Promise<void>;\n  /** Show failure HUD (persists after Raycast closes) */\n  showFailureHUD: (message: string) => Promise<void>;\n  /** Hide the toast */\n  hide: () => void;\n}\n\n/**\n * Show an animated toast with optional cancel action.\n * Returns a handle for updating progress and showing final HUD notifications.\n */\nexport function showActionToast(actionOptions: ActionToastOptions): ActionToastHandle {\n  const options: Toast.Options = {\n    style: Toast.Style.Animated,\n    title: actionOptions.title,\n    message: actionOptions.message,\n  };\n\n  let controller: AbortController | undefined;\n\n  if (actionOptions.cancelable) {\n    controller = new AbortController();\n    options.primaryAction = {\n      title: \"Cancel\",\n      onAction: () => {\n        controller?.abort();\n        toast.hide();\n      },\n    };\n  }\n\n  const toast = new Toast(options);\n  toast.show();\n\n  return {\n    abort: controller,\n    updateMessage: (message: string) => {\n      toast.message = message;\n    },\n    updateTitle: (title: string) => {\n      toast.title = title;\n    },\n    showSuccessHUD: async (message: string) => {\n      if (preferences.closeAfterAction) {\n        toast.hide();\n        // Close window and show HUD\n        await showHUD(`\u2705 ${message}`);\n      } else {\n        // Keep window open - update existing toast in-place to avoid stale detail HUD\n        toast.style = Toast.Style.Success;\n        toast.title = message;\n        toast.message = undefined;\n        toast.primaryAction = undefined;\n      }\n    },\n    showFailureHUD: async (message: string) => {\n      if (preferences.closeAfterAction) {\n        toast.hide();\n        // Close window and show HUD\n        await showHUD(`\u274C ${message}`);\n      } else {\n        // Keep window open - update existing toast in-place to avoid stale detail HUD\n        toast.style = Toast.Style.Failure;\n        toast.title = message;\n        toast.message = undefined;\n        toast.primaryAction = undefined;\n      }\n    },\n    hide: () => {\n      toast.hide();\n    },\n  };\n}\n\n/**\n * Show a Brew-specific failure toast with error details and optional retry action.\n *\n * Unlike the standard `showFailureToast` from `@raycast/utils`, this function:\n * - Detects Homebrew lock errors and shows \"Brew is Busy\" with helpful context\n * - Logs structured error details (stderr, exit code, error type) via uiLogger\n * - Provides a \"Copy Logs\" action with brew-specific troubleshooting tips\n * - Supports conditional retry for recoverable brew errors\n * - Silently ignores AbortError (user-initiated cancellations)\n *\n * Use this for all Homebrew operations. Use `showFailureToast` from `@raycast/utils`\n * for general extension errors unrelated to brew commands.\n */\nexport async function showBrewFailureToast(\n  title: string,\n  error: Error,\n  options?: { retryAction?: () => Promise<void> },\n): Promise<void> {\n  if (error.name === \"AbortError\") {\n    uiLogger.log(\"Operation aborted by user\");\n    return;\n  }\n\n  const execError = error as ExecError;\n  const errorMessage = getErrorMessage(error);\n  const isLockError = isBrewLockError(error);\n\n  uiLogger.error(title, {\n    errorType: error.name,\n    message: error.message,\n    stderr: execError.stderr,\n    code: execError.code,\n    recoverable: isRecoverableError(error),\n    isLockError,\n  });\n\n  // Use a more specific title for lock errors\n  const toastTitle = isLockError ? \"Brew is Busy\" : title;\n\n  const toastOptions: Toast.Options = {\n    style: Toast.Style.Failure,\n    title: toastTitle,\n    message: errorMessage,\n    primaryAction: {\n      title: \"Copy Logs\",\n      onAction: () => {\n        // For lock errors, include more context in the copied log\n        const logContent = isLockError\n          ? `${toastTitle}\\n${errorMessage}\\n\\nTip: Check Activity Monitor or run 'ps aux | grep brew' in Terminal to see what's running.`\n          : errorMessage;\n        Clipboard.copy(logContent);\n      },\n    },\n  };\n\n  // Add retry action for recoverable errors (including lock errors)\n  if (isRecoverableError(error) && options?.retryAction) {\n    const retryAction = options.retryAction;\n    toastOptions.secondaryAction = {\n      title: \"Retry\",\n      onAction: async (toast) => {\n        toast.style = Toast.Style.Animated;\n        toast.title = \"Retrying...\";\n        toast.message = undefined;\n        try {\n          await retryAction();\n          toast.style = Toast.Style.Success;\n          toast.title = \"Success\";\n        } catch (retryError) {\n          toast.style = Toast.Style.Failure;\n          toast.title = isBrewLockError(retryError) ? \"Brew is Busy\" : title;\n          toast.message = getErrorMessage(retryError);\n        }\n      },\n    };\n  }\n\n  const toast = new Toast(toastOptions);\n  await toast.show();\n}\n", "/**\n * Array prototype extensions for the Brew extension.\n *\n * Adds utility methods to Array prototype for convenience.\n * These are used throughout the extension for working with search results.\n */\n\n/// Array Extensions\n\ndeclare global {\n  interface Array<T> {\n    /** Total length before truncation (for paginated results) */\n    totalLength?: number;\n    /** Get the first element of the array */\n    first(): T | undefined;\n    /** Get the last element of the array */\n    last(): T | undefined;\n    /** Check if the array was truncated (totalLength > length) */\n    isTruncated(): boolean;\n  }\n}\n\nif (!Array.prototype.first) {\n  Array.prototype.first = function <T>(this: T[]): T | undefined {\n    return this.at(0);\n  };\n}\n\nif (!Array.prototype.last) {\n  Array.prototype.last = function <T>(this: T[]): T | undefined {\n    return this.at(-1);\n  };\n}\n\nif (!Array.prototype.isTruncated) {\n  Array.prototype.isTruncated = function <T>(this: T[]): boolean {\n    if (this.totalLength) {\n      return this.length < this.totalLength;\n    }\n    return false;\n  };\n}\n\n/// String Extensions\n\ndeclare global {\n  interface StringConstructor {\n    ellipsis: string;\n  }\n}\n\nif (!String.ellipsis) {\n  String.ellipsis = \"\u2026\";\n}\n\n// Export empty object to make this a module\nexport {};\n", "/**\n * Async utilities for the Brew extension.\n *\n * Provides helper functions for async operations.\n */\n\nimport { setTimeout } from \"node:timers\";\n\n/**\n * Wait for a specified number of milliseconds.\n *\n * Useful for:\n * - Waiting for toast actions to be clicked\n * - Implementing retry delays\n * - Debouncing operations\n *\n * Note: For \"no view\" commands, this allows users time to click Toast actions.\n * See: https://raycastapp.slack.com/archives/C01E6LWGXJ8/p1642676284027700\n */\nexport async function wait(ms: number): Promise<void> {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n", "/**\n * Memory diagnostics utilities.\n *\n * Provides functions for monitoring memory usage in Raycast's constrained\n * worker environment. Helps identify memory issues and potential leaks.\n *\n * Usage:\n *   import { memoryLogger, logMemory, withMemoryTracking } from \"./memory\";\n *\n *   // Simple logging\n *   logMemory(\"Before large operation\");\n *\n *   // Track memory around an operation\n *   const result = await withMemoryTracking(\"fetchFormulae\", async () => {\n *     return await fetchData();\n *   });\n */\n\nimport { Logger } from \"@chrismessina/raycast-logger\";\n\n/**\n * Memory logger instance.\n */\nexport const memoryLogger = new Logger({\n  prefix: \"[Brew]\",\n}).child(\"[Memory]\");\n\n/**\n * Memory usage snapshot with additional context.\n */\nexport interface MemorySnapshot {\n  /** Timestamp of the snapshot */\n  timestamp: number;\n  /** Label for this snapshot */\n  label: string;\n  /** Resident Set Size - total memory allocated to the process */\n  rss: number;\n  /** Total heap size allocated */\n  heapTotal: number;\n  /** Heap memory currently in use */\n  heapUsed: number;\n  /** Memory used by external C++ objects */\n  external: number;\n  /** Memory used by ArrayBuffers */\n  arrayBuffers: number;\n  /** Percentage of heap used (heapUsed / heapTotal) */\n  heapPercent: number;\n  /** Caller information (function name, file, line) */\n  caller?: CallerInfo;\n  /** Stack trace (if enabled) */\n  stack?: string;\n}\n\n/**\n * Caller information extracted from stack trace.\n */\nexport interface CallerInfo {\n  /** Function name */\n  functionName: string;\n  /** File path */\n  fileName: string;\n  /** Line number */\n  lineNumber: number;\n  /** Column number */\n  columnNumber: number;\n}\n\n/**\n * Memory tracking result for operations.\n */\nexport interface MemoryTrackingResult<T> {\n  /** The result of the tracked operation */\n  result: T;\n  /** Memory snapshot before the operation */\n  before: MemorySnapshot;\n  /** Memory snapshot after the operation */\n  after: MemorySnapshot;\n  /** Memory delta (after - before) */\n  delta: MemoryDelta;\n  /** Duration of the operation in milliseconds */\n  durationMs: number;\n}\n\n/**\n * Memory delta between two snapshots.\n */\nexport interface MemoryDelta {\n  rss: number;\n  heapTotal: number;\n  heapUsed: number;\n  external: number;\n  arrayBuffers: number;\n}\n\n/**\n * Warning thresholds for memory usage.\n */\nconst MEMORY_THRESHOLDS = {\n  /** Warn when heap usage exceeds this percentage */\n  heapPercentWarning: 70,\n  /** Critical when heap usage exceeds this percentage */\n  heapPercentCritical: 85,\n  /** Warn when a single operation increases heap by this many MB */\n  deltaWarningMB: 50,\n};\n\n/**\n * Format bytes to a human-readable string.\n */\nfunction formatBytes(bytes: number): string {\n  if (bytes < 1024) return `${bytes} B`;\n  if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;\n  return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;\n}\n\n/**\n * Parse a V8 stack trace line to extract caller info.\n * Format: \"    at functionName (filePath:line:column)\"\n * Or:     \"    at filePath:line:column\"\n */\nfunction parseStackLine(line: string): CallerInfo | undefined {\n  // Match: \"at functionName (filePath:line:column)\"\n  const withFunctionMatch = line.match(/at\\s+(.+?)\\s+\\((.+):(\\d+):(\\d+)\\)/);\n  if (withFunctionMatch) {\n    return {\n      functionName: withFunctionMatch[1],\n      fileName: withFunctionMatch[2],\n      lineNumber: parseInt(withFunctionMatch[3], 10),\n      columnNumber: parseInt(withFunctionMatch[4], 10),\n    };\n  }\n\n  // Match: \"at filePath:line:column\" (anonymous function)\n  const anonymousMatch = line.match(/at\\s+(.+):(\\d+):(\\d+)/);\n  if (anonymousMatch) {\n    return {\n      functionName: \"<anonymous>\",\n      fileName: anonymousMatch[1],\n      lineNumber: parseInt(anonymousMatch[2], 10),\n      columnNumber: parseInt(anonymousMatch[3], 10),\n    };\n  }\n\n  return undefined;\n}\n\n/**\n * Get caller information from the current stack trace.\n * @param skipFrames Number of stack frames to skip (default: 2 to skip this function and the caller)\n */\nfunction getCallerInfo(skipFrames = 2): CallerInfo | undefined {\n  const stack = new Error().stack;\n  if (!stack) return undefined;\n\n  const lines = stack.split(\"\\n\");\n  // Skip \"Error\" line and the specified number of frames\n  const callerLine = lines[skipFrames + 1];\n  if (!callerLine) return undefined;\n\n  return parseStackLine(callerLine);\n}\n\n/**\n * Get a cleaned stack trace string.\n * @param skipFrames Number of stack frames to skip\n * @param maxFrames Maximum number of frames to include\n */\nfunction getStackTrace(skipFrames = 2, maxFrames = 5): string {\n  const stack = new Error().stack;\n  if (!stack) return \"\";\n\n  const lines = stack.split(\"\\n\");\n  // Skip \"Error\" line and the specified number of frames\n  const relevantLines = lines.slice(skipFrames + 1, skipFrames + 1 + maxFrames);\n\n  return relevantLines.map((line) => line.trim()).join(\"\\n\");\n}\n\n/**\n * Take a memory snapshot with caller information.\n * @param label A descriptive label for this snapshot\n * @param includeStack Whether to include the full stack trace\n */\nexport function takeMemorySnapshot(label: string, includeStack = false): MemorySnapshot {\n  const mem = process.memoryUsage();\n  const heapPercent = mem.heapTotal > 0 ? (mem.heapUsed / mem.heapTotal) * 100 : 0;\n\n  const snapshot: MemorySnapshot = {\n    timestamp: Date.now(),\n    label,\n    rss: mem.rss,\n    heapTotal: mem.heapTotal,\n    heapUsed: mem.heapUsed,\n    external: mem.external,\n    arrayBuffers: mem.arrayBuffers,\n    heapPercent,\n    caller: getCallerInfo(3), // Skip: takeMemorySnapshot, logMemory/withMemoryTracking, actual caller\n  };\n\n  if (includeStack) {\n    snapshot.stack = getStackTrace(3);\n  }\n\n  return snapshot;\n}\n\n/**\n * Calculate the delta between two memory snapshots.\n */\nfunction calculateDelta(before: MemorySnapshot, after: MemorySnapshot): MemoryDelta {\n  return {\n    rss: after.rss - before.rss,\n    heapTotal: after.heapTotal - before.heapTotal,\n    heapUsed: after.heapUsed - before.heapUsed,\n    external: after.external - before.external,\n    arrayBuffers: after.arrayBuffers - before.arrayBuffers,\n  };\n}\n\n/**\n * Get a warning indicator based on heap percentage.\n */\nfunction getWarningIndicator(heapPercent: number): string {\n  if (heapPercent >= MEMORY_THRESHOLDS.heapPercentCritical) return \"\uD83D\uDD34 CRITICAL\";\n  if (heapPercent >= MEMORY_THRESHOLDS.heapPercentWarning) return \"\u26A0\uFE0F HIGH\";\n  return \"\";\n}\n\n/**\n * Format a memory snapshot for logging.\n */\nfunction formatSnapshot(snapshot: MemorySnapshot): Record<string, unknown> {\n  const warning = getWarningIndicator(snapshot.heapPercent);\n\n  const result: Record<string, unknown> = {\n    label: snapshot.label,\n    heapUsed: formatBytes(snapshot.heapUsed),\n    heapTotal: formatBytes(snapshot.heapTotal),\n    heapPercent: `${snapshot.heapPercent.toFixed(1)}%`,\n    rss: formatBytes(snapshot.rss),\n  };\n\n  if (warning) {\n    result.warning = warning;\n  }\n\n  if (snapshot.caller) {\n    const { functionName, fileName, lineNumber } = snapshot.caller;\n    // Shorten file path for readability\n    const shortFileName = fileName.split(\"/\").slice(-2).join(\"/\");\n    result.caller = `${functionName} (${shortFileName}:${lineNumber})`;\n  }\n\n  if (snapshot.stack) {\n    result.stack = snapshot.stack;\n  }\n\n  return result;\n}\n\n/**\n * Log current memory usage with caller information.\n * @param label A descriptive label for this log entry\n * @param includeStack Whether to include the full stack trace\n */\nexport function logMemory(label: string, includeStack = false): MemorySnapshot {\n  const snapshot = takeMemorySnapshot(label, includeStack);\n  memoryLogger.log(label, formatSnapshot(snapshot));\n  return snapshot;\n}\n\n/**\n * Log a warning if memory usage is high.\n * @param label A descriptive label\n * @param snapshot The memory snapshot to check\n */\nfunction logMemoryWarning(label: string, snapshot: MemorySnapshot): void {\n  if (snapshot.heapPercent >= MEMORY_THRESHOLDS.heapPercentCritical) {\n    memoryLogger.error(`${label} - CRITICAL memory usage`, {\n      ...formatSnapshot(snapshot),\n      recommendation: \"Consider reducing data size or clearing cache\",\n    });\n  } else if (snapshot.heapPercent >= MEMORY_THRESHOLDS.heapPercentWarning) {\n    memoryLogger.warn(`${label} - High memory usage`, formatSnapshot(snapshot));\n  }\n}\n\n/**\n * Track memory usage around an async operation.\n * Logs before/after snapshots and the delta.\n *\n * @param operationName Name of the operation being tracked\n * @param operation The async operation to track\n * @param options Tracking options\n * @returns The result of the operation along with memory tracking data\n */\nexport async function withMemoryTracking<T>(\n  operationName: string,\n  operation: () => Promise<T>,\n  options: { includeStack?: boolean; logAlways?: boolean } = {},\n): Promise<MemoryTrackingResult<T>> {\n  const { includeStack = false, logAlways = true } = options;\n\n  const before = takeMemorySnapshot(`Before ${operationName}`, includeStack);\n  const startTime = Date.now();\n\n  if (logAlways) {\n    memoryLogger.log(`Starting: ${operationName}`, formatSnapshot(before));\n  }\n\n  let result: T;\n  try {\n    result = await operation();\n  } catch (error) {\n    // Log memory state on error\n    const errorSnapshot = takeMemorySnapshot(`Error in ${operationName}`, true);\n    memoryLogger.error(`Memory state at error in ${operationName}`, {\n      ...formatSnapshot(errorSnapshot),\n      error: error instanceof Error ? error.message : String(error),\n    });\n    throw error;\n  }\n\n  const after = takeMemorySnapshot(`After ${operationName}`, includeStack);\n  const durationMs = Date.now() - startTime;\n  const delta = calculateDelta(before, after);\n\n  const deltaHeapMB = delta.heapUsed / (1024 * 1024);\n  const isLargeDelta = Math.abs(deltaHeapMB) >= MEMORY_THRESHOLDS.deltaWarningMB;\n\n  if (logAlways || isLargeDelta) {\n    memoryLogger.log(`Completed: ${operationName}`, {\n      durationMs,\n      heapDelta: formatBytes(delta.heapUsed),\n      heapBefore: formatBytes(before.heapUsed),\n      heapAfter: formatBytes(after.heapUsed),\n      heapPercent: `${after.heapPercent.toFixed(1)}%`,\n      ...(isLargeDelta ? { warning: `\u26A0\uFE0F Large heap change: ${deltaHeapMB.toFixed(1)} MB` } : {}),\n    });\n  }\n\n  // Check for warnings after operation\n  logMemoryWarning(operationName, after);\n\n  return {\n    result,\n    before,\n    after,\n    delta,\n    durationMs,\n  };\n}\n\n/**\n * Synchronous version of withMemoryTracking for non-async operations.\n */\nexport function withMemoryTrackingSync<T>(\n  operationName: string,\n  operation: () => T,\n  options: { includeStack?: boolean; logAlways?: boolean } = {},\n): MemoryTrackingResult<T> {\n  const { includeStack = false, logAlways = true } = options;\n\n  const before = takeMemorySnapshot(`Before ${operationName}`, includeStack);\n  const startTime = Date.now();\n\n  if (logAlways) {\n    memoryLogger.log(`Starting: ${operationName}`, formatSnapshot(before));\n  }\n\n  let result: T;\n  try {\n    result = operation();\n  } catch (error) {\n    const errorSnapshot = takeMemorySnapshot(`Error in ${operationName}`, true);\n    memoryLogger.error(`Memory state at error in ${operationName}`, {\n      ...formatSnapshot(errorSnapshot),\n      error: error instanceof Error ? error.message : String(error),\n    });\n    throw error;\n  }\n\n  const after = takeMemorySnapshot(`After ${operationName}`, includeStack);\n  const durationMs = Date.now() - startTime;\n  const delta = calculateDelta(before, after);\n\n  const deltaHeapMB = delta.heapUsed / (1024 * 1024);\n  const isLargeDelta = Math.abs(deltaHeapMB) >= MEMORY_THRESHOLDS.deltaWarningMB;\n\n  if (logAlways || isLargeDelta) {\n    memoryLogger.log(`Completed: ${operationName}`, {\n      durationMs,\n      heapDelta: formatBytes(delta.heapUsed),\n      heapBefore: formatBytes(before.heapUsed),\n      heapAfter: formatBytes(after.heapUsed),\n      heapPercent: `${after.heapPercent.toFixed(1)}%`,\n      ...(isLargeDelta ? { warning: `\u26A0\uFE0F Large heap change: ${deltaHeapMB.toFixed(1)} MB` } : {}),\n    });\n  }\n\n  logMemoryWarning(operationName, after);\n\n  return {\n    result,\n    before,\n    after,\n    delta,\n    durationMs,\n  };\n}\n\n/**\n * Get a summary of current memory usage.\n * Useful for periodic health checks.\n */\nexport function getMemorySummary(): {\n  heapUsed: string;\n  heapTotal: string;\n  heapPercent: string;\n  rss: string;\n  status: \"ok\" | \"warning\" | \"critical\";\n} {\n  const mem = process.memoryUsage();\n  const heapPercent = mem.heapTotal > 0 ? (mem.heapUsed / mem.heapTotal) * 100 : 0;\n\n  let status: \"ok\" | \"warning\" | \"critical\" = \"ok\";\n  if (heapPercent >= MEMORY_THRESHOLDS.heapPercentCritical) {\n    status = \"critical\";\n  } else if (heapPercent >= MEMORY_THRESHOLDS.heapPercentWarning) {\n    status = \"warning\";\n  }\n\n  return {\n    heapUsed: formatBytes(mem.heapUsed),\n    heapTotal: formatBytes(mem.heapTotal),\n    heapPercent: `${heapPercent.toFixed(1)}%`,\n    rss: formatBytes(mem.rss),\n    status,\n  };\n}\n"],
  "mappings": "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",
  "names": ["exports", "redactString", "sanitizeArgs", "maskEmail", "text", "_m", "p1", "p2", "input", "s", "redactValueByKey", "key", "value", "k", "json", "prop", "val", "args", "arg", "api_1", "redaction_1", "Logger", "_Logger", "config", "error", "message", "args", "formattedMessage", "processedMessage", "processedArgs", "prefix", "childPrefix", "exports", "logger_1", "exports", "redaction_1", "require_stream_chain", "__commonJSMin", "exports", "module", "Readable", "Writable", "Duplex", "Transform", "none", "finalSymbol", "manySymbol", "final", "value", "many", "values", "isFinal", "o", "isMany", "getFinalValue", "getManyValues", "runAsyncGenerator", "gen", "stream", "data", "Chain", "wrapFunction", "fn", "chunk", "encoding", "callback", "result", "error", "wrapArray", "fns", "i", "isReadableNodeStream", "obj", "isWritableNodeStream", "isDuplexNodeStream", "_Chain", "options", "index", "s", "output", "_1", "_2", "e", "require_Utf8Stream", "__commonJSMin", "exports", "module", "Transform", "StringDecoder", "Utf8Stream", "options", "chunk", "encoding", "callback", "_", "require_Parser", "__commonJSMin", "exports", "module", "Utf8Stream", "patterns", "MAX_PATTERN_SIZE", "noSticky", "key", "src", "values", "expected", "fromHex", "codes", "Parser", "_Parser", "options", "callback", "error", "match", "value", "index", "main", "t", "require_emit", "__commonJSMin", "exports", "module", "emit", "stream", "item", "require_stream_json", "__commonJSMin", "exports", "module", "Parser", "emit", "make", "options", "require_FilterBase", "__commonJSMin", "exports", "module", "Transform", "FilterBase", "_FilterBase", "string", "separator", "stack", "path", "regExp", "array", "options", "filter", "replacement", "chunk", "_", "callback", "passValue", "last", "post", "expected", "skipValue", "require_withParser", "__commonJSMin", "exports", "module", "chain", "Parser", "withParser", "fn", "options", "require_Filter", "__commonJSMin", "exports", "module", "FilterBase", "withParser", "Filter", "_Filter", "options", "callback", "chunk", "stack", "last", "stackLength", "lastLength", "commonLength", "n", "i", "key", "require_Assembler", "__commonJSMin", "exports", "module", "EventEmitter", "startObject", "Ctr", "Assembler", "_Assembler", "stream", "options", "chunk", "path", "i", "key", "level", "index", "value", "require_StreamBase", "__commonJSMin", "exports", "module", "Transform", "Assembler", "Counter", "initialDepth", "StreamBase", "options", "chunk", "encoding", "callback", "result", "require_StreamArray", "__commonJSMin", "exports", "module", "StreamBase", "withParser", "StreamArray", "_StreamArray", "options", "chunk", "_", "callback", "discard", "clean_up_exports", "__export", "clean_up_default", "__toCommonJS", "import_api", "import_child_process", "import_path", "import_os", "import_api", "preferences", "brewPrefix", "preferences", "path_join", "brewPath", "suffix", "brewExecutable", "import_child_process", "import_util", "import_fs", "fs", "import_path", "import_api", "import_raycast_logger", "logger", "brewLogger", "cacheLogger", "actionsLogger", "fetchLogger", "searchLogger", "uiLogger", "BrewError", "message", "options", "NetworkError", "BrewCommandError", "BrewError", "message", "options", "BrewNotFoundError", "BrewLockError", "BrewError", "message", "options", "DownloadTimeoutError", "StaleProcessError", "PackageNotFoundError", "PackageDisabledError", "PackageConflictError", "UnsupportedMacOSError", "isNetworkError", "error", "NetworkError", "isBrewLockError", "BrewLockError", "isDownloadTimeoutError", "DownloadTimeoutError", "isStaleProcessError", "StaleProcessError", "isRecoverableError", "error", "isNetworkError", "isBrewLockError", "isDownloadTimeoutError", "isStaleProcessError", "BREW_LOCK_PATTERNS", "DISABLED_PACKAGE_PATTERN", "isBrewLockMessage", "message", "BREW_LOCK_PATTERNS", "pattern", "parseDisabledPackageMessage", "message", "match", "DISABLED_PACKAGE_PATTERN", "ensureError", "err", "getErrorMessage", "error", "BrewLockError", "DownloadTimeoutError", "pkg", "phase", "StaleProcessError", "PackageDisabledError", "type", "message", "PackageConflictError", "conflicts", "UnsupportedMacOSError", "NetworkError", "BrewNotFoundError", "PackageNotFoundError", "BrewCommandError", "disabledInfo", "parseDisabledPackageMessage", "BrewError", "execError", "import_api", "import_path", "import_fs", "import_stream_chain", "import_stream_json", "import_Filter", "import_StreamArray", "supportPath", "fs", "cacheLogger", "bundleIdentifier", "path", "comp", "cachePath", "name", "getChunkedCacheConfig", "type", "baseDir", "path", "supportPath", "execp", "homebrewEnvLogged", "execBrew", "cmd", "options", "env", "execBrewEnv", "brewExecutable", "err", "execErr", "errorOutput", "isBrewLockMessage", "brewLogger", "BrewLockError", "preferences", "askpassPath", "path_join", "fs_constants", "bundleIdentifier", "downloadConcurrencyDisabled", "useInternalApi", "DEFAULT_STALE_TIMEOUT_MS", "DOWNLOAD_PHASE_TIMEOUT_MS", "installedCachePath", "cachePath", "formulaCachePath", "caskCachePath", "formulaURL", "caskURL", "formulaRemote", "getChunkedCacheConfig", "caskRemote", "brewCleanup", "withoutThreshold", "cancel", "actionsLogger", "cmd", "execBrew", "import_api", "showActionToast", "actionOptions", "options", "controller", "toast", "message", "title", "preferences", "showBrewFailureToast", "error", "uiLogger", "execError", "errorMessage", "getErrorMessage", "isLockError", "isBrewLockError", "isRecoverableError", "toastTitle", "toastOptions", "logContent", "retryAction", "retryError", "import_node_timers", "wait", "ms", "resolve", "import_raycast_logger", "memoryLogger", "clean_up_default", "handle", "showActionToast", "brewCleanup", "preferences", "err", "showBrewFailureToast", "ensureError", "wait"]
}
